"""
Requires that exactly one field must be supplied and that field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

"""Exposes a URL that specifies the behavior of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behavior of this scalar."""
  url: String!
) on SCALAR

type AcceptanceEmail {
  html: String! @deprecated(reason: "Use the safeHtml type instead.")
  safeHtml: Html!
  subject: String!
  template: EmailTemplate!
}

type AccessToken {
  application: ApiApplication!
  id: ID!
}

type Account {
  accountType: String
  code: String
  createdAt: DateTime!
  id: ID!
  importedFrom: AccountImportedFrom
  name: String!
  state: AccountState!
  updatedAt: DateTime!
  uuid: ID! @deprecated(reason: "use id instead")
}

"""The connection type for Account."""
type AccountConnection {
  """A list of edges."""
  edges: [AccountEdge!]!

  """A list of nodes."""
  nodes: [Account!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AccountEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Account!
}

enum AccountImportedFrom {
  """Xero"""
  XERO
}

input AccountQuery {
  importedFromEq: String
}

enum AccountState {
  """Active"""
  ACTIVE

  """Archived"""
  ARCHIVED
}

input AcknowledgeFilter {
  idCont: String
  idStartsWith: String
}

type Acknowledgement {
  id: ID!
  level: AcknowledgementLevel!
  updatedAt: DateTime!
}

"""Autogenerated input type of AcknowledgementAdd"""
input AcknowledgementAddInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """identifier of acknowledgement content"""
  id: ID!
  level: AcknowledgementLevel!
}

"""Autogenerated return type of AcknowledgementAdd."""
type AcknowledgementAddPayload {
  acknowledgement: Acknowledgement
  acknowledgements: [Acknowledgement!]

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

enum AcknowledgementLevel {
  USER
  PRACTICE
}

"""Autogenerated input type of AcknowledgementRemove"""
input AcknowledgementRemoveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """identifier of acknowledgement content"""
  id: ID!
  level: AcknowledgementLevel!
}

"""Autogenerated return type of AcknowledgementRemove."""
type AcknowledgementRemovePayload {
  acknowledgements: [Acknowledgement!]

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

type ActivityLog {
  additionalInfo: String
  createdAt: DateTime!
  id: ID!
  level: ActivityLogLevel!
  message: String!
  relationId: ID!
  updatedAt: DateTime!

  """The user associated with the activity (if any)."""
  user: User
}

"""The connection type for ActivityLog."""
type ActivityLogConnection {
  """A list of edges."""
  edges: [ActivityLogEdge!]!

  """A list of nodes."""
  nodes: [ActivityLog!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ActivityLogEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ActivityLog!
}

enum ActivityLogLevel {
  ERROR
  INFO
  SUCCESS
  WARNING
}

input ActivityLogOrder {
  """Sort by when the activity log was created."""
  createdAt: OrderBy
}

"""An address"""
type Address {
  address: String @deprecated(reason: "use lines instead")

  """City or Suburb"""
  city: String
  client: Client!

  """Full country name"""
  country: String
  createdAt: DateTime!
  isPostal: Boolean!

  """
  Free text part of an address with each line a separate entry. Usually one or two
  """
  lines: [String!]!
  postCode: String @deprecated(reason: "Use postcode")
  postcode: String
  referenceNumber: ID!

  """Region or State"""
  region: String
  updatedAt: DateTime!
}

"""The connection type for Address."""
type AddressConnection {
  """A list of edges."""
  edges: [AddressEdge!]!

  """A list of nodes."""
  nodes: [Address!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AddressEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Address!
}

input AddressFilter {
  isPostal: Boolean
}

input AddressInput {
  address: String
  lines: [String!]
  city: String
  region: String
  postCode: String
  postcode: String
  country: String
}

type AdminUser {
  createdAt: DateTime!
  email: EmailAddress!
  id: ID!
  roles: [String!]
  updatedAt: DateTime!
}

type AgreedService {
  """
  The Xero Integration account this service will be accounted to when invoiced
  """
  account: Account @deprecated(reason: "use ledgerItem")
  activities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    orderBy: ActivityLogOrder = {createdAt: ASCENDING}
  ): ActivityLogConnection
  billingDescription: String @deprecated(reason: "Agreed Service can have multiple portions. Use `portion.billing_description` instead.")
  billingMode: ProposalBillingModeEnum!
  billingSchedule: BillingSchedule! @deprecated(reason: "Use portions { billingSchedule } instead")
  billingSummary: String @deprecated(reason: "Agreed Service can have multiple portions. Use `portion.billing_summary` instead.")
  client: Client!
  description: Textile!

  """
  The date this service is scheduled to becomes inactive, provided all
  associated billing items have been billed. If not set, service will stay
  active until ended manually.
  """
  expiresOn: Date
  id: ID!
  invoiceStrategy: ProposalInvoiceStrategy @deprecated(reason: "use portions { invoiceStrategy } instead")
  isActive: Boolean @deprecated(reason: "Use state instead. An agreed service is active if it's state = 'enabled'.")
  isBillingCompleted: Boolean
  isEditable: Boolean!
  lastBillingDate: Date

  """Ledger Item. Currently only supports Xero account"""
  ledgerItem: LedgerItem
  name: String!
  origin: Origin
  paymentMethod: PaymentMethod
  portions: [AgreedServicePortion!]!
  price: ProposalPriceInterface!

  """Quantity Object containing amounts and rules"""
  quantity: BillingQuantityRuleInterface

  """
  If set, this is the agreed service that was / will be replaced once this agreed service is enabled.
  """
  replacee: AgreedService

  """
  If set, this is the agreed service that will replace / has replaced this one.
  """
  replacement: AgreedService

  """
  List of billing schedule items for all billable services linked to this agreed service
  """
  scheduleItems: [ScheduleItem!]!
  scheduleStart: String! @deprecated(reason: "Agreed Service can have multiple portions. Use `portion.schedule_start` instead.")
  scheduleType: BillingScheduleTypeEnum!
  service: Service!

  """The date this service becomes active."""
  startsOn: Date!
  state: ClientServicesAgreedServiceStateEnum!

  """The tax applied to this service"""
  tax: Tax!
  uneditableReason: String
}

"""The connection type for AgreedService."""
type AgreedServiceConnection {
  """A list of edges."""
  edges: [AgreedServiceEdge!]!

  """A list of nodes."""
  nodes: [AgreedService!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type AgreedServiceCreatePreview {
  billingItems: [BillingItemPreview!]!
  billingSummary: String!
  paymentMethod: PaymentMethod
}

"""An edge in a connection."""
type AgreedServiceEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: AgreedService!
}

input AgreedServiceFilter {
  stateIn: [ClientServicesAgreedServiceStateEnum!]
}

input AgreedServiceInput {
  description: String!
  serviceId: ID
  serviceName: String
  accountId: ID
  taxId: ID!
  quantity: QuantityRuleInput
  portions: [PortionInput!]!
}

type AgreedServicePortion {
  billingDescription: String!
  billingStart: ProposalStartBillingOnDate!
  billingSummary: String!
  id: ID!
  invoiceStrategy: ProposalInvoiceStrategy!
  name: String
  price: ProposalPriceInterface!
  recurrence: ProposalBillingStrategyType!
  rrule: RecurrenceRule
  scheduleStart: String!
}

type AgreedServiceUpdatePreview {
  billingItems: [BillingItem!]!
  billingSummary: String!
  changedValues: [ChangedValue!]!
  scheduleChangeDate: Date
}

"""Autogenerated input type of ApiAccessTokenRevoke"""
input ApiAccessTokenRevokeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Name of the application to revoke access from"""
  appName: String!
}

"""Autogenerated return type of ApiAccessTokenRevoke."""
type ApiAccessTokenRevokePayload {
  accessTokens: [AccessToken!]

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  userErrors: [UserError!]
}

type ApiApplication {
  id: ID!
  name: String!
}

"""
An App is an integration that implements generic, defined functionality that
extends core functionality, usually by integrating with an external system.  For
example, a Xero App may deploy client billing invoices to Xero.  These defined
functionalities are called Capabilities.  An App returned through this API is
Practice specific- the same App type may have different capabilities for
different Practices
"""
type App {
  appClients(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: AppClientFilter
  ): AppClientConnection!

  """AppServices in a search results format"""
  appServices(filter: IgnitionAppServiceFilterType, pagination: PaginationInput, sort: SearchQuerySortInput, asyncJobGroupId: ID): SearchQuery
  appTaxes(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: AppTaxFilter
  ): AppTaxConnection!
  appUsers(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: AppUserFilter
  ): AppUserConnection!

  """
  Capabilities are standard functionality that this App implements. A list of capabilities.
  """
  capabilities(filter: AppCapabilityFilter): [CapabilityWithState!]!
  clientSyncSettings: ClientSyncSettings

  """The name of this App to be shown in the user interface"""
  displayName: String!

  """A publicly available URL with the icon of the App"""
  icon: URL!

  """A unique identifier for this App"""
  id: ID!
  invoiceDeploySettings: InvoiceDeploySettings

  """The most recent client sync result (if any)."""
  latestClientSync: ClientSync
  ledgerItems(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): LedgerItemConnection!

  """A publicly available URL with the logo of the App"""
  logo: URL!

  """The globally unique name of this App"""
  name: String!
  userConfigurable: UserConfigurable
  workflowCategories(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): WorkflowCategoryTypeConnection!
  workflowTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): WorkflowTemplateTypeConnection!
}

"""Type for filtering App Capabilitites"""
input AppCapabilityFilter {
  """State of Capabilitites"""
  state: CapabilityStateEnum
}

"""
An AppClient is a counterpart to a Client that exists in an App's domain.
AppClients can be linked ("mapped") to Clients, and can be used to create
Clients. For example, a Customer in QuickBooks or Contact in Xero could be the
underlying record behind an AppClient.
"""
type AppClient implements ClientInterface {
  app: App!
  company: AppClientCompany!
  contacts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AppClientContactConnection!
  defaultContact: AppClientContact!
  email: String @deprecated(reason: "Use contacts or defaultContact.email")

  """An identifier used by the App this AppClient belongs to"""
  externalId: ID!
  id: ID!

  """Slug of the manager user"""
  managerId: String

  """Full name"""
  name: String!

  """Slug of the partner user"""
  partnerId: String
  physicalAddress: AppClientAddress
  postalAddress: AppClientAddress

  """Tags associated with this AppClient"""
  tags: [String!]!

  """Link to view this AppClient in external system"""
  url: String
}

type AppClientAddress {
  """City or Suburb"""
  city: String

  """Region or State"""
  country: String
  id: ID!

  """Address Lines"""
  lines: [String!]!
  postcode: String

  """Region or State"""
  region: String
}

type AppClientCompany {
  """
  The fax number of the Company, as opposed to the phone number of an individual
  """
  fax: String

  """
  Freeform text to store GST Information- may be Yes/No or a GST Registration number
  """
  gstRegistrationInfo: String

  """
  The phone number of the Company, as opposed to the phone number of an individual
  """
  phone: String

  """
  The Official number of the company- e.g. ABN/ACN in Australia, CRN in U.S.A., etc
  """
  registrationNumber: String

  """e.g. TFN in Australia, EIN in U.S.A., etc"""
  taxNumber: String

  """Free form Text description of the type of company"""
  type: String

  """The main website of the Company"""
  website: String
}

"""The connection type for AppClient."""
type AppClientConnection {
  """A list of edges."""
  edges: [AppClientEdge!]!

  """A list of nodes."""
  nodes: [AppClient!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type AppClientContact {
  addressee: String
  email: EmailAddress
  id: ID!
  mobile: String
  name: String!
  phone: String
  salutation: String
}

"""The connection type for AppClientContact."""
type AppClientContactConnection {
  """A list of edges."""
  edges: [AppClientContactEdge!]!

  """A list of nodes."""
  nodes: [AppClientContact!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AppClientContactEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: AppClientContact!
}

"""An edge in a connection."""
type AppClientEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: AppClient!
}

"""Type for filtering AppClients"""
input AppClientFilter {
  """Return AppClients with these IDs"""
  idsIn: [ID!]

  """Return AppClients with names containing this value"""
  nameCont: String

  """Return AppClients that belong to this app"""
  appName: String

  """If true, exclude AppClients mapped to a Client"""
  excludeMapped: Boolean = false
}

"""Input data identifying an AppClient"""
input AppClientInput {
  """The unique name of the App that the AppClient belongs to"""
  appName: String!

  """
  The ID of the AppClient to map to.  If missing, any existing mapping will be removed
  """
  id: ID
}

type AppClientProconnect {
  taxReturnType: String
}

type AppClientResult {
  appClient: AppClient
  appData: AppDataUnion!
  appName: String!
  createdAt: DateTime!
  email: String
  id: ID!
  ignitionappClient: Client
  ignitionappClientId: String
  isLinked: Boolean!
  lastSyncedAt: DateTime
  name: String!
  primaryContactEmail: String
  primaryContactName: String
  updatedAt: DateTime!
}

"""Autogenerated input type of AppConnect"""
input AppConnectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The name of the App to disconnect"""
  appName: String!

  """ID of the App Account to connect to"""
  accountId: ID!
}

"""The connection type for App."""
type AppConnection {
  """A list of edges."""
  edges: [AppEdge!]!

  """A list of nodes."""
  nodes: [App!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated return type of AppConnect."""
type AppConnectPayload {
  app: App!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

union AppDataUnion = AppClientProconnect

"""Autogenerated input type of AppDisconnect"""
input AppDisconnectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The name of the App to disconnect"""
  appName: String!
}

"""Autogenerated return type of AppDisconnect."""
type AppDisconnectPayload {
  app: App!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""An edge in a connection."""
type AppEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: App!
}

"""Autogenerated input type of AppEnable"""
input AppEnableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The name of the App to enable"""
  appName: String!
}

"""Autogenerated return type of AppEnable."""
type AppEnablePayload {
  app: App!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Type for filtering Apps"""
input AppFilter {
  """Return Apps that exactly match this name"""
  name: String

  """Return Apps that implement all these Capabilities"""
  capabilities: [CapabilityFilter!]
}

"""Autogenerated input type of AppSetClientSyncSettings"""
input AppSetClientSyncSettingsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  appName: String!
  settings: ClientSyncSettingsInput!
}

"""Autogenerated return type of AppSetClientSyncSettings."""
type AppSetClientSyncSettingsPayload {
  app: App!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of AppSync"""
input AppSyncInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The name of the App to sync"""
  appName: String!
}

"""Autogenerated return type of AppSync."""
type AppSyncPayload {
  app: App!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

type AppTax {
  app: App!

  """Tax Code (e.g. GST)"""
  code: String!

  """The app's own identifier for this tax."""
  externalId: ID!
  id: ID!

  """Tax Name (e.g. Sales Tax)"""
  name: String!

  """Tax Rate"""
  rate: Percentage!

  """Tax Rate as a decimal (e.g. 0.1 for 10%)"""
  rateLegacy: Decimal! @deprecated(reason: "Use rate instead.")
}

"""The connection type for AppTax."""
type AppTaxConnection {
  """A list of edges."""
  edges: [AppTaxEdge!]!

  """A list of nodes."""
  nodes: [AppTax!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AppTaxEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: AppTax!
}

"""Type for filtering AppTaxes"""
input AppTaxFilter {
  """Return AppTaxes that belong to this app"""
  appName: String

  """If true, exclude AppTaxes mapped to a Tax"""
  excludeMapped: Boolean = false
}

"""Input data identifying an AppTax"""
input AppTaxInput {
  """The unique name of the App that the AppTax belongs to"""
  appName: String!

  """
  The ID of the AppTax to map to. If missing, any existing mapping will be removed
  """
  id: ID
}

input AppTaxMappingInput {
  """The ID of the Ignition Tax."""
  taxId: ID!

  """
  The ID of the AppTax to map to. If null, the existing mapping will be removed.
  """
  appTaxId: ID
}

"""
An AppUser is a counterpart to a User that exists in an App's domain. AppUsers
can be linked ("mapped") to Users, and can be used to create Users.  For
example, a Staff member in Xero could be the underlying record behind an AppUser.
"""
type AppUser {
  app: App!
  email: String

  """An identifier used by the App this AppUser belongs to"""
  externalId: ID!
  id: ID!

  """Full name"""
  name: String!

  """Link to view this AppUser in external system"""
  url: String
}

"""The connection type for AppUser."""
type AppUserConnection {
  """A list of edges."""
  edges: [AppUserEdge!]!

  """A list of nodes."""
  nodes: [AppUser!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AppUserEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: AppUser!
}

"""Type for filtering AppUsers"""
input AppUserFilter {
  """Return AppUsers with names containing this value"""
  nameCont: String

  """Return AppUsers that belong to this app"""
  appName: String

  """If true, exclude AppUsers mapped to a User"""
  excludeMapped: Boolean = false
}

"""Input data identifying an AppUser"""
input AppUserInput {
  """The unique name of the App that the AppUser belongs to"""
  appName: String!

  """
  The ID of the AppUser to map to.  If missing, any existing mapping will be removed
  """
  id: ID
}

type AsyncJob {
  createdAt: DateTime!
  errors: [String!]!
  id: ID!
  resultSlug: String
  state: AsyncJobStateEnum!
  subjectSlug: String
  updatedAt: DateTime!
}

type AsyncJobGroup {
  failureCount: Int!
  groupType: AsyncJobGroupTypeEnum
  id: ID!
  jobs: [AsyncJob!]!
  name: String!
  state: AsyncJobGroupStateEnum!
  user: User
}

enum AsyncJobGroupStateEnum {
  PENDING
  COMPLETED
}

enum AsyncJobGroupTypeEnum {
  CLIENT_ARCHIVE
  PAYMENT_METHOD_REQUEST
  RENEWAL
  SEND_PROPOSALS
  CREATED_FROM_LEDGER
  CREATE_VIA_IMPORT
  CREATE_SERVICE_FROM_ITEM
  CREATE_PROPOSALS
}

enum AsyncJobStateEnum {
  PENDING
  SUCCESSFUL
  FAILED
}

type BackgroundJob {
  """sidekiq background job id"""
  id: String!

  """timestamp of when the job was queued"""
  queuedAt: DateTime!
}

type BankAccount {
  """The editable part of the payment descriptor"""
  descriptor: String

  """The prefix added to the statement descriptor during disbursal"""
  descriptorPrefix: String
  name: String
  number: String!
  routingNumber: String!
}

type BankAccountFailureEmailTemplate implements EmailTemplateInterface & PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  slug: ID!
  subject: String!
  updatedAt: DateTime!
}

"""Autogenerated input type of BankAccountFailureEmailTemplateUpdate"""
input BankAccountFailureEmailTemplateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of bank account failure email template"""
  id: ID!
  template: EmailTemplateInput!
}

"""Autogenerated return type of BankAccountFailureEmailTemplateUpdate."""
type BankAccountFailureEmailTemplateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: BankAccountFailureEmailTemplate
  templates: Templates
}

type BankAccountPaymentMethod implements PaymentsPaymentMethod {
  createdAt: DateTime!
  displayMethodType: String!
  id: ID!
  isInUse: Boolean!
  isInvalid: Boolean!
  name: String
  number: String
  numberSuffix: String!
  referenceNumber: ID!
  routingNumber: String!
  type: PaymentMethodType!
  verificationUrl: URL
  verified: Boolean!
}

type BankAccountVerificationEmailTemplate implements EmailTemplateInterface & PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  slug: ID!
  subject: String!
  updatedAt: DateTime!
}

"""Autogenerated input type of BankAccountVerificationEmailTemplateUpdate"""
input BankAccountVerificationEmailTemplateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of bank account verification email template"""
  id: ID!
  template: EmailTemplateInput!
}

"""
Autogenerated return type of BankAccountVerificationEmailTemplateUpdate.
"""
type BankAccountVerificationEmailTemplateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: BankAccountVerificationEmailTemplate
  templates: Templates
}

"""Represents non-fractional signed whole numeric values."""
scalar BigInt

type BillableService {
  billingGroup: BillingGroup!
  billingItems(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): BillingItemConnection
  description: Textile!
  id: ID!
  invoiceStrategy: ProposalInvoiceStrategy
  name: String!
  price: ProposalPriceInterface!

  """Quantity Object containing amounts and rules"""
  quantity: BillingQuantityRuleInterface
}

"""The connection type for BillableService."""
type BillableServiceConnection {
  """A list of edges."""
  edges: [BillableServiceEdge!]!

  """A list of nodes."""
  nodes: [BillableService!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type BillableServiceEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: BillableService!
}

type BillingEstimateQuantityRule implements BillingQuantityRuleInterface {
  """
  Quantity amount. Either a calculated amount or a estimate amount depending on the type
  """
  amount: Decimal

  """Type of quantity rule"""
  type: BillingQuantityRuleType!
}

type BillingFixedPriceRule implements BillingPriceRuleInterface {
  """Amount"""
  amount: Money!

  """Description of the price rule"""
  description: String!

  """Type of price rule"""
  type: BillingPriceRuleType!
}

type BillingGroup {
  """The billing items belonging to this billing group."""
  billingItems(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: BillingItemFilter
  ): ClientBillingBillingItemConnection!

  """
  The billing group reference number.
  
  This is used in combination with a Workflow integration, where workflows
  can be configured to receive credits when services belonging to a billing group
  with that reference are invoiced.
  
  """
  billingReference: String!
  id: ID!

  """The invoices issued for this billing group."""
  invoices(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClientBillingInvoiceConnection!

  """
  Denotes whether there are unbilled services assigned this billing group.
  """
  isInUse: Boolean! @deprecated(reason: "use invoices { count }")

  """Name of billing group."""
  name: String!

  """Source of billing group"""
  source: ClientBillingBillingGroupSource

  """The type of this billing group."""
  type: ClientBillingBillingGroupType!

  """The workflow strategies assigned this billing group."""
  workflowStrategies(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: ClientWorkflowStrategyFilter
    orderBy: ClientWorkflowStrategyOrder
  ): ClientWorkflowStrategyConnection!
}

"""The connection type for BillingGroup."""
type BillingGroupConnection {
  """A list of edges."""
  edges: [BillingGroupEdge!]!

  """A list of nodes."""
  nodes: [BillingGroup!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type BillingGroupEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: BillingGroup!
}

type BillingIncludedPriceRule implements BillingPriceRuleInterface {
  """Description of the price rule"""
  description: String!

  """Type of price rule"""
  type: BillingPriceRuleType!
}

type BillingItem {
  """The value of this billing item excluding tax"""
  amount: Money

  """The total value of this billing item, including tax"""
  amountWithTax: Money
  billOn: Date!
  billableService: BillableService!
  billingGroup: BillingGroup!
  billingName: String
  date: Date @deprecated(reason: "Use billOn instead")
  description: Textile!

  """The total discount applied"""
  discount: Money
  groupId: ID!
  id: ID!
  invoiceStrategy: ProposalInvoiceStrategy
  name: String!
  notes: String
  origin: Origin
  paymentMethod: PaymentMethod
  price: Money @deprecated(reason: "Use unitPrice instead")
  priceRule: ProposalPriceInterface!
  quantity: Decimal @deprecated(reason: "Use quantity_rule instead.")

  """Quantity rule object containing amounts and rules"""
  quantityRule: BillingQuantityRuleInterface!
  state: ClientBillingBillingItemState!

  """The value of the tax component of this billing item"""
  taxAmount: Money
  unitPrice: Money
  unitPriceWithTax: Money
}

"""The connection type for BillingItem."""
type BillingItemConnection {
  """A list of edges."""
  edges: [BillingItemEdge!]!

  """A list of nodes."""
  nodes: [BillingItem!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type BillingItemEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: BillingItem!
}

input BillingItemFilter {
  dateIn: DateRangeInput
  strategyEq: ProposalInvoiceStrategy
  stateIn: ClientBillingBillingItemState
}

type BillingItemGroup {
  """Total value of this billing group, excluding tax"""
  amount: Money

  """Total value of this billing group, including tax"""
  amountWithTax: Money
  billingStrategy: ProposalInvoiceStrategy!
  date: Date
  id: ID!
  items(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): BillingItemConnection!
  paymentMethod: PaymentMethod

  """Value of the tax on this billing group"""
  taxAmount: Money
  totalPrice: Money @deprecated(reason: "Use amount instead")
}

"""The connection type for BillingItemGroup."""
type BillingItemGroupConnection {
  """A list of edges."""
  edges: [BillingItemGroupEdge!]!

  """A list of nodes."""
  nodes: [BillingItemGroup!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type BillingItemGroupEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: BillingItemGroup!
}

input BillingItemInput {
  id: ID!

  """Quantity rule"""
  quantityRule: QuantityRuleInput!
  groupId: String!

  """price in dollar"""
  price: Decimal
  notes: String

  """discount in dollar"""
  discount: Decimal
}

type BillingItemPreview {
  billOn: Date!
  id: ID!
  name: String!
  priceRule: ProposalPriceInterface!
}

type BillingMinimumPriceRule implements BillingPriceRuleInterface {
  """Description of the price rule"""
  description: String!

  """Minimum amount"""
  minimum: Money!

  """Type of price rule"""
  type: BillingPriceRuleType!
}

"""Autogenerated input type of BillingPriceRuleAddUnitName"""
input BillingPriceRuleAddUnitNameInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """custom unit name"""
  name: String!
}

"""Autogenerated return type of BillingPriceRuleAddUnitName."""
type BillingPriceRuleAddUnitNamePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  priceRuleUnitName: PriceRuleUnitName!
}

"""Autogenerated input type of BillingPriceRuleDeleteUnitName"""
input BillingPriceRuleDeleteUnitNameInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Custom Unit Name"""
  id: ID!
}

"""Autogenerated return type of BillingPriceRuleDeleteUnitName."""
type BillingPriceRuleDeleteUnitNamePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customUnitPriceNames(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PriceRuleUnitNameConnection!
}

interface BillingPriceRuleInterface {
  """Description of the price rule"""
  description: String!

  """Type of price rule"""
  type: BillingPriceRuleType!
}

enum BillingPriceRuleType {
  FIXED
  HOURLY
  INCLUDED
  MINIMUM
  UNIT
  RANGE
}

interface BillingQuantityRuleInterface {
  """
  Quantity amount. Either a calculated amount or a estimate amount depending on the type
  """
  amount: Decimal

  """Type of quantity rule"""
  type: BillingQuantityRuleType!
}

enum BillingQuantityRuleType {
  ESTIMATE
  SMART_BILLING
}

type BillingRangePriceRule implements BillingPriceRuleInterface {
  """Description of the price rule"""
  description: String!

  """Maximum amount"""
  maximum: Money!

  """Minimum amount"""
  minimum: Money!

  """Type of price rule"""
  type: BillingPriceRuleType!
}

type BillingSchedule {
  billingDescription: String
  billingSummary: String
  dates: [Date!]

  """the html for displaying on the web page"""
  description: String

  """
  The date from which the schedule stops recurring. Will be NULL for CONTINUOUS schedules.
  """
  endDate: Date

  """representation of the recurrence rule in ical rule encoded format"""
  ical: String!

  """The date from which the schedule starts recurring."""
  startDate: Date!
  type: BillingScheduleTypeEnum!
}

"""Input to creation of a BillingSchedule"""
input BillingScheduleInputType {
  name: String
  recurrence: ProposalBillingStrategyType!

  """
  Ignored unless recurrence is "RECURRING"
  """
  rule: RecurrenceRuleInput
  start: BillingStartInputType!
}

enum BillingScheduleTypeEnum {
  CONTINUOUS
  NON_RECURRING
  RECURRING
}

type BillingSmartBillingQuantityRule implements BillingQuantityRuleInterface {
  """
  Quantity amount. Either a calculated amount or a estimate amount depending on the type
  """
  amount: Decimal

  """time rule was created or of last sync"""
  lastUpdatedAt: DateTime

  """source/name of the rule used to calculate the amount"""
  source: String!

  """Type of quantity rule"""
  type: BillingQuantityRuleType!
}

input BillingStartInputType {
  startType: ProposalStartBillingType!

  """
  Ignored unless start_type is "ON_DATE"
  """
  date: Date
  delay: DurationInput
}

type BillingUnitPriceRule implements BillingPriceRuleInterface {
  """Amount"""
  amount: Money!

  """Description of the price rule"""
  description: String!

  """Type of price rule"""
  type: BillingPriceRuleType!

  """Name of the type of unit"""
  unitName: String!
}

type BrandingTheme {
  colour: String!
  colourHex: String!
  defaultBrochure: Filestack
  defaultBrochureUrl: URL @deprecated(reason: "Use default_brochure { url } instead.")
  id: ID!

  """Tells you if the returned logo is the Ignition provided default."""
  isDefaultLogo: Boolean!

  """Sets whether the customer logo is to be shown in emails to clients."""
  isLogoShownOnClientEmails: Boolean!
  logo: ResizeableImage!
  logoUrl: URL! @deprecated(reason: "Use logo { url } instead.")
}

"""Autogenerated input type of BrandingThemeColourUpdate"""
input BrandingThemeColourUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  colour: String!
}

"""Autogenerated return type of BrandingThemeColourUpdate."""
type BrandingThemeColourUpdatePayload {
  brandingTheme: BrandingTheme!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of BrandingThemeDefaultBrochureUnset"""
input BrandingThemeDefaultBrochureUnsetInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of BrandingThemeDefaultBrochureUnset."""
type BrandingThemeDefaultBrochureUnsetPayload {
  brandingTheme: BrandingTheme!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of BrandingThemeDefaultBrochureUpdate"""
input BrandingThemeDefaultBrochureUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  file: FilestackInput!
}

"""Autogenerated return type of BrandingThemeDefaultBrochureUpdate."""
type BrandingThemeDefaultBrochureUpdatePayload {
  brandingTheme: BrandingTheme!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of BrandingThemeLogoUnset"""
input BrandingThemeLogoUnsetInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of BrandingThemeLogoUnset."""
type BrandingThemeLogoUnsetPayload {
  brandingTheme: BrandingTheme!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of BrandingThemeLogoUpdate"""
input BrandingThemeLogoUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  file: FilestackInput!
}

"""Autogenerated return type of BrandingThemeLogoUpdate."""
type BrandingThemeLogoUpdatePayload {
  brandingTheme: BrandingTheme!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of BrandingThemeUpdate"""
input BrandingThemeUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  logo: String
  colour: String
  defaultBrochureFile: FilestackInput
  isLogoShownOnClientEmails: Boolean
}

"""Autogenerated return type of BrandingThemeUpdate."""
type BrandingThemeUpdatePayload {
  brandingTheme: BrandingTheme!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

type Brochure {
  file: Filestack!
  id: ID!
}

"""Autogenerated input type of BrochureCreate"""
input BrochureCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  file: FilestackInput!
}

"""Autogenerated return type of BrochureCreate."""
type BrochureCreatePayload {
  brochure: Brochure

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

input CapabilityFilter {
  name: CapabilityNameEnum
  state: CapabilityStateEnum
}

enum CapabilityNameEnum {
  CLIENT_SYNC
  CLIENT_SEARCH
  TAX_RATES
  USER_SYNC
  WORKFLOW
  WORKFLOW_TEMPLATES
  WORKFLOW_CATEGORIES
  LEDGER_ITEMS
  PRACTICE_BILLING
  PROVIDED_TEMPLATES
  USER_CONFIGURABLE
  SMART_BILLING
  INVOICE_DEPLOY
  PROPOSAL_IMPORT
  SERVICE_IMPORT
}

enum CapabilityStateEnum {
  ENABLED
  DISABLED
}

"""
A Capability is a generic piece of functionality that an App can .implement. 
For example, the "client_sync" functionality allows Apps to sync Client details
to and from external systems.  If an App has the "client_sync" functionality,
then all associated types (e.g. AppClient) and mutations (e.g.
ClientSetAppMapping) will work with that App.
"""
type CapabilityWithState {
  description: String!
  name: CapabilityNameEnum!
  state: CapabilityStateEnum!
}

type ChangedValue {
  name: String!
  newValue: String
  oldValue: String
  summary: String
}

type Clawback {
  amount: Money!
  collection: Collection
  completedAt: DateTime
  createdAt: DateTime!
  externalId: String
  failedAt: DateTime
  id: ID!
  message: String

  """Payment associated with the clawback"""
  payment: Payment!
  paymentMethod: PaymentMethod!
  startedAt: DateTime!
  state: PaymentsClawbackState!
  updatedAt: DateTime!
}

"""The connection type for Clawback."""
type ClawbackConnection {
  """A list of edges."""
  edges: [ClawbackEdge!]!

  """A list of nodes."""
  nodes: [Clawback!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalAmount: Money!
  totalCount: Int!
}

"""An edge in a connection."""
type ClawbackEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Clawback!
}

"""A client of a practice for which proposals are created."""
type Client {
  """
  The workflow strategy that is currently configured to receive credits for invoices raised with this
  client's billing group.
  
  """
  activeBillingWorkflowStrategy: ClientWorkflowStrategy

  """
  If present, this is an error related to recent activity on the client, such as a failed proposal creation
  """
  activityError: String

  """The date/time when activityError last occurred"""
  activityErrorOccurredAt: DateTime
  addresses(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: AddressFilter
  ): AddressConnection @deprecated(reason: "Use companyAddress and postalAddress instead")

  """agreed services"""
  agreedServices(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: AgreedServiceFilter
  ): AgreedServiceConnection
  appClients(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: AppClientFilter
  ): AppClientConnection!
  automaticBillingGroup(
    """Billing item's group key"""
    id: ID!
  ): BillingItemGroup
  automaticBillingGroups(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    dateIn: DateRangeInput
  ): BillingItemGroupConnection
  billableServices(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): BillableServiceConnection
  billingGroup(
    """Billing Group slug"""
    id: ID!
  ): BillingGroup
  billingGroups(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: ClientBillingBillingGroupFilter
  ): BillingGroupConnection!
  billingItem(
    """Billing Item slug"""
    id: ID!
  ): BillingItem

  """unbilled billing items"""
  billingItems(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: BillingItemFilter!
  ): BillingItemConnection
  businessStructure: String
  canArchive: Boolean!
  companyAddress: Address
  companyNumber: String
  contacts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ContactConnection!
  createdAt: DateTime!
  defaultContact: Contact!

  """Reference number for the client (eg. CLI-0001)"""
  displayReferenceNumber: String!
  emailSettings: [EmailSettings!]!
  fax: PhoneNumber
  fiscalPeriodEndDay: Int
  fiscalPeriodEndMonth: Int
  group: ClientGroup
  gstRegistered: String
  id: ID!
  invoiceSettings: InvoiceNotificationSettings
  invoices(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClientBillingInvoiceConnection

  """
  Is revenue from this client excluded from the dashboard and other reports?
  """
  isExcludedFromReports: Boolean!

  """send the invoice email when an invoice is raised"""
  isSendInvoiceNotificationsEnabled: Boolean!

  """
  Whether the practice applies surcharges to pass on payment fees to this client
  """
  isSurchargeEnabled: Boolean!
  jobManager: User
  name: String!
  notes: String
  notificationSettings: ClientNotificationSettings
  partner: User

  """List of payment method requests sent to the client."""
  paymentMethodRequests(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: PaymentMethodRequestFilter
  ): PaymentMethodRequestConnection!
  paymentMethods: [PaymentMethod!]
  paymentNotificationSettings: PaymentNotificationSettings
  payments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: PaymentFilter
  ): PaymentConnection!
  phone: PhoneNumber
  postalAddress: Address

  """Legacy auto-inc id of client"""
  referenceNumber: ID! @deprecated(reason: "Use id instead.")
  state: ClientState!
  tagList: [String!]!
  taxNumber: String
  token: PublicToken
  type: ClientType!

  """url used for updating payment details on a client"""
  updatePaymentDetailsUrl: URL
  updatedAt: DateTime!
  website: URL
  willDeployInvoices: Boolean
  workflowItem(
    """Workflow item slug"""
    id: ID!
  ): ClientWorkflowItem
  workflowStrategies(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: ClientWorkflowStrategyFilter
    orderBy: ClientWorkflowStrategyOrder
  ): ClientWorkflowStrategyConnection

  """Xero Tracking Categories for the client"""
  xeroTrackingCategories: [XeroTrackingCategory!] @deprecated(reason: "After tracking categories and available options have been moved to the practice root, only selectedOptions will remain")
}

"""Autogenerated input type of ClientArchive"""
input ClientArchiveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  ids: [ID!]!
}

"""Autogenerated return type of ClientArchive."""
type ClientArchivePayload {
  """Async Job Group for the clients being archived in the background"""
  asyncJobGroup: AsyncJobGroup

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

input ClientBillingBillingGroupFilter {
  typeEq: ClientBillingBillingGroupType
  billingReferenceEq: String
}

union ClientBillingBillingGroupSource = Client | Engagement | Project | Proposal

enum ClientBillingBillingGroupType {
  """Billing Group for Client"""
  CLIENT

  """Billing Group for Proposal"""
  PROPOSAL

  """Billing Group for Proposal Project"""
  PROJECT

  """Billing Group for Classic Proposal"""
  ENGAGEMENT
}

"""The connection type for BillingItem."""
type ClientBillingBillingItemConnection {
  count: Int!

  """A list of edges."""
  edges: [ClientBillingBillingItemEdge!]!

  """A list of nodes."""
  nodes: [BillingItem!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalPrice: Money
}

"""An edge in a connection."""
type ClientBillingBillingItemEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: BillingItem!
}

enum ClientBillingBillingItemState {
  UNBILLED
  BILLED
  ARCHIVED
}

type ClientBillingInvoice {
  activities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    orderBy: ActivityLogOrder = {createdAt: ASCENDING}
  ): ActivityLogConnection

  """The total value of the invoice, excluding tax"""
  amount: Money!

  """The total value of the invoice, including tax"""
  amountWithTax: Money!
  client: Client!
  date: Date!
  deployments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: ClientBillingInvoiceDeploymentFilter
  ): ClientBillingInvoiceDeploymentConnection
  dueDate: Date!
  id: ID!

  """Indicate whether we have sent the invoice email to client or not"""
  isInvoiceEmailSent: Boolean!
  isOnlinePaymentAvailable: Boolean!
  items(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClientBillingInvoiceItemConnection!
  latestDeployment: ClientBillingInvoiceDeployment
  memo: String
  payInvoicePortalUrl: String!
  payment: Payment
  paymentMethod: PaymentMethod @deprecated(reason: "Use payment.paymentMethod instead")

  """Whether it is valid to call the reconcile mutation on this Invoice"""
  reconcilable: Boolean!
  reference: String!
  state: ClientBillingInvoiceState!

  """The total amount of tax charged on this invoice"""
  taxAmount: Money!
}

"""The connection type for ClientBillingInvoice."""
type ClientBillingInvoiceConnection {
  count: Int!

  """A list of edges."""
  edges: [ClientBillingInvoiceEdge!]!

  """A list of nodes."""
  nodes: [ClientBillingInvoice!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalAmount: Money
}

"""Autogenerated input type of ClientBillingInvoiceDeploy"""
input ClientBillingInvoiceDeployInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of invoice"""
  invoiceId: ID!
}

type ClientBillingInvoiceDeployment {
  completedAt: DateTime
  externalId: String
  externalNumber: String
  externalUrl: String
  failedAt: DateTime
  id: ID!
  ledgerName: String!
  message: String
  reference: ID!
  startedAt: DateTime
  state: ClientBillingInvoiceDeploymentState!
}

"""The connection type for ClientBillingInvoiceDeployment."""
type ClientBillingInvoiceDeploymentConnection {
  """A list of edges."""
  edges: [ClientBillingInvoiceDeploymentEdge!]!

  """A list of nodes."""
  nodes: [ClientBillingInvoiceDeployment!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ClientBillingInvoiceDeploymentEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ClientBillingInvoiceDeployment!
}

input ClientBillingInvoiceDeploymentFilter {
  stateIn: [ClientBillingInvoiceDeploymentState!]
}

enum ClientBillingInvoiceDeploymentState {
  STARTED
  COMPLETED
  FAILED
}

"""Autogenerated return type of ClientBillingInvoiceDeploy."""
type ClientBillingInvoiceDeployPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  invoice: ClientBillingInvoice!
}

"""An edge in a connection."""
type ClientBillingInvoiceEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ClientBillingInvoice!
}

"""Autogenerated input type of ClientBillingInvoiceIssue"""
input ClientBillingInvoiceIssueInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """billing items"""
  billingItems: [BillingItemInput!]!

  """payment method slug"""
  paymentMethodId: ID!
}

"""Autogenerated return type of ClientBillingInvoiceIssue."""
type ClientBillingInvoiceIssuePayload {
  billingItems: [BillingItem!]!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  invoices: [ClientBillingInvoice!]
}

type ClientBillingInvoiceItem {
  """The total value of this item excluding tax, i.e. quantity * unit_price"""
  amount: Money!

  """
  The total value of this item including total, i.e. (quantity * unit_price) + tax_amount
  """
  amountWithTax: Money!

  """The billing item this invoice item was created from (if any)."""
  billingItem: BillingItem
  billingName: String
  description: String
  discount: Money
  id: ID!
  name: String!
  notes: String
  origin: Origin
  position: Int
  quantity: Decimal!

  """The type of tax applied to this item"""
  tax: Tax!

  """The total value of tax applied to this item"""
  taxAmount: Money!

  """
  The value of a single unit of this item, i.e. the value if quantity were 1
  """
  unitPrice: Money!
}

"""The connection type for ClientBillingInvoiceItem."""
type ClientBillingInvoiceItemConnection {
  """A list of edges."""
  edges: [ClientBillingInvoiceItemEdge!]!

  """A list of nodes."""
  nodes: [ClientBillingInvoiceItem!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ClientBillingInvoiceItemEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ClientBillingInvoiceItem!
}

"""Autogenerated input type of ClientBillingInvoiceReconcile"""
input ClientBillingInvoiceReconcileInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of invoice"""
  invoiceId: ID!
}

"""Autogenerated return type of ClientBillingInvoiceReconcile."""
type ClientBillingInvoiceReconcilePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  invoice: ClientBillingInvoice!
}

"""
Autogenerated input type of ClientBillingInvoiceSendInvoiceToClientEmail
"""
input ClientBillingInvoiceSendInvoiceToClientEmailInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Invoice's slug"""
  invoiceId: ID!

  """Email recipients"""
  to: [EmailAddress!]!

  """Email subject"""
  subject: String!

  """Additional message"""
  message: String

  """Allow online payment checkbox value"""
  allowOnlinePayment: Boolean!
}

"""
Autogenerated return type of ClientBillingInvoiceSendInvoiceToClientEmail.
"""
type ClientBillingInvoiceSendInvoiceToClientEmailPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  invoice: ClientBillingInvoice!
}

enum ClientBillingInvoiceState {
  ISSUED
  DELETED
}

"""Autogenerated input type of ClientBillingItemArchive"""
input ClientBillingItemArchiveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Billing item slugs"""
  billingItemIds: [ID!]!
}

"""Autogenerated return type of ClientBillingItemArchive."""
type ClientBillingItemArchivePayload {
  billingItems: [BillingItem!]!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientBillingItemBillAutomatically"""
input ClientBillingItemBillAutomaticallyInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Billing items"""
  billingItems: [BillingItemInput!]!

  """Date for which all billing items should be billed. (ISO formatted)"""
  date: Date!

  """
  Payment method to use when collecting payment for this item. To unset the payment method, use an empty string.
  """
  paymentMethodId: ID!
}

"""Autogenerated return type of ClientBillingItemBillAutomatically."""
type ClientBillingItemBillAutomaticallyPayload {
  billingItems: [BillingItem!]!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientBillingItemBillManually"""
input ClientBillingItemBillManuallyInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Billing items"""
  billingItems: [BillingItemInput!]!

  """
  Date (ISO Formatted) for which all billing items should be billed. (ISO Formatted)
  """
  date: Date!
}

"""Autogenerated return type of ClientBillingItemBillManually."""
type ClientBillingItemBillManuallyPayload {
  billingItems: [BillingItem!]!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""
Autogenerated input type of ClientBillingItemPreviewSmartBillingQuantity
"""
input ClientBillingItemPreviewSmartBillingQuantityInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the billing item"""
  id: ID!

  """quantity rule to use for smart billing calculation"""
  quantityRule: QuantityRuleInput!
}

"""
Autogenerated return type of ClientBillingItemPreviewSmartBillingQuantity.
"""
type ClientBillingItemPreviewSmartBillingQuantityPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  smartBillingQuantityRule: BillingSmartBillingQuantityRule!
}

"""
Autogenerated input type of ClientBillingItemRefreshSmartBillingQuantity
"""
input ClientBillingItemRefreshSmartBillingQuantityInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the billing item"""
  id: ID!
}

"""
Autogenerated return type of ClientBillingItemRefreshSmartBillingQuantity.
"""
type ClientBillingItemRefreshSmartBillingQuantityPayload {
  billingItem: BillingItem!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientBillingItemReschedule"""
input ClientBillingItemRescheduleInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Billing item slugs"""
  billingItemIds: [ID!]!

  """New billing item date (ISO Formatted)"""
  date: Date!
}

"""Autogenerated return type of ClientBillingItemReschedule."""
type ClientBillingItemReschedulePayload {
  billingItems: [BillingItem!]!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""The connection type for Client."""
type ClientConnection {
  """A list of edges."""
  edges: [ClientEdge!]!
  ids: [ID!]

  """A list of nodes."""
  nodes: [Client!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of ClientCreate"""
input ClientCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  client: ClientInput!

  """An AppClient to map the Client to"""
  appClient: AppClientInput
}

"""Autogenerated return type of ClientCreate."""
type ClientCreatePayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""An edge in a connection."""
type ClientEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Client!
}

input ClientFilter {
  """Filter by partial match on name"""
  nameCont: String

  """Filter by exact match on name"""
  nameEq: String
  stateNotIn: [ClientState!]
  stateIn: [ClientState!]
  idsIn: [ID!]
  tagEq: String
  awaitingVerification: Boolean
  expiringCards: Boolean
  manualPaymentsDue: ClientManualPaymentDueFilter
  proposalFilter: ProposalFilter
}

"""A group of clients, of a practice, that can have group engagements."""
type ClientGroup {
  contact: Contact
  id: ID!
  name: String!
  referenceNumber: ID!
}

"""Autogenerated input type of ClientGroupsUpdate"""
input ClientGroupsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """client group id"""
  id: ID!

  """client group contact id to update"""
  contactId: ID

  """client group name to update"""
  name: String
}

"""Autogenerated return type of ClientGroupsUpdate."""
type ClientGroupsUpdatePayload {
  clientGroup: ClientGroup!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientImportCreate"""
input ClientImportCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  file: FilestackInput!
}

"""Autogenerated return type of ClientImportCreate."""
type ClientImportCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Number of clients successfully imported"""
  count: Int!

  """List of error messages including line number"""
  errors: [String!]

  """Import object"""
  import: ImportType

  """Is the csv a valid csv for import"""
  isValid: Boolean!
}

"""Autogenerated input type of ClientImport"""
input ClientImportInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  importId: ID!
}

"""Autogenerated return type of ClientImport."""
type ClientImportPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  import: ImportType!
}

"""Input data to specify the details for a client."""
input ClientInput {
  """Name of the client"""
  name: String!

  """Tags"""
  tagList: [String!]

  """Free-form notes about the client"""
  notes: String

  """ID of the partner user"""
  partnerId: ID

  """ID of the manager user"""
  managerId: ID

  """Main address of the client"""
  address: AddressInput

  """Postal address of the client"""
  postalAddress: AddressInput

  """Phone number of the client"""
  phone: PhoneNumber

  """Fax number of the client"""
  fax: PhoneNumber

  """Website of the client"""
  website: URL

  """End of Fiscal Period: perennial month"""
  fiscalPeriodEndMonth: Int

  """End of Fiscal Period: perennial day"""
  fiscalPeriodEndDay: Int

  """Description or identification of the business structure"""
  businessStructure: String

  """
  Free-form description of whether the client is GST registered or not (may contain malicious Javascript)
  """
  gstRegistered: String

  """Tax file number"""
  taxNumber: String

  """Legal entity company number"""
  companyNumber: String

  """Details of the contacts"""
  contacts: [ContactInput!] = []

  """Email settings of the client"""
  emailSettings: [EmailSettingsInput!] = []
}

interface ClientInterface {
  """Company-specific attributes"""
  company: AppClientCompany!
  contacts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AppClientContactConnection!

  """
  The default contact information to use to contact this Client,
  if a specific contact has not been chosen
  """
  defaultContact: AppClientContact!
  id: ID!

  """Full name"""
  name: String!

  """The physical or shipping address"""
  physicalAddress: AppClientAddress

  """The postal or billing address"""
  postalAddress: AppClientAddress
}

enum ClientManualPaymentDueFilter {
  OVERDUE
  THIS_WEEK
  THIS_MONTH
  ALL
}

type ClientNotificationSettings {
  recipients: [Recipient]
}

"""Autogenerated input type of ClientPaymentMethodDelete"""
input ClientPaymentMethodDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Client ID"""
  id: ID!

  """Payment method slug"""
  paymentMethodId: ID!
}

"""Autogenerated return type of ClientPaymentMethodDelete."""
type ClientPaymentMethodDeletePayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

type ClientResult {
  client: Client!
  createdAt: DateTime!
  groupContactEmail: String
  groupName: String
  id: ID!
  manager: String
  mostRecentActivityCause: String

  """If present, the most recent activity had an error"""
  mostRecentActivityError: String
  mostRecentActivityOn: Date
  name: String!
  partner: String
  primaryContactEmail: String
  tags: String
  updatedAt: DateTime!
}

enum ClientsCount {
  """2000+ clients"""
  TWO_THOUSAND_PLUS

  """1001-2000 clients"""
  ONE_THOUSAND_AND_ONE_TO_TWO_THOUSAND

  """501-1000 clients"""
  FIVE_HUNDRED_AND_ONE_TO_ONE_THOUSAND

  """251-500 clients"""
  TWO_HUNDRED_FIFTY_ONE_TO_FIVE_HUNDRED

  """101-250 clients"""
  ONE_HUNDRED_AND_ONE_TO_TWO_HUNDRED_FIFTY

  """61-100 clients"""
  SIXTY_ONE_TO_ONE_HUNDRED

  """31-60 clients"""
  THIRTY_ONE_TO_SIXTY

  """1-30 clients"""
  ONE_TO_THIRTY @deprecated(reason: "split into ZERO_TO_NINE and TEN_TO_THIRTY instead")

  """10-30 clients"""
  TEN_TO_THIRTY

  """0-9 clients"""
  ZERO_TO_NINE
}

"""Autogenerated input type of ClientServicesAgreedServiceCancel"""
input ClientServicesAgreedServiceCancelInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Agreed Service"""
  agreedServiceId: ID!
}

"""Autogenerated return type of ClientServicesAgreedServiceCancel."""
type ClientServicesAgreedServiceCancelPayload {
  agreedService: AgreedService!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientServicesAgreedServiceCreate"""
input ClientServicesAgreedServiceCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Client slug"""
  clientId: ID!
  agreedServiceInput: AgreedServiceInput!

  """Payment method slug"""
  paymentMethodId: ID
  reason: String
  notification: NotificationInput
}

"""Autogenerated return type of ClientServicesAgreedServiceCreate."""
type ClientServicesAgreedServiceCreatePayload {
  agreedService: AgreedService!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientServicesAgreedServiceDisableAll"""
input ClientServicesAgreedServiceDisableAllInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Client"""
  clientId: ID!
}

"""Autogenerated return type of ClientServicesAgreedServiceDisableAll."""
type ClientServicesAgreedServiceDisableAllPayload {
  agreedServices: [AgreedService!]!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientServicesAgreedServiceDisable"""
input ClientServicesAgreedServiceDisableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Agreed Service"""
  agreedServiceId: ID!
}

"""Autogenerated return type of ClientServicesAgreedServiceDisable."""
type ClientServicesAgreedServiceDisablePayload {
  agreedService: AgreedService!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""
Autogenerated input type of ClientServicesAgreedServiceRemovePaymentMethod
"""
input ClientServicesAgreedServiceRemovePaymentMethodInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Agreed Service Slug"""
  agreedServiceId: ID!
}

"""
Autogenerated return type of ClientServicesAgreedServiceRemovePaymentMethod.
"""
type ClientServicesAgreedServiceRemovePaymentMethodPayload {
  agreedService: AgreedService!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""
Autogenerated input type of ClientServicesAgreedServiceSetPaymentMethod
"""
input ClientServicesAgreedServiceSetPaymentMethodInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Agreed Service Slug"""
  agreedServiceId: ID!

  """Payment Method Slug"""
  paymentMethodId: ID!
}

"""
Autogenerated return type of ClientServicesAgreedServiceSetPaymentMethod.
"""
type ClientServicesAgreedServiceSetPaymentMethodPayload {
  agreedService: AgreedService!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientServicesAgreedServicesExport"""
input ClientServicesAgreedServicesExportInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """
  Only agreed services with expiration on or after this date will be included.
  """
  expiresOnOrAfter: Date

  """The date to start calculating the total price of agreed services."""
  startDate: Date

  """The date to end calculating the total price of agreed services."""
  endDate: Date
}

"""Autogenerated return type of ClientServicesAgreedServicesExport."""
type ClientServicesAgreedServicesExportPayload {
  backgroundJob: BackgroundJob!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

enum ClientServicesAgreedServiceStateEnum {
  """Service is due to start in the future."""
  UPCOMING

  """Service is currently active."""
  ENABLED

  """Service is currently inactive."""
  DISABLED

  """Service was cancelled."""
  CANCELLED
}

"""Autogenerated input type of ClientServicesAgreedServiceUpdate"""
input ClientServicesAgreedServiceUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Agreed Service to be updated"""
  agreedServiceId: ID!
  agreedServiceInput: AgreedServiceInput!
  reason: String
  notification: NotificationInput
}

"""Autogenerated return type of ClientServicesAgreedServiceUpdate."""
type ClientServicesAgreedServiceUpdatePayload {
  agreedService: AgreedService!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientSetAppMapping"""
input ClientSetAppMappingInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Client to map"""
  id: ID!

  """The AppClients to map to"""
  appClients: [AppClientInput!]!
}

"""Autogenerated return type of ClientSetAppMapping."""
type ClientSetAppMappingPayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientSetDeployInvoices"""
input ClientSetDeployInvoicesInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ID of client"""
  id: ID!
  willDeployInvoices: Boolean!
}

"""Autogenerated return type of ClientSetDeployInvoices."""
type ClientSetDeployInvoicesPayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientSetPaymentMethod"""
input ClientSetPaymentMethodInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Client ID"""
  id: ID!

  """
  The slug of the payment method to set. If not provided, the payment method will be
  removed from future billings, and any scheduled payments will be cancelled.
  """
  paymentMethodId: ID

  """Specifies whether scheduled payments should also be updated."""
  updateScheduledPayments: Boolean = false
}

"""Autogenerated return type of ClientSetPaymentMethod."""
type ClientSetPaymentMethodPayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientSetTagsList"""
input ClientSetTagsListInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!

  """Tags"""
  tagList: [String!]
}

"""Autogenerated return type of ClientSetTagsList."""
type ClientSetTagsListPayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

enum ClientState {
  LEAD
  ACTIVE
  INACTIVE
  LOST
  DELETED
  ARCHIVED
}

"""Autogenerated input type of ClientSurchargeDisable"""
input ClientSurchargeDisableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ID of the client."""
  id: ID!
}

"""Autogenerated return type of ClientSurchargeDisable."""
type ClientSurchargeDisablePayload {
  client: Client!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientSurchargeEnable"""
input ClientSurchargeEnableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ID of the client."""
  id: ID!
}

"""Autogenerated return type of ClientSurchargeEnable."""
type ClientSurchargeEnablePayload {
  client: Client!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientSwitchPaymentMethod"""
input ClientSwitchPaymentMethodInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Client ID"""
  id: ID!

  """
  The slug of the payment method to be changed. Any future billings or scheduled payments
  using this payment method will be updated.
  """
  fromPaymentMethodId: ID!

  """
  The slug of the payment method to set. If not provided, the payment method will be
  removed from future billings, and any scheduled payments will be cancelled.
  """
  toPaymentMethodId: ID

  """Specifies whether scheduled payments should also be updated."""
  updateScheduledPayments: Boolean = false
}

"""Autogenerated return type of ClientSwitchPaymentMethod."""
type ClientSwitchPaymentMethodPayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""ClientSyncType contains details about an App's ClientSync."""
type ClientSync {
  """The time the sync completed"""
  completedAt: DateTime

  """The error message if state is failed"""
  errorMessage: String

  """The time the sync failed"""
  failedAt: DateTime
  id: ID!

  """The time the sync started"""
  startedAt: DateTime!

  """The sync's current state"""
  state: ClientSyncState!
}

"""
ClientSyncSettings contains details about an App's ClientSync settings.
"""
type ClientSyncSettings {
  """Whether the ClientSync settings as configured are valid."""
  isValid: Boolean!

  """The direction client sync data is synced."""
  syncDirection: ClientSyncSettingsSyncDirection!

  """Available options for the direction client sync data is synced."""
  syncDirectionOptions: [ClientSyncSettingsSyncDirection!]!

  """Which client data will be synced between Ignition and the App."""
  syncScope: ClientSyncSettingsSyncScope!

  """
  Available options for which client data will be synced between Ignition and the App.
  """
  syncScopeOptions: [ClientSyncSettingsSyncScope!]!
}

"""Input data containing an App's ClientSync settings."""
input ClientSyncSettingsInput {
  syncDirection: ClientSyncSettingsSyncDirection!
  syncScope: ClientSyncSettingsSyncScope!
}

enum ClientSyncSettingsSyncDirection {
  FROM_APP
  TO_APP
}

enum ClientSyncSettingsSyncScope {
  EVERYTHING
  CLIENT_NAME
  NOTHING
}

"""Autogenerated input type of ClientSyncSettingsUpdate"""
input ClientSyncSettingsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  appName: String!
  clientSyncSettings: ClientSyncSettingsInput!
}

"""Autogenerated return type of ClientSyncSettingsUpdate."""
type ClientSyncSettingsUpdatePayload {
  app: App!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

enum ClientSyncState {
  STARTED
  COMPLETED
  FAILED
}

enum ClientType {
  """Normal clients created by practices"""
  STANDARD

  """
  Client used to demonstrate features without influencing real client data.
  """
  DEMO
}

"""Autogenerated input type of ClientUnarchive"""
input ClientUnarchiveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of ClientUnarchive."""
type ClientUnarchivePayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ClientUpdate"""
input ClientUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ID of the client."""
  id: ID!
  client: ClientInput!
  xeroTrackingOptions: [SelectedTrackingOptionInput!]
}

"""Autogenerated return type of ClientUpdate."""
type ClientUpdatePayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

type ClientWorkflowItem {
  """Name of the workflow app this item is configured to deploy to."""
  appName: String!
  budget: Money
  categories: [WorkflowCategoryType!]
  createdAt: DateTime!

  """Collection of all deployment attempts made for this item."""
  deployments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: ClientWorkflowItemDeploymentFilter
    orderBy: ClientWorkflowItemDeploymentOrder
  ): ClientWorkflowItemDeploymentConnection!
  description: String
  duration: Duration
  endDate: Date!
  id: ID!
  lockVersion: Int!
  manager: User
  name: String
  partner: User
  staff: [User!]!
  startDate: Date!
  state: ClientWorkflowItemState!
  templates: [WorkflowTemplateType!]
  updatedAt: DateTime!
}

"""The connection type for ClientWorkflowItem."""
type ClientWorkflowItemConnection {
  """A list of edges."""
  edges: [ClientWorkflowItemEdge!]!

  """A list of nodes."""
  nodes: [ClientWorkflowItem!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type ClientWorkflowItemDeployment {
  appName: String!
  completedAt: DateTime
  externalId: ID

  """URL of the deployed item on the workflow app (if available)."""
  externalUrl: String
  failedAt: DateTime
  id: ID!
  message: String
  startedAt: DateTime
  state: ClientWorkflowItemDeploymentState!
}

"""The connection type for ClientWorkflowItemDeployment."""
type ClientWorkflowItemDeploymentConnection {
  """A list of edges."""
  edges: [ClientWorkflowItemDeploymentEdge!]!

  """A list of nodes."""
  nodes: [ClientWorkflowItemDeployment!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ClientWorkflowItemDeploymentEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ClientWorkflowItemDeployment!
}

input ClientWorkflowItemDeploymentFilter {
  stateIn: [ClientWorkflowItemState!]
}

input ClientWorkflowItemDeploymentOrder {
  """Sort by when the deployment was started."""
  startedAt: OrderBy

  """Sort by when the deployment was marked as completed."""
  completedAt: OrderBy

  """Sort by when the deployment was marked as failed."""
  failedAt: OrderBy
}

enum ClientWorkflowItemDeploymentState {
  """
  Deployment is currently attempting to create the item in the workflow app.
  """
  STARTED

  """Deployment successfully created the item in the workflow app."""
  COMPLETED

  """Deployment failed to create the item in the workflow app."""
  FAILED
}

"""An edge in a connection."""
type ClientWorkflowItemEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ClientWorkflowItem!
}

"""Autogenerated input type of clientWorkflowItemStartDeployment"""
input clientWorkflowItemStartDeploymentInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of workflow item"""
  id: ID!

  """
  If true, allows starting a new deployment even if the workflow item has already been deployed.
  """
  allowRedeploy: Boolean = false
}

"""Autogenerated return type of clientWorkflowItemStartDeployment."""
type clientWorkflowItemStartDeploymentPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  deployment: ClientWorkflowItemDeployment
  workflowItem: ClientWorkflowItem
  workflowStrategy: ClientWorkflowStrategy
}

enum ClientWorkflowItemState {
  """Item has not been deployed to the workflow app."""
  UNDEPLOYED

  """Item is currently being deployed to the workflow app."""
  DEPLOYING

  """Item has been deployed to the workflow app."""
  DEPLOYED

  """
  Item has been deleted. Note the item may still exist on the workflow app.
  """
  DELETED
}

type ClientWorkflowStrategy {
  activities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    orderBy: ActivityLogOrder = {createdAt: ASCENDING}
  ): ActivityLogConnection

  """The workflow app this strategy is configured to deploy to."""
  appName: String!

  """
  If assigned, invoices raised with this billing group will have their credits applied to this workflow strategy.
  """
  billingGroup: BillingGroup

  """
  Will receive work credits for services billed using this reference (if set)
  """
  billingReference: String
  budget: Money
  categories: [WorkflowCategoryType!]
  client: Client!

  """Time the workflow strategy was created."""
  createdAt: DateTime!

  """Time the workflow strategy was deactivated."""
  deactivatedAt: DateTime

  """
  Denotes whether this workflow strategy should deploy jobs automatically.
  """
  deployStrategy: ClientWorkflowStrategyDeployStrategy!
  description: String
  duration: Duration
  id: ID!

  """Has this workflow strategy started deploying jobs?"""
  isStarted: Boolean!
  items(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClientWorkflowItemConnection!
  lockVersion: Int!
  manager: User
  name: String
  partner: User

  """Workflow schedule"""
  schedule: Schedule!
  staff: [User!]!
  state: ClientWorkflowStrategyState!
  templates: [WorkflowTemplateType!]

  """Time the workflow strategy was last modified."""
  updatedAt: DateTime!
}

"""The connection type for ClientWorkflowStrategy."""
type ClientWorkflowStrategyConnection {
  """A list of edges."""
  edges: [ClientWorkflowStrategyEdge!]!

  """A list of nodes."""
  nodes: [ClientWorkflowStrategy!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of clientWorkflowStrategyCreate"""
input clientWorkflowStrategyCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the client."""
  clientId: ID!

  """The name of the workflow app this will be deployed to."""
  appName: String!

  """The name of the workflow strategy."""
  name: String = "Unnamed Workflow"

  """
  The date from which the workflow item schedule should start. Defaults to the current date.
  """
  startDate: Date

  """
  Defines how the workflow item schedule will recurr. Defaults to a single occurrence.
  """
  recurrenceRule: RecurrenceRuleInput = "FREQ=DAILY;COUNT=1"

  """
  The duration of each workflow item. This is used to calculate the end date of
  each workflow item, based on their start dates.
  """
  duration: DurationInput = {count: 1, interval: MONTHS}
}

"""Autogenerated return type of clientWorkflowStrategyCreate."""
type clientWorkflowStrategyCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategy: ClientWorkflowStrategy
}

"""Autogenerated input type of clientWorkflowStrategyDeactivate"""
input clientWorkflowStrategyDeactivateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The slug of the workflow strategy being deactivated."""
  id: ID!
}

"""Autogenerated return type of clientWorkflowStrategyDeactivate."""
type clientWorkflowStrategyDeactivatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategy: ClientWorkflowStrategy
}

"""Autogenerated input type of clientWorkflowStrategyDelete"""
input clientWorkflowStrategyDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of workflow strategy to delete."""
  id: ID!
}

"""Autogenerated return type of clientWorkflowStrategyDelete."""
type clientWorkflowStrategyDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategies(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClientWorkflowStrategyConnection
}

enum ClientWorkflowStrategyDeployStrategy {
  MANUAL
  AUTOMATIC
}

"""Autogenerated input type of clientWorkflowStrategyDuplicate"""
input clientWorkflowStrategyDuplicateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of workflow strategy to duplicate."""
  id: ID!
}

"""Autogenerated return type of clientWorkflowStrategyDuplicate."""
type clientWorkflowStrategyDuplicatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategy: ClientWorkflowStrategy
}

"""An edge in a connection."""
type ClientWorkflowStrategyEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ClientWorkflowStrategy!
}

input ClientWorkflowStrategyFilter {
  stateIn: [ClientWorkflowStrategyState!]
}

input ClientWorkflowStrategyOrder {
  """Sort by when the workflow strategy was created."""
  createdAt: OrderBy

  """Sort by when the workflow strategy was deactivated."""
  deactivatedAt: OrderBy
}

"""Autogenerated input type of clientWorkflowStrategySetBillingGroup"""
input clientWorkflowStrategySetBillingGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of the workflow strategy"""
  id: ID!

  """Slug of the billing group"""
  billingGroupId: ID!
}

"""Autogenerated return type of clientWorkflowStrategySetBillingGroup."""
type clientWorkflowStrategySetBillingGroupPayload {
  client: Client!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategy: ClientWorkflowStrategy!
}

"""
Autogenerated input type of clientWorkflowStrategySetClientBillingGroup
"""
input clientWorkflowStrategySetClientBillingGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of the workflow strategy"""
  id: ID!

  """
  A billing group can only be assigned to one active workflow at a time.
  
  If another workflow strategy is already configured to use this billing group,
  by default it will return an error. Specify replaceExisting to override this
  and move the billing group to this workflow strategy.
  """
  replaceExisting: Boolean = false
}

"""
Autogenerated return type of clientWorkflowStrategySetClientBillingGroup.
"""
type clientWorkflowStrategySetClientBillingGroupPayload {
  client: Client!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategy: ClientWorkflowStrategy!
}

"""Autogenerated input type of clientWorkflowStrategySetDeployStrategy"""
input clientWorkflowStrategySetDeployStrategyInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Workflow strategy slug"""
  id: ID!
  deployStrategy: ClientWorkflowStrategyDeployStrategy!
}

"""Autogenerated return type of clientWorkflowStrategySetDeployStrategy."""
type clientWorkflowStrategySetDeployStrategyPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategy: ClientWorkflowStrategy
}

"""Autogenerated input type of clientWorkflowStrategySetGeneralSettings"""
input clientWorkflowStrategySetGeneralSettingsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of workflow strategy"""
  id: ID!
  name: String!
  description: String

  """ID of the partner user"""
  partnerId: ID

  """ID of the manager user"""
  managerId: ID

  """IDs of the staff users"""
  staffIds: [ID!]
  budget: MoneyInput

  """IDs of the workflow templates"""
  templateIds: [ID!]

  """IDs of the workflow categories"""
  categoryIds: [ID!]
}

"""Autogenerated return type of clientWorkflowStrategySetGeneralSettings."""
type clientWorkflowStrategySetGeneralSettingsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategy: ClientWorkflowStrategy
}

"""Autogenerated input type of clientWorkflowStrategySetOneTimeSchedule"""
input clientWorkflowStrategySetOneTimeScheduleInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of the workflow strategy."""
  id: ID!

  """When the workflow item is scheduled to start."""
  date: Date

  """
  Duration of the workflow item. This is used in combination with
  the start date to calculate the end date of the workflow item.
  """
  duration: DurationInput!
}

"""Autogenerated return type of clientWorkflowStrategySetOneTimeSchedule."""
type clientWorkflowStrategySetOneTimeSchedulePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategy: ClientWorkflowStrategy
}

"""Autogenerated input type of clientWorkflowStrategySetRecurringSchedule"""
input clientWorkflowStrategySetRecurringScheduleInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of workflow strategy"""
  id: ID!

  """Date from which the schedule starts recurring."""
  startDate: Date

  """Recurrence rule in iCal/RRULE format."""
  recurrenceRule: RecurrenceRuleInput!

  """
  Duration of the workflow items. This is used in combination with
  the start date to calculate the end date of each workflow item.
  """
  duration: DurationInput!
}

"""
Autogenerated return type of clientWorkflowStrategySetRecurringSchedule.
"""
type clientWorkflowStrategySetRecurringSchedulePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategy: ClientWorkflowStrategy
}

enum ClientWorkflowStrategyState {
  """
  Workflow strategy is active and will deploy items according to the schedule.
  """
  ACTIVE

  """Workflow strategy is inactive and will not deploy any further items."""
  INACTIVE

  """Workflow strategy has been deleted and is no longer available."""
  DELETED
}

"""Autogenerated input type of clientWorkflowStrategyUnsetBillingGroup"""
input clientWorkflowStrategyUnsetBillingGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of the workflow strategy"""
  id: ID!
}

"""Autogenerated return type of clientWorkflowStrategyUnsetBillingGroup."""
type clientWorkflowStrategyUnsetBillingGroupPayload {
  client: Client!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  workflowStrategy: ClientWorkflowStrategy!
}

type Collection {
  amount: Money!
  completedAt: DateTime
  createdAt: DateTime!
  disbursal: Disbursal
  externalId: String
  failedAt: DateTime
  id: ID!
  message: String
  payment: Payment!
  paymentMethod: PaymentMethod!
  scheduledTime: DateTime
  startedAt: DateTime
  state: PaymentsCollectionState!

  """Surcharge added to the collection"""
  surchargeAmount: Money!
  updatedAt: DateTime!
}

"""The connection type for Collection."""
type CollectionConnection {
  """A list of edges."""
  edges: [CollectionEdge!]!

  """A list of nodes."""
  nodes: [Collection!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CollectionEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Collection!
}

type Collections {
  isEnabled: Boolean!
}

type CollectionsNotificationSettings {
  toEmailAddresses: [EmailAddress!]!
}

"""Autogenerated input type of CollectionsNotificationSettingsUpdate"""
input CollectionsNotificationSettingsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  toEmailAddresses: [EmailAddress!]!
}

"""Autogenerated return type of CollectionsNotificationSettingsUpdate."""
type CollectionsNotificationSettingsUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  collectionsNotificationSettings: CollectionsNotificationSettings!
}

"""Autogenerated return type of Connected."""
type ConnectedPayload {
  quickbooks: quickbooks!
}

type Contact {
  """Name to be used when addressing letters or post to this Contact"""
  addressee: String
  client: Client
  createdAt: DateTime!
  email: EmailAddress
  id: ID!
  isRecipient: Boolean!
  mobile: String
  name: String!
  phone: String
  position: String
  referenceNumber: ID!
  salutation: String
  updatedAt: DateTime!
  uuid: ID! @deprecated(reason: "Use id instead")
}

"""The connection type for Contact."""
type ContactConnection {
  """A list of edges."""
  edges: [ContactEdge!]!

  """A list of nodes."""
  nodes: [Contact!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ContactEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Contact!
}

input ContactInput {
  id: ID
  name: String
  email: EmailAddress
  salutation: String
  addressee: String
  phone: String
  mobile: String
  isDefault: Boolean = false
  isRecipient: Boolean = false
}

"""Autogenerated input type of ContactUpdate"""
input ContactUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  contact: UpdateContactInput!
}

"""Autogenerated return type of ContactUpdate."""
type ContactUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  contact: Contact
  userErrors: [UserError!]
}

scalar CountryCode

enum CouponDiscountType {
  AMOUNT
  PERCENT
}

type CreditCardPaymentMethod implements PaymentsPaymentMethod {
  createdAt: DateTime!
  displayMethodType: String!
  expiryDate: String!
  id: ID!
  isExpired: Boolean!
  isInUse: Boolean!
  isInternational: Boolean!
  isInvalid: Boolean!

  """Whether a surcharge will be applied when charging this payment method"""
  isSurchargeEnabled: Boolean!
  name: String
  numberSuffix: String!
  referenceNumber: ID!

  """The category by which we determine the rate of surcharge"""
  surchargeCategory: PaymentMethodSurchargeCategory

  """
  The rate of surcharge added to this payment method's charges to account for payment fees
  """
  surchargeRate: Percentage!
  type: PaymentMethodType!
  verified: Boolean!
}

type Currency {
  """character between the whole and fraction amounts"""
  decimalMark: String!

  """the international 3-letter code as defined by the ISO 4217 standard"""
  isoCode: String!

  """the international 3-digit code as defined by the ISO 4217 standard"""
  isoNumeric: String!

  """the currency name"""
  name: String!

  """a numerical value you can use to sort/group the currency list"""
  priority: Int!

  """the name of the fractional monetary unit"""
  subunit: String!

  """the proportion between the unit and the subunit"""
  subunitToUnit: Int!

  """the currency symbol (UTF-8 encoded)"""
  symbol: String!

  """character between each thousands place"""
  thousandsSeparator: String!
}

type CustomerSuccessEngagementLetter {
  createdAt: DateTime!
  creator: User!
  file: Filestack!
  id: ID!
  state: EngagementLetterState!
}

"""The connection type for CustomerSuccessEngagementLetter."""
type CustomerSuccessEngagementLetterConnection {
  """A list of edges."""
  edges: [CustomerSuccessEngagementLetterEdge!]!

  """A list of nodes."""
  nodes: [CustomerSuccessEngagementLetter!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of CustomerSuccessEngagementLetterCreate"""
input CustomerSuccessEngagementLetterCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  file: FilestackInput!
}

"""Autogenerated return type of CustomerSuccessEngagementLetterCreate."""
type CustomerSuccessEngagementLetterCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  engagementLetter: CustomerSuccessEngagementLetter!
}

"""An edge in a connection."""
type CustomerSuccessEngagementLetterEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: CustomerSuccessEngagementLetter!
}

type CustomerSuccessMaturityIndex {
  clientsCount: ClientsCount!
  clientsCountOptions: [Option!]!
  id: ID!
  industry: Industry!
  industryOptions: [Option!]!
  ledger: Ledger!
  ledgerOptions: [Option!]!
  projectedPercentGrowthForThisYear: Percentage

  """
  The lower bound of the revenue bracket used to determine the revenue score if revenue range is provided from CMI questions
  """
  revenueBracketBottom: Int

  """
  The upper bound of the revenue bracket used to determine the revenue score if revenue range is provided from CMI questions
  """
  revenueBracketTop: Int
  revenueLastYear: Money
  revenueScore: Int!
  score: Int!
}

"""Autogenerated input type of CustomerSuccessMaturityIndexCalculate"""
input CustomerSuccessMaturityIndexCalculateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customerSuccessMaturityIndex: MaturityIndexInput!
}

"""Autogenerated return type of CustomerSuccessMaturityIndexCalculate."""
type CustomerSuccessMaturityIndexCalculatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customerSuccessMaturityIndex: CustomerSuccessMaturityIndexUnion
}

"""Possible maturity index types based on version"""
union CustomerSuccessMaturityIndexUnion = CustomerSuccessMaturityIndex | CustomerSuccessVersion1MaturityIndex

type CustomerSuccessReferralCopy {
  description: String!
  title: String!
}

type CustomerSuccessVersion1MaturityIndex {
  clientsCount: ClientsCount!
  feeStructure: FeeStructure!
  id: ID!
  industry: Industry!
  ledger: Ledger!
  paymentCollectionTool: MaturityIndexPaymentCollectionToolEnum
  paymentCollectionToolOther: String
  projectedPercentGrowthForThisYear: Percentage
  revenueLastYear: Money
  score: Int!
  staffCount: StaffCount!
  workflowTool: MaturityIndexWorkflowToolEnum
  workflowToolOther: String
}

input CustomTemplateFilter {
  """Name of the template"""
  nameCont: String
}

type Dashboard {
  """Renders the graph of clients data."""
  clientsGraph(demo: Boolean): DashboardClientsGraph!

  """Renders the graph of payments data."""
  paymentsGraph(demo: Boolean): DashboardPaymentsGraph!
  settings: DashboardSettings!
}

type DashboardBudget {
  """Amount of the budget."""
  amount: Money!

  """Date of the budget."""
  date: Date!
}

type DashboardClientsGraph {
  """Number of current clients."""
  currentClientsCount: Int!

  """Count of clients per month."""
  monthlyClientsCount: [DashboardMonthlyClientsCount!]!

  """Number of new clients."""
  newClientsCount: Int!

  """Grouping all the variances regarding clients."""
  variances: DashboardClientVariances!
}

type DashboardClientVariances {
  """
  Variance in current client count (how much change and in which direction).
  """
  currentClientsCount: DashboardVarianceCurrentClientsCount!
}

type DashboardMonthlyClientsCount {
  """Number of current clients this month."""
  count: Int!
  date: Date!
}

type DashboardPaymentsCount {
  count: Int!
}

type DashboardPaymentsCountPercentage {
  count: Int!
  percentage: Int!
}

type DashboardPaymentsCountSum {
  count: Int!
  sum: Float!
}

type DashboardPaymentsData {
  """Number of payments this month."""
  count: Int!

  """Credited this month."""
  credit: Float!

  """Projected credits this month."""
  creditProjected: Float!

  """Month."""
  date: Date!

  """Debited this month."""
  debit: Float!

  """Projected debits this month."""
  debitProjected: Float!

  """Total for the month."""
  total: Float!
}

type DashboardPaymentsGraph {
  """Graph data of payments."""
  data: [DashboardPaymentsData!]!
  generatedAt: DateTime!

  """Payments metadata"""
  metadata: DashboardPaymentsMetadata!
}

type DashboardPaymentsMetadata {
  """Number of at risk clients and sum of at risk payments."""
  atRisk: DashboardPaymentsCountSum!

  """Payments collected."""
  collected: Float!

  """Number of defaults and sum of defaults."""
  defaults: DashboardPaymentsCountSum!

  """Number of expiring cards and sum of expiring payments."""
  expiring: DashboardPaymentsCountSum!

  """Count and percentage of payments."""
  payments: DashboardPaymentsCountPercentage!

  """Potential payments."""
  potential: Float!

  """Payments scheduled."""
  scheduled: Float!

  """Payments total."""
  total: Float!

  """Number of verifying payments."""
  verifying: DashboardPaymentsCount!
}

"""Autogenerated input type of DashboardRevenueGrowthTargetSet"""
input DashboardRevenueGrowthTargetSetInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Estimate of last year's revenue."""
  revenueLastYear: MoneyInput

  """Estimated percentage growth of revenue for this year"""
  projectedGrowthForThisYear: PercentageInput!
}

"""Autogenerated return type of DashboardRevenueGrowthTargetSet."""
type DashboardRevenueGrowthTargetSetPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  settings: DashboardSettings
}

type DashboardSettings {
  """Estimated yearly budget for the current period."""
  budgets: [DashboardBudget!]

  """Calculated estimate of this year's revenue."""
  growthTarget: Money

  """Recorded estimate of this year's revenue growth rate."""
  projectedGrowthForThisYear: Percentage

  """Latest recorded estimate of last year's revenue."""
  revenueLastYear: Money

  """Recorded staff count of the practice."""
  staffCount: Int
}

"""Autogenerated input type of DashboardUpdateSettings"""
input DashboardUpdateSettingsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  settings: SettingsInput!
}

"""Autogenerated return type of DashboardUpdateSettings."""
type DashboardUpdateSettingsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  settings: DashboardSettings!
}

type DashboardVarianceCurrentClientsCount {
  """Direction of change (e.g. positive or negative)."""
  isPositive: Boolean!

  """How much the current clients count changed."""
  number: Int!
}

"""ISO8601 formatted date (yyyy-mm-dd)"""
scalar Date

input DateInput {
  """ISO formatted date"""
  date: Date
}

input DateRangeInput {
  """ISO formatted date"""
  from: Date = "1979-01-01"

  """ISO formatted date"""
  to: Date!
}

scalar DateTime

scalar Decimal

enum DefaultBillingType {
  UPFRONT
  ESTIMATE
  ON_COMPLETION
  RECURRING
  INCLUDED
}

type Disbursal {
  amount: Money!
  availableOn: Date!
  clawbacks(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClawbackConnection!
  disputes(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PaymentsDisbursalDisputeConnection
  externalId: String!
  feeAmount: Money!
  feeDescription: String!
  id: ID!
  message: String

  """Flag to indicate if there is any payments fee pending"""
  paymentFeesPending: Boolean!
  payments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PaymentConnection
  paymentsCount: Int!
  startedAt: DateTime!
  state: PaymentsDisbursalStateEnum!
}

"""The connection type for Disbursal."""
type DisbursalConnection {
  """A list of edges."""
  edges: [DisbursalEdge!]!

  """A list of nodes."""
  nodes: [Disbursal!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type DisbursalEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Disbursal!
}

input DisbursalFilter {
  """ISO formatted date"""
  availableOnAfter: Date

  """ISO formatted date"""
  availableOnBefore: Date
  externalIdEq: String
  stateEq: PaymentsPaymentStateEnum
}

type Disbursals {
  bankAccount: BankAccount
  id: ID!
  isEnabled: Boolean! @deprecated(reason: "Use practice.paymentSettings.isDisbursalsEnabled instead.")
}

enum DisbursalsDisablementType {
  KYC_REQUIRED
  FRAUD_DETECTION
  SUBSCRIPTION_EXPIRED
  DISBURSAL_ACCOUNT_CHANGED
  REJECTED_BY_STAFF
  STRIPE_PAYOUTS_DISABLED
}

interface DisplayableError {
  """Path to the input field which caused the error"""
  field: [String!]

  """The error message"""
  message: String!
}

type Duration {
  count: Int!
  interval: DurationInterval!
}

input DurationInput {
  count: Int!
  interval: DurationInterval!
}

enum DurationInterval {
  DAYS
  WEEKS
  MONTHS
  YEARS
}

scalar EmailAddress

type EmailPreview {
  """The rendered HTML email content"""
  contentHtml: String!

  """The sender email address"""
  from: EmailAddress!

  """The subject of the email message"""
  subject: String!

  """A list of destination email addresses"""
  to: [EmailAddress!]!
}

type EmailSettings {
  name: EmailSettingsName!
  setting: EmailSettingsSetting!
}

input EmailSettingsInput {
  name: EmailSettingsName!
  setting: EmailSettingsSetting!
}

enum EmailSettingsName {
  INVOICES
  PAYMENT_RECEIPTS
}

enum EmailSettingsSetting {
  DEFAULT
  ON
  OFF
}

type EmailTemplate implements PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  slug: ID!
  subject: String!
  updatedAt: DateTime!
}

input EmailTemplateInput {
  subject: String!
  name: String
  content: String!
}

interface EmailTemplateInterface {
  subject: String!
}

"""
Represents the contract between a practice and a client; (also known as a Proposal).
"""
type Engagement {
  acceptedPaymentMethodTypes: [PaymentMethodType!]
  deployJobsEnabled: Boolean!
  deployableJobsCount: Int!
  id: ID!
  lockVersion: Int!
  name: String!
  paymentMethod: PaymentMethod
  referenceNumber: ID!
  uuid: ID! @deprecated(reason: "Use id instead, which, for a time, will be uuid value (also deprecated), but then will be slug value.")
}

"""The connection type for Engagement."""
type EngagementConnection {
  """A list of edges."""
  edges: [EngagementEdge!]!

  """A list of nodes."""
  nodes: [Engagement!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of EngagementDeployJobsSettingUpdate"""
input EngagementDeployJobsSettingUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The UUID of the Engagement"""
  uuid: ID!

  """Enable/Disable deploy jobs flag"""
  enabled: Boolean!
}

"""Autogenerated return type of EngagementDeployJobsSettingUpdate."""
type EngagementDeployJobsSettingUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  engagement: Engagement
  userErrors: [UserError!]
}

"""An edge in a connection."""
type EngagementEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Engagement!
}

"""Autogenerated input type of EngagementJobsSend"""
input EngagementJobsSendInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The UUID of the Engagement"""
  uuid: ID!
}

"""Autogenerated return type of EngagementJobsSend."""
type EngagementJobsSendPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  engagement: Engagement
  userErrors: [UserError!]
}

enum EngagementLetterState {
  INTEGRATED
  PENDING
  DELETED
}

type EngagementLetterTemplate implements PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  isDefault: Boolean!
  name: String!
  slug: ID!
  updatedAt: DateTime!
}

"""Autogenerated input type of EngagementNameChange"""
input EngagementNameChangeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The UUID of the Engagement"""
  id: ID!

  """New name of the Engagement"""
  name: String!
}

"""Autogenerated return type of EngagementNameChange."""
type EngagementNameChangePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  engagement: Engagement
  userErrors: [UserError!]
}

enum EngagementState {
  ACTIVE
  COMPLETED
  DELETED
  DRAFT
  LOST
  QUEUED
  SENT
}

enum Environment {
  """Development environment"""
  DEVELOPMENT

  """Test environment"""
  TEST

  """Staging environment"""
  STAGING

  """Production environment"""
  PRODUCTION
}

"""Input type for estimate quantity rule."""
input EstimateQuantityRuleInput {
  """Quantity amount"""
  amount: Decimal!
}

type ExitSurvey {
  """Date user left ignition and submitted survey"""
  createdAt: DateTime!

  """Any feedback as to reason for leaving"""
  feedback: String

  """Any other payments tool that user will be using"""
  paymentAlternative: String
  practiceId: ID!

  """Any other proposal tool that user will be using"""
  proposalAlternative: String

  """Reason for leaving ignition"""
  reason: String

  """On a scale of 1-10 how likely is an user to come back"""
  returnLikelihood: Int
  userId: ID!
  uuid: ID!
}

"""Input fields for an exit survey"""
input ExitSurveyInputType {
  """Reason for leaving"""
  reason: String!

  """Any feedback as to reason for leaving"""
  feedback: String!

  """Any other proposal tool that user will be using"""
  proposalAlternative: String

  """Any other payments tool that user will be using"""
  paymentAlternative: String

  """On a scale of 1-10 how likely is an user to come back"""
  returnLikelihood: Int
}

type Export {
  id: ID!
  user: User!
}

"""Autogenerated input type of ExportPayments"""
input ExportPaymentsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of ExportPayments."""
type ExportPaymentsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  export: Export!
}

"""Autogenerated input type of ExportProposals"""
input ExportProposalsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """An array of additional string search filters"""
  search: [String!] = []

  """Primary search filter"""
  state: EngagementState
}

"""Autogenerated return type of ExportProposals."""
type ExportProposalsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  export: Export!
}

"""Autogenerated input type of ExportServices"""
input ExportServicesInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of ExportServices."""
type ExportServicesPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  export: Export!
}

type Feature {
  available: Boolean!
  description: String!
  id: ID!
  name: String!
}

"""The connection type for Feature."""
type FeatureConnection {
  """Maximum number of active users allowed on a practice"""
  activeUsersLimit: Int

  """Describes how long it takes to confirm a bank account"""
  bankAccountDescription: Html

  """Whether we can add more users based on current plan"""
  canAddMoreUsers: Boolean!

  """A list of edges."""
  edges: [FeatureEdge!]!

  """
  Whether we can add more signatories to a proposal based on current plan
  """
  isProposalSignatoriesLimitUpgradeable: Boolean!

  """A list of nodes."""
  nodes: [Feature!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Proposal multiple options are enabled"""
  proposalOptionsEnabled: Boolean!

  """Maximum number of recipients allowed on a proposal"""
  proposalRecipientsLimit: Int

  """Maximum number of signatories allowed on a proposal"""
  proposalSignatoriesLimit: Int!
}

"""An edge in a connection."""
type FeatureEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Feature!
}

type FeatureFlag {
  id: String!
  isEnabled: Boolean!
}

enum FeeStructure {
  """as recurring fixed fees"""
  RECURRING_FIXED_FEES

  """as fixed fee project work"""
  FIXED_FEE_PROJECT_WORK

  """hourly but switching to fixed fees"""
  HOURLY_BUT_SWITCHING

  """hourly"""
  HOURLY
}

"""
Additional expenses added to the price of a transaction
The total fee would be
[ ((price_in_cents * fixed_percent) + base_cents), capped_cents ].max

"""
type FeeType {
  """The max amount of the fee, (NULL indicates no max)"""
  cappedAmount: Money

  """The description of the fee"""
  description: String

  """A fixed amount per charge (0 is acceptable, if percent only)"""
  fixedAmount: Money

  """
  Additional fee as a percent of total price (0 is acceptable, if base only)
  """
  percentage: Percentage
}

type Filestack {
  """The name of the file that was uploaded."""
  filename: String!

  """
  The Filestack file handle. This is useful because other Filestack methods accept handles as their input.
  """
  handle: ID!

  """The mimetype of the file, if available."""
  mimetype: String

  """
  This field is reported by the picker at the time the file is uploaded. It is
  the location where the file was selected from. This can be the location in a
  user's local file system, or the id or path reported by a cloud drive.
  """
  originalPath: String!

  """
  The size of the file in bytes, if available. We will attach this directly to
  the returned metadata when we have it, otherwise you can always get the size
  by calling client.metadata(handle)
  """
  size: Int!

  """
  The source the file was uploaded from. This could be 'local_file_system', 'instagram', 'dropbox' or any other source.
  """
  source: String!

  """
  The status of the upload. This is not returned if the Filestack link is a
  symbolic link. Possible statuses are: 'Stored', 'InTransit', and 'Failed'.
  'InTransit' means the file has not yet been copied to your bucket, but the
  Filestack link is valid and won't change once the status changes to 'Stored'.
  If you have configured webhooks, you will receive a webhook when the status
  changes to 'Stored'.
  """
  status: String

  """
  This string value is a UUID that can be used to track files in callbacks.
  """
  uploadId: String!

  """The Filestack URL that points to the uploaded file."""
  url: URL!
}

input FilestackInput {
  filename: String!
  handle: ID!
  mimetype: String
  originalPath: String!
  size: Int!
  source: String!
  status: String
  uploadId: String!
  url: URL!
}

"""Input type for fixed price rule."""
input FixedPriceRuleInput {
  """Price amount"""
  amount: MoneyInput!
}

enum FrequencyTypeEnum {
  YEARLY
  MONTHLY
  WEEKLY
  DAILY
}

"""Returns safe HTML sanitised with permitted tags"""
scalar Html

"""Deprecated - use the Html type instead."""
type HtmlText {
  escaped: String! @deprecated(reason: "Use the Html type instead")
  raw: String! @deprecated(reason: "Use the Html type instead")
}

"""Type for filtering AppServices"""
input IgnitionAppServiceFilterType {
  """Return AppServices with names containing this value"""
  nameCont: String

  """If true, exclude AppServices mapped to a Service"""
  excludeMapped: Boolean

  """If true, only include AppServices with conversion errors"""
  onlyWithConversionErrors: Boolean
}

"""
An AppService is a counterpart to a Service that exists in an App's domain.
AppService can be linked ("mapped") to Services, and can be used to create
Services. For example, a Item in QuickBooks or in Xero could be the underlying
record behind an AppService.
"""
type IgnitionAppServiceType {
  app: App!

  """List of jobs associated with the item"""
  asyncJobs: [AsyncJob!]
  description: String

  """An identifier used by the App this AppService belongs to"""
  externalId: ID!
  id: ID!
  name: String!
  price: Money
}

"""An image uploaded via Base64 encoding"""
input ImageInput {
  filename: String!
  data: String!
}

"""Client import"""
type ImportType {
  id: ID!
}

"""Input type for minimum price rule."""
input IncludedPriceRuleInput {
  """ISO currency code"""
  currency: String!
}

enum Industry {
  """accounting"""
  ACCOUNTING

  """bookkeeping"""
  BOOKKEEPING

  """coaching"""
  COACHING

  """consulting"""
  CONSULTING

  """digital agency"""
  DIGITAL_AGENCY

  """financial services"""
  FINANCIAL_SERVICES

  """IT solutions"""
  IT_SOLUTIONS

  """law"""
  LAW

  """software"""
  SOFTWARE

  """other"""
  OTHER
}

type IntroMessageTemplate implements PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  isDefault: Boolean!
  name: String!
  slug: ID!
  updatedAt: DateTime!
}

"""The connection type for IntroMessageTemplate."""
type IntroMessageTemplateConnection {
  """A list of edges."""
  edges: [IntroMessageTemplateEdge!]!

  """A list of nodes."""
  nodes: [IntroMessageTemplate!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of IntroMessageTemplateCreate"""
input IntroMessageTemplateCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: TemplateInput!
}

"""Autogenerated return type of IntroMessageTemplateCreate."""
type IntroMessageTemplateCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: IntroMessageTemplate
  templates: Templates
}

"""Autogenerated input type of IntroMessageTemplateDelete"""
input IntroMessageTemplateDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug or UUID of intro message template"""
  id: ID!
}

"""Autogenerated return type of IntroMessageTemplateDelete."""
type IntroMessageTemplateDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  templates: Templates
}

"""An edge in a connection."""
type IntroMessageTemplateEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: IntroMessageTemplate!
}

"""Autogenerated input type of IntroMessageTemplateSetDefault"""
input IntroMessageTemplateSetDefaultInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of intro message template"""
  id: ID!
}

"""Autogenerated return type of IntroMessageTemplateSetDefault."""
type IntroMessageTemplateSetDefaultPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
  templates: Templates
}

"""Autogenerated input type of IntroMessageTemplateUpdate"""
input IntroMessageTemplateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug or UUID of intro message template"""
  id: ID!
  template: TemplateInput!
}

"""Autogenerated return type of IntroMessageTemplateUpdate."""
type IntroMessageTemplateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: IntroMessageTemplate
  templates: Templates
}

"""Input fields for an invitation"""
input InvitationInputType {
  """The user's full name"""
  fullName: String!

  """The user's email address"""
  email: EmailAddress!

  """ACCOUNTANT or PRACTICEADMIN"""
  role: UserRoleEnum!
}

type InvitationType {
  """The invitation's email address"""
  email: EmailAddress!

  """Nature of invitation error (if it exists)"""
  errorMessage: String

  """Returned user (if invitation is successful)"""
  user: User
}

type InvoiceDeploySettings {
  """The due date of a manual invoice will be this many days after issuing."""
  defaultInvoiceTerms: Int!

  """
  The default ledger item to apply to invoice line items, unless they have an explicit mapping.
  """
  defaultLedgerItemId: ID

  """
  The default setting for new clients for whether to deploy invoices automatically after being issued.
  """
  deployInvoices: Boolean!

  """Whether the InvoiceDeploy settings as configured are valid."""
  isValid: Boolean!

  """Whether to include the full service description on each invoice item."""
  longItemDescription: Boolean!

  """
  The due date of an automatic invoice will be this many days after issuing.
  """
  recurringInvoiceTerms: Int!
}

input InvoiceDeploySettingsInput {
  deployInvoices: Boolean!
  defaultInvoiceTerms: Int!
  recurringInvoiceTerms: Int!
  longItemDescription: Boolean!
  defaultLedgerItemId: ID!
}

"""Autogenerated input type of InvoiceDeploySettingsUpdate"""
input InvoiceDeploySettingsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  appName: String!
  invoiceDeploySettings: InvoiceDeploySettingsInput!
}

"""Autogenerated return type of InvoiceDeploySettingsUpdate."""
type InvoiceDeploySettingsUpdatePayload {
  app: App!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

type InvoiceNotificationSettings {
  sendNotifications: Boolean!
  tenantId: ID!
  useDefaultSettings: Boolean!
}

scalar IpAddress

type Ipm {
  apiKey: String
  lastSynced: DateTime
  services: [IpmService!]
  status: IpmStatus!
  workTemplateMappings: [IpmWorkTemplateMapping!]
  workTemplates: [IpmWorkTemplate!]
}

"""Autogenerated input type of IpmAuthorise"""
input IpmAuthoriseInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Ipm api key"""
  apiKey: String!
}

"""Autogenerated return type of IpmAuthorise."""
type IpmAuthorisePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  ipm: Ipm
}

"""Autogenerated input type of IpmDisconnect"""
input IpmDisconnectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of IpmDisconnect."""
type IpmDisconnectPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  ipm: Ipm
}

"""Autogenerated input type of IpmEnable"""
input IpmEnableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of IpmEnable."""
type IpmEnablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  ipm: Ipm
}

type IpmService {
  id: ID!
  subtitle: String
  title: String!
}

enum IpmStatus {
  ENABLED
  AUTHORISED
  CONFIRMED
  DISCONNECTED
  UNAUTHORISED
}

type IpmWorkTemplate {
  id: ID!
  title: String!
}

type IpmWorkTemplateMapping {
  serviceId: ID!
  workTemplateId: ID!
}

input IpmWorkTemplateMappingInputType {
  serviceId: ID!
  workTemplateId: ID!
}

"""Autogenerated input type of IpmWorkTemplateMappingsConfirm"""
input IpmWorkTemplateMappingsConfirmInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  mappings: [IpmWorkTemplateMappingInputType!]!
}

"""Autogenerated return type of IpmWorkTemplateMappingsConfirm."""
type IpmWorkTemplateMappingsConfirmPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  ipm: Ipm
}

"""Autogenerated input type of IpmWorkTemplateMappingsUpdate"""
input IpmWorkTemplateMappingsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  mappings: [IpmWorkTemplateMappingInputType!]!
}

"""Autogenerated return type of IpmWorkTemplateMappingsUpdate."""
type IpmWorkTemplateMappingsUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  ipm: Ipm
}

"""Autogenerated input type of IpmWorkTemplatesSyncAll"""
input IpmWorkTemplatesSyncAllInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of IpmWorkTemplatesSyncAll."""
type IpmWorkTemplatesSyncAllPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  ipm: Ipm
}

type Karbon {
  apiKey: String
  services: [KarbonService!]
  status: KarbonStatus!
  workTemplateMappings: [KarbonWorkTemplateMapping!]
  workTemplates: [KarbonWorkTemplate!]
}

"""Autogenerated input type of KarbonAuthorise"""
input KarbonAuthoriseInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Karbon integration api key"""
  apiKey: String!
}

"""Autogenerated return type of KarbonAuthorise."""
type KarbonAuthorisePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  karbon: Karbon
  userErrors: [UserError!]
}

"""Autogenerated input type of KarbonDisconnect"""
input KarbonDisconnectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of KarbonDisconnect."""
type KarbonDisconnectPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  karbon: Karbon
}

"""Autogenerated input type of KarbonEnable"""
input KarbonEnableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of KarbonEnable."""
type KarbonEnablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  karbon: Karbon
}

type KarbonService {
  id: ID!
  subtitle: String
  title: String!
}

enum KarbonStatus {
  ENABLED
  AUTHORISED
  CONFIRMED
  DISCONNECTED
  UNAUTHORISED
}

type KarbonWorkTemplate {
  title: String!
  uuid: ID!
}

type KarbonWorkTemplateMapping {
  serviceId: ID!
  workTemplateId: ID!
}

"""Autogenerated input type of KarbonWorkTemplateMappingsConfirm"""
input KarbonWorkTemplateMappingsConfirmInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  mappings: [WorkTemplateMappingInput!]!
}

"""Autogenerated return type of KarbonWorkTemplateMappingsConfirm."""
type KarbonWorkTemplateMappingsConfirmPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  karbon: Karbon
}

"""Autogenerated input type of KarbonWorkTemplateMappingsUpdate"""
input KarbonWorkTemplateMappingsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  mappings: [WorkTemplateMappingInput!]!
}

"""Autogenerated return type of KarbonWorkTemplateMappingsUpdate."""
type KarbonWorkTemplateMappingsUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  karbon: Karbon
}

"""Autogenerated input type of KarbonWorkTemplatesSyncAll"""
input KarbonWorkTemplatesSyncAllInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of KarbonWorkTemplatesSyncAll."""
type KarbonWorkTemplatesSyncAllPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  karbon: Karbon
}

enum Ledger {
  """Xero"""
  XERO

  """QuickBooks Online"""
  QUICKBOOKS_ONLINE

  """a different cloud ledger"""
  CLOUD_LEDGER

  """a desktop ledger"""
  DESKTOP_LEDGER
}

"""Capabilities Ledger Item."""
type LedgerItem {
  """Ledger app"""
  app: App!

  """Ledger Items with the same grouping should be displayed together"""
  grouping: String

  """Slug of ledger item"""
  id: ID!

  """Ledger Item Name"""
  name: String!
}

"""The connection type for LedgerItem."""
type LedgerItemConnection {
  """A list of edges."""
  edges: [LedgerItemEdge!]!

  """A list of nodes."""
  nodes: [LedgerItem!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type LedgerItemEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: LedgerItem!
}

"""Input type for Capabilities Ledger Item."""
input LedgerItemInput {
  """Slug of ledger item."""
  ledgerItemId: ID!

  """Ledger app (Xero or QuickBooks)"""
  appName: String!
}

input MaturityIndexInput {
  clientsCount: ClientsCount!
  feeStructure: FeeStructure
  industry: Industry!
  ledger: Ledger!
  staffCount: StaffCount
  workflowTool: MaturityIndexWorkflowToolEnum
  workflowToolOther: String
  paymentCollectionTool: MaturityIndexPaymentCollectionToolEnum
  paymentCollectionToolOther: String
  revenueLastYear: BigInt
  projectedPercentGrowthForThisYear: BigInt
  revenueBracket: MaturityIndexRevenueBracketValueEnum
}

enum MaturityIndexPaymentCollectionToolEnum {
  """Clients pay invoices with bank transfer/direct deposit"""
  CLIENTS_PAY_INVOICES_WITH_BANK_TRANSFER_DIRECT_DEPOSIT

  """Clients pay invoices with cheque or cash"""
  CLIENTS_PAY_INVOICES_WITH_CHEQUE_OR_CASH

  """Client sets up recurring standing order/eft"""
  CLIENT_SETS_UP_RECURRING_STANDING_ORDER_EFT

  """Point of Sale/Terminal"""
  POINT_OF_SALE_TERMINAL

  """Square Terminal"""
  SQUARE_TERMINAL

  """Bpay (AU)"""
  BPAY_AU

  """Interac eTransfer (CA)"""
  INTERAC_ETRANSFER_CA

  """Paypal"""
  PAYPAL

  """GoCardless (Direct)"""
  GOCARDLESS_DIRECT

  """Stripe (Direct)"""
  STRIPE_DIRECT

  """Xero Online payments w/ Stripe"""
  XERO_ONLINE_PAYMENTS_W_STRIPE

  """Xero Online payments w/ Gocardless"""
  XERO_ONLINE_PAYMENTS_W_GOCARDLESS

  """Square Online Payments"""
  SQUARE_ONLINE_PAYMENTS

  """QuickBooks Payments"""
  QUICKBOOKS_PAYMENTS

  """EziDebit/e-way (AU)"""
  EZIDEBIT_E_WAY_AU

  """Rotessa (CA)"""
  ROTESSA_CA

  """bill.com (US)"""
  BILL_COM_US

  """authorize.net"""
  AUTHORIZE_NET

  """Canopy Tax"""
  CANOPY_TAX

  """London & Zurich"""
  LONDON_ZURICH

  """Merchant account via my bank"""
  MERCHANT_ACCOUNT_VIA_MY_BANK

  """I use/I intend to use Ignition Payments"""
  PRACTICE_IGNITION_PAYMENTS

  """Other"""
  OTHER
}

enum MaturityIndexRevenueBracketValueEnum {
  LOWEST
  LOW
  LOW_MID
  HIGH_MID
  HIGH
  HIGHEST
}

enum MaturityIndexWorkflowToolEnum {
  """None"""
  NONE

  """Xero Practice Manager"""
  XERO_PRACTICE_MANAGER

  """Intuit Practice Manager"""
  INTUIT_PRACTICE_MANAGER

  """Karbon"""
  KARBON

  """Workflow Max"""
  WORKFLOW_MAX

  """Aero workflow"""
  AERO_WORKFLOW

  """Jetpack workflow"""
  JETPACK_WORKFLOW

  """Senta"""
  SENTA

  """Asana"""
  ASANA

  """Trello"""
  TRELLO

  """HubSpot"""
  HUBSPOT

  """Airtable"""
  AIRTABLE

  """Clickup"""
  CLICKUP

  """Zoho CRM"""
  ZOHO_CRM

  """Monday.com"""
  MONDAY_COM

  """Pixie"""
  PIXIE

  """Capium"""
  CAPIUM

  """AccountancyManager (UK)"""
  ACCOUNTANCYMANAGER_UK

  """APS / Reckon"""
  APS_RECKON

  """IRIS"""
  IRIS

  """CCH iFirm"""
  CCH_IFIRM

  """Digita"""
  DIGITA

  """QuickBooks Online Accountant"""
  QUICKBOOKS_ONLINE_ACCOUNTANT

  """TaxCalc"""
  TAXCALC

  """Thomson Reuters Practice CS"""
  THOMSON_REUTERS_PRACTICE_CS

  """Sage Handisoft"""
  SAGE_HANDISOFT

  """IRIS Practice Engine"""
  IRIS_PRACTICE_ENGINE

  """Nomisma"""
  NOMISMA

  """Microsoft Dynamics"""
  MICROSOFT_DYNAMICS

  """CCH axcess"""
  CCH_AXCESS

  """Onvio"""
  ONVIO

  """Microsoft Excel"""
  MICROSOFT_EXCEL

  """Google sheets"""
  GOOGLE_SHEETS

  """In-house built solution"""
  IN_HOUSE_BUILT_SOLUTION

  """Other"""
  OTHER
}

"""Input type for minimum price rule."""
input MinimumPriceRuleInput {
  """Minimum price amount"""
  min: MoneyInput!
}

type Money {
  cents: BigInt!
  currency: Currency!
  dollars: Decimal!
  format: String!
}

input MoneyInput {
  currency: String!
  cents: BigInt!
}

type Mutation {
  acknowledgementAdd(
    """Parameters for AcknowledgementAdd"""
    input: AcknowledgementAddInput!
  ): AcknowledgementAddPayload
  acknowledgementRemove(
    """Parameters for AcknowledgementRemove"""
    input: AcknowledgementRemoveInput!
  ): AcknowledgementRemovePayload

  """Revoke API app access"""
  apiAccessTokenRevoke(
    """Parameters for ApiAccessTokenRevoke"""
    input: ApiAccessTokenRevokeInput!
  ): ApiAccessTokenRevokePayload
  appClientSyncSettingsUpdate(
    """Parameters for ClientSyncSettingsUpdate"""
    input: ClientSyncSettingsUpdateInput!
  ): ClientSyncSettingsUpdatePayload

  """Connect a user-configurable App"""
  appConnect(
    """Parameters for AppConnect"""
    input: AppConnectInput!
  ): AppConnectPayload

  """Disconnect a user-configurable App"""
  appDisconnect(
    """Parameters for AppDisconnect"""
    input: AppDisconnectInput!
  ): AppDisconnectPayload

  """Enable a user-configurable App"""
  appEnable(
    """Parameters for AppEnable"""
    input: AppEnableInput!
  ): AppEnablePayload
  appInvoiceDeploySettingsUpdate(
    """Parameters for InvoiceDeploySettingsUpdate"""
    input: InvoiceDeploySettingsUpdateInput!
  ): InvoiceDeploySettingsUpdatePayload

  """Create Ignition Services from AppServices"""
  appServicesBulkCreate(
    """Parameters for ServicesBulkCreate"""
    input: ServicesBulkCreateInput!
  ): ServicesBulkCreatePayload

  """Update sync settings for an App"""
  appSetClientSyncSettings(
    """Parameters for AppSetClientSyncSettings"""
    input: AppSetClientSyncSettingsInput!
  ): AppSetClientSyncSettingsPayload

  """Request a data sync for an App"""
  appSync(
    """Parameters for AppSync"""
    input: AppSyncInput!
  ): AppSyncPayload
  bankAccountFailureEmailTemplateUpdate(
    """Parameters for BankAccountFailureEmailTemplateUpdate"""
    input: BankAccountFailureEmailTemplateUpdateInput!
  ): BankAccountFailureEmailTemplateUpdatePayload
  bankAccountVerificationEmailTemplateUpdate(
    """Parameters for BankAccountVerificationEmailTemplateUpdate"""
    input: BankAccountVerificationEmailTemplateUpdateInput!
  ): BankAccountVerificationEmailTemplateUpdatePayload

  """Add a custom unit price rule name"""
  billingPriceRuleAddUnitName(
    """Parameters for BillingPriceRuleAddUnitName"""
    input: BillingPriceRuleAddUnitNameInput!
  ): BillingPriceRuleAddUnitNamePayload

  """Delete a custom unit name"""
  billingPriceRuleDeleteUnitName(
    """Parameters for BillingPriceRuleDeleteUnitName"""
    input: BillingPriceRuleDeleteUnitNameInput!
  ): BillingPriceRuleDeleteUnitNamePayload

  """Update Branding Theme Colour"""
  brandingThemeColourUpdate(
    """Parameters for BrandingThemeColourUpdate"""
    input: BrandingThemeColourUpdateInput!
  ): BrandingThemeColourUpdatePayload

  """Unset Branding Theme DefaultBrochure"""
  brandingThemeDefaultBrochureUnset(
    """Parameters for BrandingThemeDefaultBrochureUnset"""
    input: BrandingThemeDefaultBrochureUnsetInput!
  ): BrandingThemeDefaultBrochureUnsetPayload

  """Update Branding Theme DefaultBrochure"""
  brandingThemeDefaultBrochureUpdate(
    """Parameters for BrandingThemeDefaultBrochureUpdate"""
    input: BrandingThemeDefaultBrochureUpdateInput!
  ): BrandingThemeDefaultBrochureUpdatePayload

  """Unset Branding Theme Logo"""
  brandingThemeLogoUnset(
    """Parameters for BrandingThemeLogoUnset"""
    input: BrandingThemeLogoUnsetInput!
  ): BrandingThemeLogoUnsetPayload

  """Update Branding Theme Logo"""
  brandingThemeLogoUpdate(
    """Parameters for BrandingThemeLogoUpdate"""
    input: BrandingThemeLogoUpdateInput!
  ): BrandingThemeLogoUpdatePayload

  """Update Branding Theme Attributes (Logo, Colour, Default Brochure)"""
  brandingThemeUpdate(
    """Parameters for BrandingThemeUpdate"""
    input: BrandingThemeUpdateInput!
  ): BrandingThemeUpdatePayload

  """Create brochure for current practice."""
  brochureCreate(
    """Parameters for BrochureCreate"""
    input: BrochureCreateInput!
  ): BrochureCreatePayload

  """Archives the clients"""
  clientArchive(
    """Parameters for ClientArchive"""
    input: ClientArchiveInput!
  ): ClientArchivePayload

  """
  Configure a billing item to bill automatically on the specified date using the specified payment method.
  """
  clientBillingBillingItemBillAutomatically(
    """Parameters for ClientBillingItemBillAutomatically"""
    input: ClientBillingItemBillAutomaticallyInput!
  ): ClientBillingItemBillAutomaticallyPayload

  """Configure a billing item to bill manually on the specified date."""
  clientBillingBillingItemBillManually(
    """Parameters for ClientBillingItemBillManually"""
    input: ClientBillingItemBillManuallyInput!
  ): ClientBillingItemBillManuallyPayload

  """
  Preview the amount and last updated at of a smart billing quantity rule
  """
  clientBillingBillingItemPreviewSmartBillingQuantity(
    """Parameters for ClientBillingItemPreviewSmartBillingQuantity"""
    input: ClientBillingItemPreviewSmartBillingQuantityInput!
  ): ClientBillingItemPreviewSmartBillingQuantityPayload

  """
  Refresh the amount and last updated at of a smart billing quantity rule
  """
  clientBillingBillingItemRefreshSmartBillingQuantity(
    """Parameters for ClientBillingItemRefreshSmartBillingQuantity"""
    input: ClientBillingItemRefreshSmartBillingQuantityInput!
  ): ClientBillingItemRefreshSmartBillingQuantityPayload

  """Deploy client billing invoice"""
  clientBillingInvoiceDeploy(
    """Parameters for ClientBillingInvoiceDeploy"""
    input: ClientBillingInvoiceDeployInput!
  ): ClientBillingInvoiceDeployPayload

  """Issues client billing invoice"""
  clientBillingInvoiceIssue(
    """Parameters for ClientBillingInvoiceIssue"""
    input: ClientBillingInvoiceIssueInput!
  ): ClientBillingInvoiceIssuePayload

  """Reconcile client billing invoice"""
  clientBillingInvoiceReconcile(
    """Parameters for ClientBillingInvoiceReconcile"""
    input: ClientBillingInvoiceReconcileInput!
  ): ClientBillingInvoiceReconcilePayload

  """Sends invoice to client email"""
  clientBillingInvoiceSendInvoiceToClientEmail(
    """Parameters for ClientBillingInvoiceSendInvoiceToClientEmail"""
    input: ClientBillingInvoiceSendInvoiceToClientEmailInput!
  ): ClientBillingInvoiceSendInvoiceToClientEmailPayload

  """Archive billing items"""
  clientBillingItemArchive(
    """Parameters for ClientBillingItemArchive"""
    input: ClientBillingItemArchiveInput!
  ): ClientBillingItemArchivePayload

  """Reschedule billing items to a different invoice date"""
  clientBillingItemReschedule(
    """Parameters for ClientBillingItemReschedule"""
    input: ClientBillingItemRescheduleInput!
  ): ClientBillingItemReschedulePayload

  """Create a client"""
  clientCreate(
    """Parameters for ClientCreate"""
    input: ClientCreateInput!
  ): ClientCreatePayload

  """Update client groups"""
  clientGroupsUpdate(
    """Parameters for ClientGroupsUpdate"""
    input: ClientGroupsUpdateInput!
  ): ClientGroupsUpdatePayload
  clientImport(
    """Parameters for ClientImport"""
    input: ClientImportInput!
  ): ClientImportPayload

  """Create client import"""
  clientImportCreate(
    """Parameters for ClientImportCreate"""
    input: ClientImportCreateInput!
  ): ClientImportCreatePayload

  """Delete a client's payment method"""
  clientPaymentMethodDelete(
    """Parameters for ClientPaymentMethodDelete"""
    input: ClientPaymentMethodDeleteInput!
  ): ClientPaymentMethodDeletePayload

  """Cancel an agreed service."""
  clientServicesAgreedServiceCancel(
    """Parameters for ClientServicesAgreedServiceCancel"""
    input: ClientServicesAgreedServiceCancelInput!
  ): ClientServicesAgreedServiceCancelPayload

  """Create an agreed service (Instant Bill)."""
  clientServicesAgreedServiceCreate(
    """Parameters for ClientServicesAgreedServiceCreate"""
    input: ClientServicesAgreedServiceCreateInput!
  ): ClientServicesAgreedServiceCreatePayload

  """Disable an agreed service."""
  clientServicesAgreedServiceDisable(
    """Parameters for ClientServicesAgreedServiceDisable"""
    input: ClientServicesAgreedServiceDisableInput!
  ): ClientServicesAgreedServiceDisablePayload

  """Disable all agreed services for a client."""
  clientServicesAgreedServiceDisableAll(
    """Parameters for ClientServicesAgreedServiceDisableAll"""
    input: ClientServicesAgreedServiceDisableAllInput!
  ): ClientServicesAgreedServiceDisableAllPayload

  """
  Remove payment method from agreed service (i.e. set to Arrange payment manually).
  """
  clientServicesAgreedServiceRemovePaymentMethod(
    """Parameters for ClientServicesAgreedServiceRemovePaymentMethod"""
    input: ClientServicesAgreedServiceRemovePaymentMethodInput!
  ): ClientServicesAgreedServiceRemovePaymentMethodPayload

  """Set payment method on agreed service."""
  clientServicesAgreedServiceSetPaymentMethod(
    """Parameters for ClientServicesAgreedServiceSetPaymentMethod"""
    input: ClientServicesAgreedServiceSetPaymentMethodInput!
  ): ClientServicesAgreedServiceSetPaymentMethodPayload

  """Update an agreed service."""
  clientServicesAgreedServiceUpdate(
    """Parameters for ClientServicesAgreedServiceUpdate"""
    input: ClientServicesAgreedServiceUpdateInput!
  ): ClientServicesAgreedServiceUpdatePayload

  """Exports clients' agreed services"""
  clientServicesAgreedServicesExport(
    """Parameters for ClientServicesAgreedServicesExport"""
    input: ClientServicesAgreedServicesExportInput!
  ): ClientServicesAgreedServicesExportPayload

  """
  Maps a Client to an AppClient, creating a link which can be used by the integration that the AppClient comes from
  """
  clientSetAppMapping(
    """Parameters for ClientSetAppMapping"""
    input: ClientSetAppMappingInput!
  ): ClientSetAppMappingPayload

  """Update client's deploy invoices flag."""
  clientSetDeployInvoices(
    """Parameters for ClientSetDeployInvoices"""
    input: ClientSetDeployInvoicesInput!
  ): ClientSetDeployInvoicesPayload

  """Set the payment method for all future billing of the client."""
  clientSetPaymentMethod(
    """Parameters for ClientSetPaymentMethod"""
    input: ClientSetPaymentMethodInput!
  ): ClientSetPaymentMethodPayload

  """Update client's tag list info."""
  clientSetTagsList(
    """Parameters for ClientSetTagsList"""
    input: ClientSetTagsListInput!
  ): ClientSetTagsListPayload

  """
  Disables surcharges for all of the client's current and future payment methods
  """
  clientSurchargeDisable(
    """Parameters for ClientSurchargeDisable"""
    input: ClientSurchargeDisableInput!
  ): ClientSurchargeDisablePayload

  """
  Enables surcharges for all of the client's relevant current and future payment methods
  """
  clientSurchargeEnable(
    """Parameters for ClientSurchargeEnable"""
    input: ClientSurchargeEnableInput!
  ): ClientSurchargeEnablePayload

  """
  Switch payment method on the client's agreed services, billable services, billing items and payments
  """
  clientSwitchPaymentMethod(
    """Parameters for ClientSwitchPaymentMethod"""
    input: ClientSwitchPaymentMethodInput!
  ): ClientSwitchPaymentMethodPayload

  """Unarchives the client"""
  clientUnarchive(
    """Parameters for ClientUnarchive"""
    input: ClientUnarchiveInput!
  ): ClientUnarchivePayload

  """Update a client"""
  clientUpdate(
    """Parameters for ClientUpdate"""
    input: ClientUpdateInput!
  ): ClientUpdatePayload

  """Request deployment of a workflow item to the workflow app."""
  clientWorkflowItemStartDeployment(
    """Parameters for clientWorkflowItemStartDeployment"""
    input: clientWorkflowItemStartDeploymentInput!
  ): clientWorkflowItemStartDeploymentPayload

  """Creates a new workflow strategy for the client."""
  clientWorkflowStrategyCreate(
    """Parameters for clientWorkflowStrategyCreate"""
    input: clientWorkflowStrategyCreateInput!
  ): clientWorkflowStrategyCreatePayload

  """
  Mark a workflow strategy as inactive. Once inactive, any remaining undeployed
  workflow items will be removed and no further deploys will occur.
  """
  clientWorkflowStrategyDeactivate(
    """Parameters for clientWorkflowStrategyDeactivate"""
    input: clientWorkflowStrategyDeactivateInput!
  ): clientWorkflowStrategyDeactivatePayload

  """
  Deletes a workflow strategy and all of it's items. Only permitted if no workflow items have been deployed.
  """
  clientWorkflowStrategyDelete(
    """Parameters for clientWorkflowStrategyDelete"""
    input: clientWorkflowStrategyDeleteInput!
  ): clientWorkflowStrategyDeletePayload

  """Creates a copy of a workflow strategy"""
  clientWorkflowStrategyDuplicate(
    """Parameters for clientWorkflowStrategyDuplicate"""
    input: clientWorkflowStrategyDuplicateInput!
  ): clientWorkflowStrategyDuplicatePayload

  """Set workflow strategy to receive billing credits from a billing group."""
  clientWorkflowStrategySetBillingGroup(
    """Parameters for clientWorkflowStrategySetBillingGroup"""
    input: clientWorkflowStrategySetBillingGroupInput!
  ): clientWorkflowStrategySetBillingGroupPayload

  """
  Set workflow strategy to receive billing credits from the client billing group.
  """
  clientWorkflowStrategySetClientBillingGroup(
    """Parameters for clientWorkflowStrategySetClientBillingGroup"""
    input: clientWorkflowStrategySetClientBillingGroupInput!
  ): clientWorkflowStrategySetClientBillingGroupPayload @deprecated(reason: "Use setBillingGroup")

  """Sets the deploy strategy for a workflow strategy."""
  clientWorkflowStrategySetDeployStrategy(
    """Parameters for clientWorkflowStrategySetDeployStrategy"""
    input: clientWorkflowStrategySetDeployStrategyInput!
  ): clientWorkflowStrategySetDeployStrategyPayload

  """Sets the general settings for a workflow strategy."""
  clientWorkflowStrategySetGeneralSettings(
    """Parameters for clientWorkflowStrategySetGeneralSettings"""
    input: clientWorkflowStrategySetGeneralSettingsInput!
  ): clientWorkflowStrategySetGeneralSettingsPayload

  """
  Set a one-time (non recurring) schedule for a workflow strategy on a specified date.
  
  Can only be changed if the workflow strategy has not yet started.
  
  """
  clientWorkflowStrategySetOneTimeSchedule(
    """Parameters for clientWorkflowStrategySetOneTimeSchedule"""
    input: clientWorkflowStrategySetOneTimeScheduleInput!
  ): clientWorkflowStrategySetOneTimeSchedulePayload

  """
  Set a recurring schedule for a workflow strategy starting from the specified date.
  
  Can only be changed if the workflow strategy has not yet started.
  
  """
  clientWorkflowStrategySetRecurringSchedule(
    """Parameters for clientWorkflowStrategySetRecurringSchedule"""
    input: clientWorkflowStrategySetRecurringScheduleInput!
  ): clientWorkflowStrategySetRecurringSchedulePayload

  """
  Removes the billing group from a workflow strategy.
  
  Workflow strategies with no billing group will not receive billing credits.
  
  """
  clientWorkflowStrategyUnsetBillingGroup(
    """Parameters for clientWorkflowStrategyUnsetBillingGroup"""
    input: clientWorkflowStrategyUnsetBillingGroupInput!
  ): clientWorkflowStrategyUnsetBillingGroupPayload
  collectionsNotificationSettingsUpdate(
    """Parameters for CollectionsNotificationSettingsUpdate"""
    input: CollectionsNotificationSettingsUpdateInput!
  ): CollectionsNotificationSettingsUpdatePayload

  """Update contact's info."""
  contactUpdate(
    """Parameters for ContactUpdate"""
    input: ContactUpdateInput!
  ): ContactUpdatePayload
  customerSuccessMaturityIndexCalculate(
    """Parameters for CustomerSuccessMaturityIndexCalculate"""
    input: CustomerSuccessMaturityIndexCalculateInput!
  ): CustomerSuccessMaturityIndexCalculatePayload

  """Set new revenue growth target to recalculate CMI score"""
  dashboardRevenueGrowthTargetSet(
    """Parameters for DashboardRevenueGrowthTargetSet"""
    input: DashboardRevenueGrowthTargetSetInput!
  ): DashboardRevenueGrowthTargetSetPayload

  """Update practice's dashboard settings"""
  dashboardUpdate(
    """Parameters for DashboardUpdateSettings"""
    input: DashboardUpdateSettingsInput!
  ): DashboardUpdateSettingsPayload
  engagementDeployJobsSettingUpdate(
    """Parameters for EngagementDeployJobsSettingUpdate"""
    input: EngagementDeployJobsSettingUpdateInput!
  ): EngagementDeployJobsSettingUpdatePayload
  engagementJobsSend(
    """Parameters for EngagementJobsSend"""
    input: EngagementJobsSendInput!
  ): EngagementJobsSendPayload
  engagementLetterCreate(
    """Parameters for CustomerSuccessEngagementLetterCreate"""
    input: CustomerSuccessEngagementLetterCreateInput!
  ): CustomerSuccessEngagementLetterCreatePayload

  """Change engagement name."""
  engagementNameChange(
    """Parameters for EngagementNameChange"""
    input: EngagementNameChangeInput!
  ): EngagementNameChangePayload

  """Exports payments csv"""
  exportPayments(
    """Parameters for ExportPayments"""
    input: ExportPaymentsInput!
  ): ExportPaymentsPayload

  """Export CPE proposals as a csv"""
  exportProposals(
    """Parameters for ExportProposals"""
    input: ExportProposalsInput!
  ): ExportProposalsPayload

  """Exports services csv"""
  exportServices(
    """Parameters for ExportServices"""
    input: ExportServicesInput!
  ): ExportServicesPayload
  introMessageTemplateCreate(
    """Parameters for IntroMessageTemplateCreate"""
    input: IntroMessageTemplateCreateInput!
  ): IntroMessageTemplateCreatePayload
  introMessageTemplateDelete(
    """Parameters for IntroMessageTemplateDelete"""
    input: IntroMessageTemplateDeleteInput!
  ): IntroMessageTemplateDeletePayload
  introMessageTemplateSetDefault(
    """Parameters for IntroMessageTemplateSetDefault"""
    input: IntroMessageTemplateSetDefaultInput!
  ): IntroMessageTemplateSetDefaultPayload
  introMessageTemplateUpdate(
    """Parameters for IntroMessageTemplateUpdate"""
    input: IntroMessageTemplateUpdateInput!
  ): IntroMessageTemplateUpdatePayload
  ipmAuthorise(
    """Parameters for IpmAuthorise"""
    input: IpmAuthoriseInput!
  ): IpmAuthorisePayload
  ipmDisconnect(
    """Parameters for IpmDisconnect"""
    input: IpmDisconnectInput!
  ): IpmDisconnectPayload
  ipmEnable(
    """Parameters for IpmEnable"""
    input: IpmEnableInput!
  ): IpmEnablePayload
  ipmWorkTemplateMappingsConfirm(
    """Parameters for IpmWorkTemplateMappingsConfirm"""
    input: IpmWorkTemplateMappingsConfirmInput!
  ): IpmWorkTemplateMappingsConfirmPayload
  ipmWorkTemplateMappingsUpdate(
    """Parameters for IpmWorkTemplateMappingsUpdate"""
    input: IpmWorkTemplateMappingsUpdateInput!
  ): IpmWorkTemplateMappingsUpdatePayload
  ipmWorkTemplatesSyncAll(
    """Parameters for IpmWorkTemplatesSyncAll"""
    input: IpmWorkTemplatesSyncAllInput!
  ): IpmWorkTemplatesSyncAllPayload
  karbonAuthorise(
    """Parameters for KarbonAuthorise"""
    input: KarbonAuthoriseInput!
  ): KarbonAuthorisePayload
  karbonDisconnect(
    """Parameters for KarbonDisconnect"""
    input: KarbonDisconnectInput!
  ): KarbonDisconnectPayload
  karbonEnable(
    """Parameters for KarbonEnable"""
    input: KarbonEnableInput!
  ): KarbonEnablePayload
  karbonWorkTemplateMappingsConfirm(
    """Parameters for KarbonWorkTemplateMappingsConfirm"""
    input: KarbonWorkTemplateMappingsConfirmInput!
  ): KarbonWorkTemplateMappingsConfirmPayload
  karbonWorkTemplateMappingsUpdate(
    """Parameters for KarbonWorkTemplateMappingsUpdate"""
    input: KarbonWorkTemplateMappingsUpdateInput!
  ): KarbonWorkTemplateMappingsUpdatePayload
  karbonWorkTemplatesSyncAll(
    """Parameters for KarbonWorkTemplatesSyncAll"""
    input: KarbonWorkTemplatesSyncAllInput!
  ): KarbonWorkTemplatesSyncAllPayload
  newGroupProposalEmailTemplateUpdate(
    """Parameters for NewGroupProposalEmailTemplateUpdate"""
    input: NewGroupProposalEmailTemplateUpdateInput!
  ): NewGroupProposalEmailTemplateUpdatePayload
  newProposalEmailTemplateArchive(
    """Parameters for NewProposalEmailTemplateArchive"""
    input: NewProposalEmailTemplateArchiveInput!
  ): NewProposalEmailTemplateArchivePayload
  newProposalEmailTemplateCreate(
    """Parameters for NewProposalEmailTemplateCreate"""
    input: NewProposalEmailTemplateCreateInput!
  ): NewProposalEmailTemplateCreatePayload
  newProposalEmailTemplateUpdate(
    """Parameters for NewProposalEmailTemplateUpdate"""
    input: NewProposalEmailTemplateUpdateInput!
  ): NewProposalEmailTemplateUpdatePayload
  newSubmissionEmailTemplateUpdate(
    """Parameters for NewSubmissionEmailTemplateUpdate"""
    input: NewSubmissionEmailTemplateUpdateInput!
  ): NewSubmissionEmailTemplateUpdatePayload
  nextStepsMessageTemplateCreate(
    """Parameters for NextStepsMessageTemplateCreate"""
    input: NextStepsMessageTemplateCreateInput!
  ): NextStepsMessageTemplateCreatePayload
  nextStepsMessageTemplateDelete(
    """Parameters for NextStepsMessageTemplateDelete"""
    input: NextStepsMessageTemplateDeleteInput!
  ): NextStepsMessageTemplateDeletePayload
  nextStepsMessageTemplateSetDefault(
    """Parameters for NextStepsMessageTemplateSetDefault"""
    input: NextStepsMessageTemplateSetDefaultInput!
  ): NextStepsMessageTemplateSetDefaultPayload
  nextStepsMessageTemplateUpdate(
    """Parameters for NextStepsMessageTemplateUpdate"""
    input: NextStepsMessageTemplateUpdateInput!
  ): NextStepsMessageTemplateUpdatePayload

  """Cancels an uncollected payment"""
  paymentCancel(
    """Parameters for PaymentCancel"""
    input: PaymentCancelInput!
  ): PaymentCancelPayload

  """Create a payment method from a setup intent"""
  paymentMethodCreateFromSetupIntent(
    """Parameters for PaymentMethodCreateFromSetupIntent"""
    input: PaymentMethodCreateFromSetupIntentInput!
  ): PaymentMethodCreateFromSetupIntentPayload

  """Request payment method from a client. Does not send an email"""
  paymentMethodRequestCreate(
    """Parameters for PaymentMethodRequestCreate"""
    input: PaymentMethodRequestCreateInput!
  ): PaymentMethodRequestCreatePayload

  """Request a refund for a payment"""
  paymentRefundRequest(
    """Parameters for PaymentRefundRequest"""
    input: PaymentRefundRequestInput!
  ): PaymentRefundRequestPayload

  """Schedule collection of a payment"""
  paymentScheduleCollection(
    """Parameters for PaymentScheduleCollection"""
    input: PaymentScheduleCollectionInput!
  ): PaymentScheduleCollectionPayload

  """Start collection of a payment"""
  paymentStartCollection(
    """Parameters for PaymentStartCollection"""
    input: PaymentStartCollectionInput!
  ): PaymentStartCollectionPayload

  """Unschedule a scheduled collection on a payment"""
  paymentUnscheduleCollection(
    """Parameters for PaymentUnscheduleCollection"""
    input: PaymentUnscheduleCollectionInput!
  ): PaymentUnscheduleCollectionPayload

  """Update what types of collections this practice will require/accept"""
  paymentsCollectionSettingsUpdate(
    """Parameters for PaymentsCollectionSettingsUpdate"""
    input: PaymentsCollectionSettingsUpdateInput!
  ): PaymentsCollectionSettingsUpdatePayload

  """Update the disbursal account for payments"""
  paymentsDisbursalAccountUpdate(
    """Parameters for PaymentsDisbursalAccountUpdate"""
    input: PaymentsDisbursalAccountUpdateInput!
  ): PaymentsDisbursalAccountUpdatePayload
  paymentsDisbursalsExport(
    """Parameters for PaymentsDisbursalsExport"""
    input: PaymentsDisbursalsExportInput!
  ): PaymentsDisbursalsExportPayload

  """Asynchronously request payment methods from clients via email"""
  paymentsSendPaymentMethodRequestToClients(
    """Parameters for SendPaymentMethodRequestToClients"""
    input: SendPaymentMethodRequestToClientsInput!
  ): SendPaymentMethodRequestToClientsPayload

  """Create a payment method setup intent for a client"""
  paymentsSetupIntentCreate(
    """Parameters for PaymentMethodSetupIntentCreate"""
    input: PaymentMethodSetupIntentCreateInput!
  ): PaymentMethodSetupIntentCreatePayload

  """
  Allow the practice to stop using surcharges to pass on payment fees to their clients
  """
  paymentsSurchargeDisable(
    """Parameters for SurchargeDisable"""
    input: SurchargeDisableInput!
  ): SurchargeDisablePayload

  """
  Allow the practice to use surcharges to pass on payment fees to their clients
  """
  paymentsSurchargeEnable(
    """Parameters for SurchargeEnable"""
    input: SurchargeEnableInput!
  ): SurchargeEnablePayload
  paymentsTermsUpdate(
    """Parameters for PaymentsTermsUpdate"""
    input: PaymentsTermsUpdateInput!
  ): PaymentsTermsUpdatePayload
  practiceBillingCancelSubscription(
    """Parameters for practiceBillingCancelSubscription"""
    input: practiceBillingCancelSubscriptionInput!
  ): practiceBillingCancelSubscriptionPayload
  practiceBillingReportPaymentChallengeError(
    """Parameters for practiceBillingReportPaymentChallengeError"""
    input: practiceBillingReportPaymentChallengeErrorInput!
  ): practiceBillingReportPaymentChallengeErrorPayload
  practiceBillingResolvePaymentChallenge(
    """Parameters for practiceBillingResolvePaymentChallenge"""
    input: practiceBillingResolvePaymentChallengeInput!
  ): practiceBillingResolvePaymentChallengePayload
  practiceBillingSetSubscription(
    """Parameters for practiceBillingSetSubscription"""
    input: practiceBillingSetSubscriptionInput!
  ): practiceBillingSetSubscriptionPayload

  """Confirm practice details upon sign up"""
  practiceConfirmDetails(
    """Parameters for PracticeConfirmDetails"""
    input: PracticeConfirmDetailsInput!
  ): PracticeConfirmDetailsPayload
  practiceSetDefaultNewProposalEmailTemplate(
    """Parameters for PracticeSetDefaultNewProposalEmailTemplate"""
    input: PracticeSetDefaultNewProposalEmailTemplateInput!
  ): PracticeSetDefaultNewProposalEmailTemplatePayload
  practiceSetDefaultTax(
    """Parameters for PracticeSetDefaultTax"""
    input: PracticeSetDefaultTaxInput!
  ): PracticeSetDefaultTaxPayload
  practiceSetDefaultTermsTemplate(
    """Parameters for PracticeSetDefaultTermsTemplate"""
    input: PracticeSetDefaultTermsTemplateInput!
  ): PracticeSetDefaultTermsTemplatePayload

  """Set the practice's intent for signing up with ignition"""
  practiceSetIntent(
    """Parameters for PracticeSetIntent"""
    input: PracticeSetIntentInput!
  ): PracticeSetIntentPayload
  practiceSetPreferredLandingPage(
    """Parameters for PracticeSetPreferredLandingPage"""
    input: PracticeSetPreferredLandingPageInput!
  ): PracticeSetPreferredLandingPagePayload
  practiceSetPreferredProposalEditor(
    """Parameters for PracticeSetPreferredProposalEditor"""
    input: PracticeSetPreferredProposalEditorInput!
  ): PracticeSetPreferredProposalEditorPayload
  proconnectConnect(
    """Parameters for ProconnectConnect"""
    input: ProconnectConnectInput!
  ): ProconnectConnectPayload
  proconnectDisconnect(
    """Parameters for ProconnectDisconnect"""
    input: ProconnectDisconnectInput!
  ): ProconnectDisconnectPayload
  proposalAcceptedBrowserTemplateUpdate(
    """Parameters for ProposalAcceptedBrowserTemplateUpdate"""
    input: ProposalAcceptedBrowserTemplateUpdateInput!
  ): ProposalAcceptedBrowserTemplateUpdatePayload
  proposalAcceptedEmailTemplateUpdate(
    """Parameters for ProposalAcceptedEmailTemplateUpdate"""
    input: ProposalAcceptedEmailTemplateUpdateInput!
  ): ProposalAcceptedEmailTemplateUpdatePayload

  """Add or reset workflows based on the workflow app settings."""
  proposalAddDefaultWorkflow(
    """Parameters for ProposalAddDefaultWorkflow"""
    input: ProposalAddDefaultWorkflowInput!
  ): ProposalAddDefaultWorkflowPayload

  """
  Deprecated. Adds a service group with multiple billing schedules. Use the
  regular 'ProposalAddServiceGroup' mutation instead as it is identical
  """
  proposalAddMultipleBillingServiceGroup(
    """Parameters for ProposalAddMultipleBillingServiceGroup"""
    input: ProposalAddMultipleBillingServiceGroupInput!
  ): ProposalAddMultipleBillingServiceGroupPayload

  """Add a service group with once-off on acceptance billing strategy"""
  proposalAddOnAcceptanceServiceGroup(
    """Parameters for ProposalAddOnAcceptanceServiceGroup"""
    input: ProposalAddOnAcceptanceServiceGroupInput!
  ): ProposalAddOnAcceptanceServiceGroupPayload

  """Add an option to a proposal"""
  proposalAddOption(
    """Parameters for ProposalAddOption"""
    input: ProposalAddOptionInput!
  ): ProposalAddOptionPayload

  """adds a project to a proposal option"""
  proposalAddProject(
    """Parameters for ProposalAddProject"""
    input: ProposalAddProjectInput!
  ): ProposalAddProjectPayload

  """adds a proposed service to a service group"""
  proposalAddProposedService(
    """Parameters for ProposalAddProposedService"""
    input: ProposalAddProposedServiceInput!
  ): ProposalAddProposedServicePayload

  """adds a recipient to proposal"""
  proposalAddRecipient(
    """Parameters for ProposalAddRecipient"""
    input: ProposalAddRecipientInput!
  ): ProposalAddRecipientPayload

  """Add a service group with recurring billing strategy"""
  proposalAddRecurringServiceGroup(
    """Parameters for ProposalAddRecurringServiceGroup"""
    input: ProposalAddRecurringServiceGroupInput!
  ): ProposalAddRecurringServiceGroupPayload

  """Add a service group to a project"""
  proposalAddServiceGroup(
    """Parameters for ProposalAddServiceGroup"""
    input: ProposalAddServiceGroupInput!
  ): ProposalAddServiceGroupPayload @deprecated(reason: "Use proposalAddOnAcceptanceServiceGroup instead")

  """Add a Workflow Strategy to a Proposal."""
  proposalAddWorkflowStrategy(
    """Parameters for proposalAddWorkflowStrategy"""
    input: proposalAddWorkflowStrategyInput!
  ): proposalAddWorkflowStrategyPayload

  """Add a staff to a Workflow Strategy."""
  proposalAddWorkflowStrategyStaff(
    """Parameters for proposalAddWorkflowStrategyStaff"""
    input: proposalAddWorkflowStrategyStaffInput!
  ): proposalAddWorkflowStrategyStaffPayload

  """Add a template to a Workflow Strategy."""
  proposalAddWorkflowStrategyTemplate(
    """Parameters for proposalAddWorkflowStrategyTemplate"""
    input: proposalAddWorkflowStrategyTemplateInput!
  ): proposalAddWorkflowStrategyTemplatePayload

  """archives a proposal"""
  proposalArchive(
    """Parameters for proposalArchive"""
    input: proposalArchiveInput!
  ): proposalArchivePayload

  """Create a draft proposal and set its client if clientId is provided."""
  proposalCreate(
    """Parameters for ProposalCreate"""
    input: ProposalCreateInput!
  ): ProposalCreatePayload

  """Create multiple proposals"""
  proposalCreateBulk(
    """Parameters for ProposalCreateBulk"""
    input: ProposalCreateBulkInput!
  ): ProposalCreateBulkPayload

  """Create a draft proposal with demo client set."""
  proposalCreateWithDemoClient(
    """Parameters for ProposalCreateWithDemoClient"""
    input: ProposalCreateWithDemoClientInput!
  ): ProposalCreateWithDemoClientPayload

  """Create a new proposal with placeholder client set."""
  proposalCreateWithPlaceholderClient(
    """Parameters for ProposalCreateWithPlaceholderClient"""
    input: ProposalCreateWithPlaceholderClientInput!
  ): ProposalCreateWithPlaceholderClientPayload

  """Create a custom template from a proposal"""
  proposalCustomTemplateCreateFromProposal(
    """Parameters for ProposalCustomTemplateCreateFromProposal"""
    input: ProposalCustomTemplateCreateFromProposalInput!
  ): ProposalCustomTemplateCreateFromProposalPayload

  """Delete a custom template"""
  proposalCustomTemplateDelete(
    """Parameters for ProposalCustomTemplateDelete"""
    input: ProposalCustomTemplateDeleteInput!
  ): ProposalCustomTemplateDeletePayload

  """Create a custom template preview proposal"""
  proposalCustomTemplatePreview(
    """Parameters for ProposalCustomTemplatePreview"""
    input: ProposalCustomTemplatePreviewInput!
  ): ProposalCustomTemplatePreviewPayload

  """Replace a custom template with new proposal data"""
  proposalCustomTemplateReplace(
    """Parameters for ProposalCustomTemplateReplace"""
    input: ProposalCustomTemplateReplaceInput!
  ): ProposalCustomTemplateReplacePayload

  """duplicates a proposal"""
  proposalDuplicate(
    """Parameters for proposalDuplicate"""
    input: proposalDuplicateInput!
  ): proposalDuplicatePayload

  """duplicates a proposal option"""
  proposalDuplicateOption(
    """Parameters for proposalOptionDuplicate"""
    input: proposalOptionDuplicateInput!
  ): proposalOptionDuplicatePayload

  """Duplicate project from a proposal"""
  proposalDuplicateProject(
    """Parameters for ProposalDuplicateProject"""
    input: ProposalDuplicateProjectInput!
  ): ProposalDuplicateProjectPayload

  """Duplicate proposed service from a proposal"""
  proposalDuplicateProposedService(
    """Parameters for ProposalDuplicateProposedService"""
    input: ProposalDuplicateProposedServiceInput!
  ): ProposalDuplicateProposedServicePayload

  """Duplicate service group from a proposal"""
  proposalDuplicateServiceGroup(
    """Parameters for ProposalDuplicateServiceGroup"""
    input: ProposalDuplicateServiceGroupInput!
  ): ProposalDuplicateServiceGroupPayload

  """Increase service prices of a proposal."""
  proposalIncreaseServicePrices(
    """Parameters for proposalIncreaseServicePrices"""
    input: proposalIncreaseServicePricesInput!
  ): proposalIncreaseServicePricesPayload

  """marks a proposal as lost"""
  proposalMarkAsLost(
    """Parameters for proposalMarkAsLost"""
    input: proposalMarkAsLostInput!
  ): proposalMarkAsLostPayload

  """Move options within proposal"""
  proposalMoveOption(
    """Parameters for ProposalMoveOption"""
    input: ProposalMoveOptionInput!
  ): ProposalMoveOptionPayload

  """move project within a proposal option"""
  proposalMoveProject(
    """Parameters for ProposalMoveProject"""
    input: ProposalMoveProjectInput!
  ): ProposalMoveProjectPayload

  """move proposed service within and between proposal service groups"""
  proposalMoveProposedService(
    """Parameters for ProposalMoveProposedService"""
    input: ProposalMoveProposedServiceInput!
  ): ProposalMoveProposedServicePayload

  """Move service group within and between proposal projects"""
  proposalMoveServiceGroup(
    """Parameters for ProposalMoveServiceGroup"""
    input: ProposalMoveServiceGroupInput!
  ): ProposalMoveServiceGroupPayload

  """move proposal to awaiting acceptance"""
  proposalMoveToAwaitingAcceptance(
    """Parameters for ProposalMoveToAwaitingAcceptance"""
    input: ProposalMoveToAwaitingAcceptanceInput!
  ): ProposalMoveToAwaitingAcceptancePayload

  """
  Request the lastest amount be fetched for the smart quantity attached to a given proposed service
  """
  proposalRefreshProposedServiceSmartQuantity(
    """Parameters for ProposalRefreshProposedServiceSmartQuantity"""
    input: ProposalRefreshProposedServiceSmartQuantityInput!
  ): ProposalRefreshProposedServiceSmartQuantityPayload

  """remove option from a proposal"""
  proposalRemoveOption(
    """Parameters for ProposalRemoveOption"""
    input: ProposalRemoveOptionInput!
  ): ProposalRemoveOptionPayload

  """remove project from a proposal"""
  proposalRemoveProject(
    """Parameters for ProposalRemoveProject"""
    input: ProposalRemoveProjectInput!
  ): ProposalRemoveProjectPayload

  """remove proposed service from a proposal"""
  proposalRemoveProposedService(
    """Parameters for ProposalRemoveProposedService"""
    input: ProposalRemoveProposedServiceInput!
  ): ProposalRemoveProposedServicePayload

  """removes a recipient on proposal"""
  proposalRemoveRecipient(
    """Parameters for ProposalRemoveRecipient"""
    input: ProposalRemoveRecipientInput!
  ): ProposalRemoveRecipientPayload

  """Remove service group from a proposal"""
  proposalRemoveServiceGroup(
    """Parameters for ProposalRemoveServiceGroup"""
    input: ProposalRemoveServiceGroupInput!
  ): ProposalRemoveServiceGroupPayload

  """Remove a Workflow Strategy from a Proposal."""
  proposalRemoveWorkflowStrategy(
    """Parameters for proposalRemoveWorkflowStrategy"""
    input: proposalRemoveWorkflowStrategyInput!
  ): proposalRemoveWorkflowStrategyPayload

  """Remove a staff from a Workflow Strategy."""
  proposalRemoveWorkflowStrategyStaff(
    """Parameters for proposalRemoveWorkflowStrategyStaff"""
    input: proposalRemoveWorkflowStrategyStaffInput!
  ): proposalRemoveWorkflowStrategyStaffPayload

  """Remove a template from a Workflow Strategy."""
  proposalRemoveWorkflowStrategyTemplate(
    """Parameters for proposalRemoveWorkflowStrategyTemplate"""
    input: proposalRemoveWorkflowStrategyTemplateInput!
  ): proposalRemoveWorkflowStrategyTemplatePayload

  """Renews a proposal"""
  proposalRenew(
    """Parameters for proposalRenew"""
    input: proposalRenewInput!
  ): proposalRenewPayload

  """Renew multiple proposals"""
  proposalRenewBulk(
    """Parameters for proposalRenewBulk"""
    input: proposalRenewBulkInput!
  ): proposalRenewBulkPayload

  """
  Reset an option to the default state.
  This will remove any customisation made to the option.
  
  """
  proposalResetOption(
    """Parameters for ProposalResetOption"""
    input: ProposalResetOptionInput!
  ): ProposalResetOptionPayload

  """
  Reset a project to the default state.
  This will remove any services added or customisation made to the project.
  
  """
  proposalResetProject(
    """Parameters for ProposalResetProject"""
    input: ProposalResetProjectInput!
  ): ProposalResetProjectPayload

  """Approve an proposal."""
  proposalReviewApprove(
    """Parameters for ProposalReviewApprove"""
    input: ProposalReviewApproveInput!
  ): ProposalReviewApprovePayload

  """Request a change or changes to a proposal."""
  proposalReviewRequestChange(
    """Parameters for ProposalReviewRequestChange"""
    input: ProposalReviewRequestChangeInput!
  ): ProposalReviewRequestChangePayload

  """Request a Review of a proposal."""
  proposalReviewRequestReview(
    """Parameters for ProposalReviewRequestReview"""
    input: ProposalReviewRequestReviewInput!
  ): ProposalReviewRequestReviewPayload

  """revoke a proposal"""
  proposalRevoke(
    """Parameters for proposalRevoke"""
    input: proposalRevokeInput!
  ): proposalRevokePayload

  """saves a proposal for later"""
  proposalSave(
    """Parameters for ProposalSave"""
    input: ProposalSaveInput!
  ): ProposalSavePayload

  """Send a demo proposal to a specific email address"""
  proposalSendDemo(
    """Parameters for SendDemoProposal"""
    input: SendDemoProposalInput!
  ): SendDemoProposalPayload

  """send a test proposal to a specific email address"""
  proposalSendTestProposal(
    """Parameters for SendTestProposal"""
    input: SendTestProposalInput!
  ): SendTestProposalPayload

  """send proposal to client"""
  proposalSendToClient(
    """Parameters for ProposalSendToClient"""
    input: ProposalSendToClientInput!
  ): ProposalSendToClientPayload

  """Send multiple proposals to their respective clients"""
  proposalSendToClientBulk(
    """Parameters for proposalSendToClientBulk"""
    input: proposalSendToClientBulkInput!
  ): proposalSendToClientBulkPayload

  """send proposal to signatory"""
  proposalSendToSignatory(
    """Parameters for ProposalSendToSignatory"""
    input: ProposalSendToSignatoryInput!
  ): ProposalSendToSignatoryPayload

  """Change the way services from this proposal are grouped for billing."""
  proposalSetBillingGroupedBy(
    """Parameters for ProposalSetBillingGroupedBy"""
    input: ProposalSetBillingGroupedByInput!
  ): ProposalSetBillingGroupedByPayload

  """Set proposal's brochure"""
  proposalSetBrochure(
    """Parameters for ProposalSetBrochure"""
    input: ProposalSetBrochureInput!
  ): ProposalSetBrochurePayload

  """Set proposal's client"""
  proposalSetClient(
    """Parameters for ProposalSetClient"""
    input: ProposalSetClientInput!
  ): ProposalSetClientPayload

  """set the email template of a proposal"""
  proposalSetEmailTemplate(
    """Parameters for ProposalSetEmailTemplate"""
    input: ProposalSetEmailTemplateInput!
  ): ProposalSetEmailTemplatePayload

  """set the minimum length of the proposed contract"""
  proposalSetMinimumContractLength(
    """Parameters for ProposalSetMinimumContractLength"""
    input: ProposalSetMinimumContractLengthInput!
  ): ProposalSetMinimumContractLengthPayload

  """Set proposal's name"""
  proposalSetName(
    """Parameters for ProposalSetName"""
    input: ProposalSetNameInput!
  ): ProposalSetNamePayload

  """Set the next steps message for a proposal"""
  proposalSetNextStepsMessage(
    """Parameters for ProposalSetNextStepsMessage"""
    input: ProposalSetNextStepsMessageInput!
  ): ProposalSetNextStepsMessagePayload

  """set display of one time date on proposal"""
  proposalSetOneTimeDateDisplay(
    """Parameters for ProposalSetOneTimeDateDisplay"""
    input: ProposalSetOneTimeDateDisplayInput!
  ): ProposalSetOneTimeDateDisplayPayload

  """Set proposal option's description"""
  proposalSetOptionDescription(
    """Parameters for ProposalOptionSetDescription"""
    input: ProposalOptionSetDescriptionInput!
  ): ProposalOptionSetDescriptionPayload

  """Set proposal option's name"""
  proposalSetOptionName(
    """Parameters for ProposalOptionSetName"""
    input: ProposalOptionSetNameInput!
  ): ProposalOptionSetNamePayload

  """Set proposal's payment settings"""
  proposalSetPaymentSettings(
    """Parameters for ProposalSetPaymentSettings"""
    input: ProposalSetPaymentSettingsInput!
  ): ProposalSetPaymentSettingsPayload

  """set the personalised message for a proposal"""
  proposalSetPersonalisedMessage(
    """Parameters for ProposalSetPersonalisedMessage"""
    input: ProposalSetPersonalisedMessageInput!
  ): ProposalSetPersonalisedMessagePayload

  """Set post acceptance video url"""
  proposalSetPostAcceptanceVideo(
    """Parameters for ProposalSetPostAcceptanceVideo"""
    input: ProposalSetPostAcceptanceVideoInput!
  ): ProposalSetPostAcceptanceVideoPayload

  """set current practice as sender of a proposal"""
  proposalSetPracticeAsSender(
    """Parameters for ProposalSetPracticeAsSender"""
    input: ProposalSetPracticeAsSenderInput!
  ): ProposalSetPracticeAsSenderPayload

  """Set pre acceptance video url"""
  proposalSetPreAcceptanceVideo(
    """Parameters for ProposalSetPreAcceptanceVideo"""
    input: ProposalSetPreAcceptanceVideoInput!
  ): ProposalSetPreAcceptanceVideoPayload

  """set the description of a proposed project"""
  proposalSetProjectDescription(
    """Parameters for ProposalSetProjectDescription"""
    input: ProposalSetProjectDescriptionInput!
  ): ProposalSetProjectDescriptionPayload

  """set the graphql_name of a proposed project"""
  proposalSetProjectName(
    """Parameters for ProposalSetProjectName"""
    input: ProposalSetProjectNameInput!
  ): ProposalSetProjectNamePayload

  """set display of a proposal's value"""
  proposalSetProposalValueDisplay(
    """Parameters for ProposalSetProposalValueDisplay"""
    input: ProposalSetProposalValueDisplayInput!
  ): ProposalSetProposalValueDisplayPayload

  """set account for proposed service"""
  proposalSetProposedServiceAccount(
    """Parameters for ProposalSetProposedServiceAccount"""
    input: ProposalSetProposedServiceAccountInput!
  ): ProposalSetProposedServiceAccountPayload

  """set the description of a proposed service"""
  proposalSetProposedServiceDescription(
    """Parameters for ProposalSetProposedServiceDescription"""
    input: ProposalSetProposedServiceDescriptionInput!
  ): ProposalSetProposedServiceDescriptionPayload

  """set fixed price for a proposed service"""
  proposalSetProposedServiceFixedPrice(
    """Parameters for ProposalSetProposedServiceFixedPrice"""
    input: ProposalSetProposedServiceFixedPriceInput!
  ): ProposalSetProposedServiceFixedPricePayload

  """set included price for a proposed service"""
  proposalSetProposedServiceIncludedPrice(
    """Parameters for ProposalSetProposedServiceIncludedPrice"""
    input: ProposalSetProposedServiceIncludedPriceInput!
  ): ProposalSetProposedServiceIncludedPricePayload

  """set the minimum for a proposed service"""
  proposalSetProposedServiceMinimumPrice(
    """Parameters for ProposalSetProposedServiceMinimumPrice"""
    input: ProposalSetProposedServiceMinimumPriceInput!
  ): ProposalSetProposedServiceMinimumPricePayload

  """set invoice strategy of a proposed service portion"""
  proposalSetProposedServicePortionInvoiceStrategy(
    """Parameters for ProposalSetProposedServicePortionInvoiceStrategy"""
    input: ProposalSetProposedServicePortionInvoiceStrategyInput!
  ): ProposalSetProposedServicePortionInvoiceStrategyPayload

  """set price of a proposed service portion"""
  proposalSetProposedServicePortionPrice(
    """Parameters for ProposalSetProposedServicePortionPrice"""
    input: ProposalSetProposedServicePortionPriceInput!
  ): ProposalSetProposedServicePortionPricePayload

  """sets the price range for a proposed service"""
  proposalSetProposedServicePriceRange(
    """Parameters for ProposalSetProposedServicePriceRange"""
    input: ProposalSetProposedServicePriceRangeInput!
  ): ProposalSetProposedServicePriceRangePayload

  """set quantity rule for a proposed service"""
  proposalSetProposedServiceQuantityRule(
    """Parameters for ProposalSetProposedServiceQuantityRule"""
    input: ProposalSetProposedServiceQuantityRuleInput!
  ): ProposalSetProposedServiceQuantityRulePayload

  """set the tax type of a proposed service"""
  proposalSetProposedServiceTax(
    """Parameters for ProposalSetProposedServiceTax"""
    input: ProposalSetProposedServiceTaxInput!
  ): ProposalSetProposedServiceTaxPayload

  """
  Set the tax exempt flag of a proposed service.  Only used for proposals which are using proposal level taxes.
  """
  proposalSetProposedServiceTaxExempt(
    """Parameters for ProposalSetProposedServiceTaxExempt"""
    input: ProposalSetProposedServiceTaxExemptInput!
  ): ProposalSetProposedServiceTaxExemptPayload

  """set unit price for a proposed service"""
  proposalSetProposedServiceUnitPrice(
    """Parameters for ProposalSetProposedServiceUnitPrice"""
    input: ProposalSetProposedServiceUnitPriceInput!
  ): ProposalSetProposedServiceUnitPricePayload

  """Set proposal's recommended option"""
  proposalSetRecommendedOption(
    """Parameters for ProposalSetRecommendedOption"""
    input: ProposalSetRecommendedOptionInput!
  ): ProposalSetRecommendedOptionPayload

  """set one or more billing schedules on a service group"""
  proposalSetServiceGroupBillingSchedules(
    """Parameters for ProposalSetServiceGroupBillingSchedules"""
    input: ProposalSetServiceGroupBillingSchedulesInput!
  ): ProposalSetServiceGroupBillingSchedulesPayload

  """set display of detailed service prices on proposal"""
  proposalSetServicePriceDisplay(
    """Parameters for ProposalSetServicePriceDisplay"""
    input: ProposalSetServicePriceDisplayInput!
  ): ProposalSetServicePriceDisplayPayload

  """sets the signatories for a proposal"""
  proposalSetSignatories(
    """Parameters for ProposalSetSignatories"""
    input: ProposalSetSignatoriesInput!
  ): ProposalSetSignatoriesPayload

  """
  Set proposal's tax.  This is only used for proposals that are using proposal
  level taxes.  If using service level taxes, ProposalSetProposedServiceTax
  should be used instead.
  """
  proposalSetTax(
    """Parameters for ProposalSetTax"""
    input: ProposalSetTaxInput!
  ): ProposalSetTaxPayload

  """set the terms template of a proposal"""
  proposalSetTermsTemplate(
    """Parameters for ProposalSetTermsTemplate"""
    input: ProposalSetTermsTemplateInput!
  ): ProposalSetTermsTemplatePayload

  """set an user as sender of a proposal"""
  proposalSetUserAsSender(
    """Parameters for ProposalSetUserAsSender"""
    input: ProposalSetUserAsSenderInput!
  ): ProposalSetUserAsSenderPayload

  """Update the budget on a Workflow Strategy."""
  proposalSetWorkflowStrategyBudget(
    """Parameters for proposalSetWorkflowStrategyBudget"""
    input: proposalSetWorkflowStrategyBudgetInput!
  ): proposalSetWorkflowStrategyBudgetPayload

  """Update the categories on a Workflow Strategy."""
  proposalSetWorkflowStrategyCategories(
    """Parameters for proposalSetWorkflowStrategyCategories"""
    input: proposalSetWorkflowStrategyCategoriesInput!
  ): proposalSetWorkflowStrategyCategoriesPayload

  """Update the description on a Workflow Strategy."""
  proposalSetWorkflowStrategyDescription(
    """Parameters for proposalSetWorkflowStrategyDescription"""
    input: proposalSetWorkflowStrategyDescriptionInput!
  ): proposalSetWorkflowStrategyDescriptionPayload

  """Update the duration on a Workflow Strategy."""
  proposalSetWorkflowStrategyDuration(
    """Parameters for proposalSetWorkflowStrategyDuration"""
    input: proposalSetWorkflowStrategyDurationInput!
  ): proposalSetWorkflowStrategyDurationPayload

  """Update the manager on a Workflow Strategy."""
  proposalSetWorkflowStrategyManager(
    """Parameters for proposalSetWorkflowStrategyManager"""
    input: proposalSetWorkflowStrategyManagerInput!
  ): proposalSetWorkflowStrategyManagerPayload

  """Update the name on a Workflow Strategy."""
  proposalSetWorkflowStrategyName(
    """Parameters for proposalSetWorkflowStrategyName"""
    input: proposalSetWorkflowStrategyNameInput!
  ): proposalSetWorkflowStrategyNamePayload

  """Update the partner on a Workflow Strategy."""
  proposalSetWorkflowStrategyPartner(
    """Parameters for proposalSetWorkflowStrategyPartner"""
    input: proposalSetWorkflowStrategyPartnerInput!
  ): proposalSetWorkflowStrategyPartnerPayload

  """Set the Workflow Strategy schedule to non-recurring."""
  proposalSetWorkflowStrategyRecurrenceOnce(
    """Parameters for proposalSetWorkflowStrategyRecurrenceOnce"""
    input: proposalSetWorkflowStrategyRecurrenceOnceInput!
  ): proposalSetWorkflowStrategyRecurrenceOncePayload

  """Set the Workflow Strategy schedule to recurring."""
  proposalSetWorkflowStrategyRecurring(
    """Parameters for proposalSetWorkflowStrategyRecurring"""
    input: proposalSetWorkflowStrategyRecurringInput!
  ): proposalSetWorkflowStrategyRecurringPayload

  """Set the Workflow Strategy schedule start date."""
  proposalSetWorkflowStrategyStartOnDate(
    """Parameters for proposalSetWorkflowStrategyStartOnDate"""
    input: proposalSetWorkflowStrategyStartOnDateInput!
  ): proposalSetWorkflowStrategyStartOnDatePayload

  """Update the templates on a Workflow Strategy."""
  proposalSetWorkflowStrategyTemplates(
    """Parameters for proposalSetWorkflowStrategyTemplates"""
    input: proposalSetWorkflowStrategyTemplatesInput!
  ): proposalSetWorkflowStrategyTemplatesPayload

  """sign on behalf of all unsigned signatories"""
  proposalSignOnBehalfForAll(
    """Parameters for proposalSignOnBehalfForAll"""
    input: proposalSignOnBehalfForAllInput!
  ): proposalSignOnBehalfForAllPayload

  """set proposal to start on acceptance"""
  proposalStartOnAcceptance(
    """Parameters for ProposalStartOnAcceptance"""
    input: ProposalStartOnAcceptanceInput!
  ): ProposalStartOnAcceptancePayload

  """set the date the proposed contract starts on"""
  proposalStartOnDate(
    """Parameters for ProposalStartOnDate"""
    input: ProposalStartOnDateInput!
  ): ProposalStartOnDatePayload

  """Create a proposal from a template"""
  proposalTemplateUse(
    """Parameters for ProposalTemplateUse"""
    input: ProposalTemplateUseInput!
  ): ProposalTemplateUsePayload

  """Unset proposal's brochure"""
  proposalUnsetBrochure(
    """Parameters for ProposalUnsetBrochure"""
    input: ProposalUnsetBrochureInput!
  ): ProposalUnsetBrochurePayload

  """Unset proposal's recommended option"""
  proposalUnsetRecommendedOption(
    """Parameters for ProposalUnsetRecommendedOption"""
    input: ProposalUnsetRecommendedOptionInput!
  ): ProposalUnsetRecommendedOptionPayload

  """Remove a manager from a Workflow Strategy."""
  proposalUnsetWorkflowStrategyManager(
    """Parameters for proposalUnsetWorkflowStrategyManager"""
    input: proposalUnsetWorkflowStrategyManagerInput!
  ): proposalUnsetWorkflowStrategyManagerPayload

  """Remove a partner from a Workflow Strategy."""
  proposalUnsetWorkflowStrategyPartner(
    """Parameters for proposalUnsetWorkflowStrategyPartner"""
    input: proposalUnsetWorkflowStrategyPartnerInput!
  ): proposalUnsetWorkflowStrategyPartnerPayload

  """Update proposed service from a service in a proposal."""
  proposalUpdateProposedService(
    """Parameters for ProposalUpdateProposedService"""
    input: ProposalUpdateProposedServiceInput!
  ): ProposalUpdateProposedServicePayload

  """Sets the deploy strategy for all workflows for the specified app."""
  proposalWorkflowSettingsSetDeployStrategy(
    """Parameters for proposalWorkflowSettingsSetDeployStrategy"""
    input: proposalWorkflowSettingsSetDeployStrategyInput!
  ): proposalWorkflowSettingsSetDeployStrategyPayload

  """
  Set the workflow strategy to receive billing credits from the client billing group.
  """
  proposalWorkflowStrategySetClientBillingGroup(
    """Parameters for proposalWorkflowStrategySetClientBillingGroup"""
    input: proposalWorkflowStrategySetClientBillingGroupInput!
  ): proposalWorkflowStrategySetClientBillingGroupPayload

  """
  Set the workflow strategy to receive billing credits from a Project billing group.
  """
  proposalWorkflowStrategySetProjectBillingGroup(
    """Parameters for proposalWorkflowStrategySetProjectBillingGroup"""
    input: proposalWorkflowStrategySetProjectBillingGroupInput!
  ): proposalWorkflowStrategySetProjectBillingGroupPayload

  """
  Set the workflow strategy to receive billing credits from the Proposal billing group.
  """
  proposalWorkflowStrategySetProposalBillingGroup(
    """Parameters for proposalWorkflowStrategySetProposalBillingGroup"""
    input: proposalWorkflowStrategySetProposalBillingGroupInput!
  ): proposalWorkflowStrategySetProposalBillingGroupPayload

  """Set the Workflow Strategy schedule to start on proposal acceptance."""
  proposalWorkflowStrategyStartOnAcceptance(
    """Parameters for proposalWorkflowStrategyStartOnAcceptance"""
    input: proposalWorkflowStrategyStartOnAcceptanceInput!
  ): proposalWorkflowStrategyStartOnAcceptancePayload

  """Set the Workflow Strategy schedule to start on proposal start date."""
  proposalWorkflowStrategyStartOnProposalStart(
    """Parameters for proposalWorkflowStrategyStartOnProposalStart"""
    input: proposalWorkflowStrategyStartOnProposalStartInput!
  ): proposalWorkflowStrategyStartOnProposalStartPayload

  """Unset the billing group on a Workflow Strategy."""
  proposalWorkflowStrategyUnsetBillingGroup(
    """Parameters for proposalWorkflowStrategyUnsetBillingGroup"""
    input: proposalWorkflowStrategyUnsetBillingGroupInput!
  ): proposalWorkflowStrategyUnsetBillingGroupPayload

  """
  Creates a Background Job for emailing proposal CSVs to the current user
  """
  proposalsExport(
    """Parameters for proposalsExport"""
    input: proposalsExportInput!
  ): proposalsExportPayload
  quickbooksDisconnect(
    """Parameters for QuickbooksDisconnect"""
    input: QuickbooksDisconnectInput!
  ): QuickbooksDisconnectPayload
  quickbooksEnable(
    """Parameters for QuickbooksEnable"""
    input: QuickbooksEnableInput!
  ): QuickbooksEnablePayload

  """Create proposals from recurring transactions"""
  quickbooksProposalsBulkCreateFromRecurringTransactions(
    """Parameters for ProposalsBulkCreateFromRecurringTransactions"""
    input: ProposalsBulkCreateFromRecurringTransactionsInput!
  ): ProposalsBulkCreateFromRecurringTransactionsPayload
  quickbooksSettingsUpdate(
    """Parameters for QuickbooksSettingsUpdate"""
    input: QuickbooksSettingsUpdateInput!
  ): QuickbooksSettingsUpdatePayload
  quickbooksTaxCodeMappingCreate(
    """Parameters for QuickbooksTaxCodeMappingCreate"""
    input: QuickbooksTaxCodeMappingCreateInput!
  ): QuickbooksTaxCodeMappingCreatePayload
  quickbooksTaxCodeMappingsUpdate(
    """Parameters for QuickbooksTaxCodeMappingsUpdate"""
    input: QuickbooksTaxCodeMappingsUpdateInput!
  ): QuickbooksTaxCodeMappingsUpdatePayload

  """
  Triggers a future CSV export with the given filters and returns immediately
  """
  searchExportCsv(
    """Parameters for SearchExportCsv"""
    input: SearchExportCsvInput!
  ): SearchExportCsvPayload

  """Add Mapping between a Service and Workflow Templates"""
  serviceAddWorkflowTemplateMappings(
    """Parameters for ServiceAddWorkflowTemplateMappings"""
    input: ServiceAddWorkflowTemplateMappingsInput!
  ): ServiceAddWorkflowTemplateMappingsPayload

  """Create a service in service library"""
  serviceCreate(
    """Parameters for ServiceCreate"""
    input: ServiceCreateInput!
  ): ServiceCreatePayload

  """Archives the services"""
  serviceDelete(
    """Parameters for ServiceDelete"""
    input: ServiceDeleteInput!
  ): ServiceDeletePayload

  """Remove Mapping between a Service and Workflow Templates"""
  serviceDeleteWorkflowTemplateMappings(
    """Parameters for ServiceDeleteWorkflowTemplateMappings"""
    input: ServiceDeleteWorkflowTemplateMappingsInput!
  ): ServiceDeleteWorkflowTemplateMappingsPayload
  serviceGroupCreate(
    """Parameters for ServiceGroupCreate"""
    input: ServiceGroupCreateInput!
  ): ServiceGroupCreatePayload

  """Import services"""
  serviceImport(
    """Parameters for ServiceImport"""
    input: ServiceImportInput!
  ): ServiceImportPayload
  serviceRevenueExport(
    """Parameters for ServiceRevenueExport"""
    input: ServiceRevenueExportInput!
  ): ServiceRevenueExportPayload

  """Set Mapping between a Service and Workflow Templates"""
  serviceSetWorkflowTemplateMappings(
    """Parameters for ServiceSetWorkflowTemplateMappings"""
    input: ServiceSetWorkflowTemplateMappingsInput!
  ): ServiceSetWorkflowTemplateMappingsPayload

  """Generate token for service"""
  serviceTokenGenerate(
    """Parameters for ServiceTokenGenerate"""
    input: ServiceTokenGenerateInput!
  ): ServiceTokenGeneratePayload

  """revoke token for service"""
  serviceTokenRevoke(
    """Parameters for ServiceTokenRevoke"""
    input: ServiceTokenRevokeInput!
  ): ServiceTokenRevokePayload

  """Update a service in service library"""
  serviceUpdate(
    """Parameters for ServiceUpdate"""
    input: ServiceUpdateInput!
  ): ServiceUpdatePayload
  taxCreate(
    """Parameters for TaxCreate"""
    input: TaxCreateInput!
  ): TaxCreatePayload

  """
  Maps a list of Taxes to AppTaxes, creating a link which can be used by the integration that the AppTax comes from.
  """
  taxSetAppMappings(
    """Parameters for TaxSetAppMappings"""
    input: TaxSetAppMappingsInput!
  ): TaxSetAppMappingsPayload
  termsTemplateCreate(
    """Parameters for TermsTemplateCreate"""
    input: TermsTemplateCreateInput!
  ): TermsTemplateCreatePayload
  termsTemplateDelete(
    """Parameters for TermsTemplateDelete"""
    input: TermsTemplateDeleteInput!
  ): TermsTemplateDeletePayload
  termsTemplateUpdate(
    """Parameters for TermsTemplateUpdate"""
    input: TermsTemplateUpdateInput!
  ): TermsTemplateUpdatePayload
  userCreate(
    """Parameters for UserCreate"""
    input: UserCreateInput!
  ): UserCreatePayload
  userDelete(
    """Parameters for UserDelete"""
    input: UserDeleteInput!
  ): UserDeletePayload
  userInvite(
    """Parameters for UserInvite"""
    input: UserInviteInput!
  ): UserInvitePayload
  userInviteAll(
    """Parameters for UserInviteAll"""
    input: UserInviteAllInput!
  ): UserInviteAllPayload

  """Sign out current user and clear out current session's user tokens"""
  userLogout(
    """Parameters for UserLogout"""
    input: UserLogoutInput!
  ): UserLogoutPayload

  """
  Update user's password in app. It requires user token app scope to execute the mutation.
  """
  userPasswordUpdate(
    """Parameters for UserPasswordUpdate"""
    input: UserPasswordUpdateInput!
  ): UserPasswordUpdatePayload

  """
  Register a referral URL that the user can share with others to participate in the referrals scheme
  """
  userRegisterReferralUrl(
    """Parameters for UserRegisterReferralUrl"""
    input: UserRegisterReferralUrlInput!
  ): UserRegisterReferralUrlPayload

  """The practice principal can reset a users TFA_ENABLED to false"""
  userResetTwoFactorAuth(
    """Parameters for UserResetTwoFactorAuth"""
    input: UserResetTwoFactorAuthInput!
  ): UserResetTwoFactorAuthPayload

  """
  Send an email with a user's referral URL to participate in the referrals scheme
  """
  userSendReferralInviteEmail(
    """Parameters for UserSendReferralInviteEmail"""
    input: UserSendReferralInviteEmailInput!
  ): UserSendReferralInviteEmailPayload

  """Send a the tfa code to the current users mobile"""
  userSendTwoFactorAuthSmsCode(
    """Parameters for UserSendTwoFactorAuthSmsCode"""
    input: UserSendTwoFactorAuthSmsCodeInput!
  ): UserSendTwoFactorAuthSmsCodePayload

  """
  Maps a User to an AppUser, creating a link which can be used by the integration that the AppUser comes from
  """
  userSetAppMapping(
    """Parameters for UserSetAppMapping"""
    input: UserSetAppMappingInput!
  ): UserSetAppMappingPayload
  userUpdate(
    """Parameters for UserUpdate"""
    input: UserUpdateInput!
  ): UserUpdatePayload
  userUpdateWeeklySummaryEmail(
    """Parameters for UserUpdateWeeklySummaryEmail"""
    input: UserUpdateWeeklySummaryEmailInput!
  ): UserUpdateWeeklySummaryEmailPayload

  """Uploads a user avatar."""
  userUploadAvatar(
    """Parameters for UploadAvatar"""
    input: UploadAvatarInput!
  ): UploadAvatarPayload

  """Create proposals from repeating invoices"""
  xeroProposalsBulkCreateFromRepeatingInvoices(
    """Parameters for ProposalsBulkCreateFromRepeatingInvoices"""
    input: ProposalsBulkCreateFromRepeatingInvoicesInput!
  ): ProposalsBulkCreateFromRepeatingInvoicesPayload
  xeroTaxRateMappingCreate(
    """Parameters for XeroTaxRateMappingCreate"""
    input: XeroTaxRateMappingCreateInput!
  ): XeroTaxRateMappingCreatePayload
  xeroTaxRateMappingsUpdate(
    """Parameters for XeroTaxRateMappingsUpdate"""
    input: XeroTaxRateMappingsUpdateInput!
  ): XeroTaxRateMappingsUpdatePayload
}

type NewGroupProposalEmailTemplate implements EmailTemplateInterface & PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  slug: ID!
  subject: String!
  updatedAt: DateTime!
}

"""Autogenerated input type of NewGroupProposalEmailTemplateUpdate"""
input NewGroupProposalEmailTemplateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of new group proposal email template"""
  id: ID!
  template: EmailTemplateInput!
}

"""Autogenerated return type of NewGroupProposalEmailTemplateUpdate."""
type NewGroupProposalEmailTemplateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: NewGroupProposalEmailTemplate
  templates: Templates
}

type NewProposalEmailTemplate implements EmailTemplateInterface & PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  isDefault: Boolean!
  name: String!
  slug: ID!
  subject: String!
  updatedAt: DateTime!
}

"""Autogenerated input type of NewProposalEmailTemplateArchive"""
input NewProposalEmailTemplateArchiveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of new proposal email template"""
  id: ID!
}

"""Autogenerated return type of NewProposalEmailTemplateArchive."""
type NewProposalEmailTemplateArchivePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  templates: Templates
}

"""The connection type for NewProposalEmailTemplate."""
type NewProposalEmailTemplateConnection {
  """A list of edges."""
  edges: [NewProposalEmailTemplateEdge!]!

  """A list of nodes."""
  nodes: [NewProposalEmailTemplate!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of NewProposalEmailTemplateCreate"""
input NewProposalEmailTemplateCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: EmailTemplateInput!
}

"""Autogenerated return type of NewProposalEmailTemplateCreate."""
type NewProposalEmailTemplateCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: NewProposalEmailTemplate
  templates: Templates
}

"""An edge in a connection."""
type NewProposalEmailTemplateEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: NewProposalEmailTemplate!
}

"""Autogenerated input type of NewProposalEmailTemplateUpdate"""
input NewProposalEmailTemplateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of new proposal email template"""
  id: ID!
  template: EmailTemplateInput!
}

"""Autogenerated return type of NewProposalEmailTemplateUpdate."""
type NewProposalEmailTemplateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: NewProposalEmailTemplate
  templates: Templates
}

type NewSubmissionEmailTemplate implements EmailTemplateInterface & PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  slug: ID!
  subject: String!
  updatedAt: DateTime!
}

"""Autogenerated input type of NewSubmissionEmailTemplateUpdate"""
input NewSubmissionEmailTemplateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of new submission email template"""
  id: ID!
  template: EmailTemplateInput!
}

"""Autogenerated return type of NewSubmissionEmailTemplateUpdate."""
type NewSubmissionEmailTemplateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: NewSubmissionEmailTemplate
  templates: Templates
}

type NextStepsMessageTemplate implements PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  isDefault: Boolean!
  name: String!
  slug: ID!
  updatedAt: DateTime!
}

"""The connection type for NextStepsMessageTemplate."""
type NextStepsMessageTemplateConnection {
  """A list of edges."""
  edges: [NextStepsMessageTemplateEdge!]!

  """A list of nodes."""
  nodes: [NextStepsMessageTemplate!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of NextStepsMessageTemplateCreate"""
input NextStepsMessageTemplateCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: TemplateInput!
}

"""Autogenerated return type of NextStepsMessageTemplateCreate."""
type NextStepsMessageTemplateCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: NextStepsMessageTemplate
  templates: Templates
}

"""Autogenerated input type of NextStepsMessageTemplateDelete"""
input NextStepsMessageTemplateDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug or UUID of next steps message template"""
  id: ID!
}

"""Autogenerated return type of NextStepsMessageTemplateDelete."""
type NextStepsMessageTemplateDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  templates: Templates
}

"""An edge in a connection."""
type NextStepsMessageTemplateEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: NextStepsMessageTemplate!
}

"""Autogenerated input type of NextStepsMessageTemplateSetDefault"""
input NextStepsMessageTemplateSetDefaultInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of next steps message template"""
  id: ID!
}

"""Autogenerated return type of NextStepsMessageTemplateSetDefault."""
type NextStepsMessageTemplateSetDefaultPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
  templates: Templates
}

"""Autogenerated input type of NextStepsMessageTemplateUpdate"""
input NextStepsMessageTemplateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug or UUID of next steps message template"""
  id: ID!
  template: TemplateInput!
}

"""Autogenerated return type of NextStepsMessageTemplateUpdate."""
type NextStepsMessageTemplateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: NextStepsMessageTemplate
  templates: Templates
}

type Notification {
  state: String!
}

"""An edge in a connection."""
type NotificationEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Notification!
}

input NotificationInput {
  emailAddresses: [EmailAddress!]!
  subject: String!
  message: String
}

type Notifications {
  """
  Sample of email sent to secondary signatories announcing that they will soon be asked for their signature
  """
  announcementToSecondarySignatoryEmail: NotificationSample! @deprecated(reason: "use announcementToSecondarySignatoryEmailPreview and the EmailPreviewType instead of NotificationSampleType")

  """
  Sample of email sent to secondary signatories announcing that they will soon be asked for their signature
  """
  announcementToSecondarySignatoryEmailPreview: EmailPreview!

  """Sample of email sent to signatories when their signature is needed"""
  awaitingSignatureToSignatoryEmail: NotificationSample! @deprecated(reason: "use awaitingSignatureToSignatoryEmailPreview and the EmailPreviewType instead of NotificationSampleType")

  """Sample of email sent to signatories when their signature is needed"""
  awaitingSignatureToSignatoryEmailPreview: EmailPreview!
}

type NotificationSample {
  """Sample notification body"""
  body: String!

  """Sample notification subject"""
  subject: String!
}

"""The connection type for Notification."""
type NotificationsConnectionType {
  """A list of edges."""
  edges: [NotificationEdge!]!
  latest: Int

  """A list of nodes."""
  nodes: [Notification!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  unread: Int!
}

type OembedVideo {
  html: String!
  providerName: String!
  thumbnailUrl: URL
  title: String
}

type Option {
  """Description as shown to the user"""
  description: String!

  """Option value name"""
  value: String!
}

enum OrderBy {
  """Sort by lowest values first."""
  ASCENDING

  """Sort by highest values first."""
  DESCENDING
}

type Origin {
  id: ID!
  sources: [OriginSource!]!
}

type OriginSource {
  id: ID!
  name: String!
  reference: String!
  referenceNumber: String
  type: OriginSourceTypeEnum!
}

enum OriginSourceTypeEnum {
  ENGAGEMENT
  PROJECT
  PROPOSAL
  CLIENT
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

input PaginationInput {
  """Number of results rows to return"""
  pageSize: Int!

  """1-based results page number to return"""
  pageNumber: Int!
}

type Payment {
  activities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    orderBy: ActivityLogOrder = {createdAt: ASCENDING}
  ): ActivityLogConnection
  amount: Money!
  availableOn: Date
  canCancel: Boolean!
  canCollect: Boolean!
  canRetry: Boolean!
  client: Client!
  collections(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): CollectionConnection
  createdAt: DateTime!

  """
  Fee associated with the payment collection, null implying the payment fee has not yet been generated
  """
  fee: PaymentsFee
  feeAmount: Money! @deprecated(reason: "Use fee.amount instead")
  id: ID!
  invoice: ClientBillingInvoice!

  """
  Flag to indicate if the payment is allowed for refund.
  Only payments in collected, disbursed or disbursing state are allowed for requesting a refund.
  
  """
  isRefundable: Boolean!
  paymentMethod: PaymentMethod!
  reference: String!
  scheduleCollectionPortalUrl: String!
  scheduledCollectionTime: DateTime
  state: PaymentsPaymentStateEnum!

  """Surcharge added to the payment"""
  surchargeAmount: Money
  updatedAt: DateTime!
}

"""Autogenerated input type of PaymentCancel"""
input PaymentCancelInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of payment"""
  paymentId: ID!
}

"""Autogenerated return type of PaymentCancel."""
type PaymentCancelPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  payment: Payment!
}

"""Autogenerated return type of paymentCollected."""
type paymentCollectedPayload {
  """True if this is the first collected payment for the practice"""
  isFirstPayment: Boolean!

  """The collected payment"""
  payment: Payment!
}

"""The connection type for Payment."""
type PaymentConnection {
  """A list of edges."""
  edges: [PaymentEdge!]!

  """A list of nodes."""
  nodes: [Payment!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalAmount: Money!
  totalCount: Int!
  totalFee: PaymentsFee!
}

"""Autogenerated return type of paymentDisbursed."""
type paymentDisbursedPayload {
  """True if this is the first disbursed payment for the practice"""
  isFirstPayment: Boolean!

  """The disbursed payment"""
  payment: Payment!
}

"""An edge in a connection."""
type PaymentEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Payment!
}

input PaymentFilter {
  """Payments which are currently scheduled to collect."""
  withScheduledCollection: Boolean

  """Payments which are not currently scheduled to collect."""
  withoutScheduledCollection: Boolean

  """Payments whose latest collection attempt failed."""
  latestCollectionFailed: Boolean

  """ISO formatted date"""
  availableOnGteq: Date

  """ISO formatted date"""
  availableOnLteq: Date
  stateEq: PaymentsPaymentStateEnum
  stateIn: [PaymentsPaymentStateEnum!]
  stateNotIn: [PaymentsPaymentStateEnum!]

  """Payments that use this payment method."""
  paymentMethodId: ID

  """Payments whose payment method is verified or not."""
  paymentMethodVerified: Boolean
}

type PaymentGateway {
  gatewayId: String!
  paymentMethodTypes: [PaymentMethodType!]
  processorId: String!
  statementDescriptor: String!
}

"""The connection type for PaymentGateway."""
type PaymentGatewayConnectionType {
  creditCard: PaymentGateway
  directDebit: PaymentGateway

  """A list of edges."""
  edges: [PaymentGatewayEdge!]!

  """A list of nodes."""
  nodes: [PaymentGateway!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PaymentGatewayEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PaymentGateway!
}

"""
A method for making payments; mainly Credit Card and Direct Debit methods.
"""
type PaymentMethod {
  bacsDebitMandateUrl: URL @deprecated(reason: "replaced by usage of StripeJS on the frontend")
  createdAt: DateTime!
  displayMethodType: String!
  displayName: String!

  """ISO formatted date"""
  expiryDate: Date
  id: ID!
  isDeleted: Boolean!
  isExpired: Boolean!
  isInUse: Boolean!
  isInvalid: Boolean! @deprecated(reason: "Avoid Booleans with a built-in negation")

  """Whether a surcharge will be applied when charging this payment method"""
  isSurchargeEnabled: Boolean!
  isValid: Boolean!
  isVerified: Boolean!

  """Name on card (if applicable)"""
  name: String
  numberSuffix: String!

  """Time taken to process payment (in days)."""
  processingTime: Int!
  referenceNumber: ID!

  """The category by which we determine the rate of surcharge"""
  surchargeCategory: PaymentMethodSurchargeCategory

  """
  The rate of surcharge added to this payment method's charges to account for payment fees
  """
  surchargeRate: Percentage!
  type: PaymentMethodType!
  verificationUrl: URL
}

"""Options for payment method acceptance status"""
enum PaymentMethodAcceptanceStatus {
  UNSUPPORTED
  SUPPORTED
  ACCEPTED
}

"""Autogenerated input type of PaymentMethodCreateFromSetupIntent"""
input PaymentMethodCreateFromSetupIntentInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The Stripe id of the setup intent """
  setupIntentStripeId: ID!

  """Use payment method for future invoices or not"""
  useForFutureInvoices: Boolean
}

"""Autogenerated return type of PaymentMethodCreateFromSetupIntent."""
type PaymentMethodCreateFromSetupIntentPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  paymentMethod: PaymentsPaymentMethod!
}

type PaymentMethodRequest {
  """
  Is credit card accepted in the client portal link generated from this request
  """
  creditCardAccepted: Boolean!

  """
  Is direct debit accepted in the client portal link generated from this request
  """
  directDebitAccepted: Boolean!

  """
  Error message received during the processing of a payment method request.
  """
  errorMessage: String
  id: ID!
  mostRecentActivityAt: DateTime!

  """
  The client-accessible portal url where the payment method should be added
  """
  portalUrl: URL!
  requestType: PaymentMethodRequestType!
  state: PaymentMethodRequestState!

  """Use this payment method for future billing items"""
  usePaymentMethodForFutureInvoices: Boolean!
}

"""The connection type for PaymentMethodRequest."""
type PaymentMethodRequestConnection {
  """A list of edges."""
  edges: [PaymentMethodRequestEdge!]!

  """A list of nodes."""
  nodes: [PaymentMethodRequest!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of PaymentMethodRequestCreate"""
input PaymentMethodRequestCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the client for the request"""
  clientId: ID!

  """Allowed payment methods in the client portal request"""
  creditCardAccepted: Boolean!

  """Allowed payment methods in the client portal request"""
  directDebitAccepted: Boolean!

  """Use this payment method for future billing items"""
  useMethodInFuture: Boolean!
}

"""Autogenerated return type of PaymentMethodRequestCreate."""
type PaymentMethodRequestCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  paymentMethodRequest: PaymentMethodRequest!
}

"""An edge in a connection."""
type PaymentMethodRequestEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PaymentMethodRequest!
}

input PaymentMethodRequestFilter {
  requestTypeEq: PaymentMethodRequestType
}

type PaymentMethodRequestGroup {
  clients: [Client!]!

  """
  Is credit card accepted in the client portal link generated from this request
  """
  creditCardAccepted: Boolean!

  """
  Is direct debit accepted in the client portal link generated from this request
  """
  directDebitAccepted: Boolean!
  id: ID!

  """Message text included in the notification to the client"""
  messageText: String!

  """Use this payment method for future billing items"""
  useMethodInFuture: Boolean!
}

enum PaymentMethodRequestState {
  PENDING
  SENT
  ACTIONED
  FAILED
}

enum PaymentMethodRequestType {
  EMAIL
  SHARED_LINK
}

"""Autogenerated input type of PaymentMethodSetupIntentCreate"""
input PaymentMethodSetupIntentCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The client id of the setup intent"""
  clientId: ID!

  """Type of payment method"""
  scopeId: ID

  """Type of transaction"""
  transactionType: String
}

"""Autogenerated return type of PaymentMethodSetupIntentCreate."""
type PaymentMethodSetupIntentCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  clientSecret: String!
}

"""Options for payment method surcharge category"""
enum PaymentMethodSurchargeCategory {
  CREDIT_CARD
  DEBIT_CARD
  PREPAID_CARD
  UNKNOWN_CARD
}

enum PaymentMethodType {
  CREDIT_CARD
  BANK_ACCOUNT
}

type PaymentNotificationSettings {
  sendNotifications: Boolean!
  tenantId: ID!
  useDefaultSettings: Boolean!
}

"""Autogenerated input type of PaymentRefundRequest"""
input PaymentRefundRequestInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Payment ID"""
  paymentId: ID!

  """Reason for the return"""
  reason: String!
}

"""Autogenerated return type of PaymentRefundRequest."""
type PaymentRefundRequestPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  refund: PaymentsRefund
}

type Payments {
  """
  Information about payments collected from clients on behalf of this practice
  """
  collections: Collections @deprecated(reason: "Use isEnabled or isSupported on payments object")

  """Whether this practice is collecting payments via credit card"""
  creditCardAccepted: Boolean!

  """
  Whether credit card payments are active in this practice's Stripe account
  """
  creditCardAvailable: Boolean!

  """Whether credit card payments are supported in this practice's region"""
  creditCardSupported: Boolean!

  """Whether this practice is collecting payments via direct debit"""
  directDebitAccepted: Boolean!

  """
  Whether direct debit payments are active in this practice's Stripe account
  """
  directDebitAvailable: Boolean!

  """Whether direct debit payments are supported in this practice's region"""
  directDebitSupported: Boolean!

  """Information about money disbursed to this practice"""
  disbursals: Disbursals

  """
  Whether the user needs to go through an external process with a payment
  processing partner to give extra information to the payment processor
  """
  externalVerificationRequired: Boolean!
  id: ID!

  """Whether payments can currently be collected"""
  isEnabled: Boolean!

  """Whether payments can be enabled"""
  isSupported: Boolean!

  """
  Number of days a payment will be collected after an invoice for one-off payment is raised
  """
  onceOffTerms: Int!

  """Whether this practice is allowing online payment"""
  onlinePaymentAllowed: Boolean!

  """Renders a HTML Payment Method Request email, with generic placeholders"""
  paymentMethodRequestEmailPreview(
    """
    The HTML email body template HTML, with optional embedded variables via Liquid
    """
    message: String!

    """Email recipients"""
    to: [EmailAddress!] = []
  ): EmailPreview!

  """
  Whether this practice requires a valid payment method from a client when a proposal is accepted
  """
  paymentMethodRequired: Boolean!

  """
  Number of days a payment will be collected after an invoice for a recurring payment is raised
  """
  recurringTerms: Int!

  """Locale specific text strings for payment related phrases"""
  translations: PaymentsTranslations!
}

"""Autogenerated input type of PaymentScheduleCollection"""
input PaymentScheduleCollectionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Invoice slug"""
  invoiceId: ID!

  """Payment method slug"""
  paymentMethodId: ID!

  """Time to start collection"""
  time: DateTime!
}

"""Autogenerated return type of PaymentScheduleCollection."""
type PaymentScheduleCollectionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  payment: Payment!
}

enum PaymentsClawbackState {
  STARTED
  COMPLETED
  FAILED
}

"""Autogenerated input type of PaymentsCollectionSettingsUpdate"""
input PaymentsCollectionSettingsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  creditCardAccepted: Boolean!
  directDebitAccepted: Boolean!
  paymentMethodRequired: Boolean!
  onlinePaymentAllowed: Boolean
}

"""Autogenerated return type of PaymentsCollectionSettingsUpdate."""
type PaymentsCollectionSettingsUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  payments: Payments
  practice: Practice! @deprecated(reason: "Use payments instead")
}

enum PaymentsCollectionsSettingState {
  """Customer is enabled to collect payments from their clients"""
  ENABLED

  """
  Customer requires onboarding with our payments provider before they can collect payments from clients
  """
  PROVIDER_ONBOARDING_REQUIRED

  """
  Customer requires a valid Ignition subscription before collecting payments from clients
  """
  SUBSCRIPTION_EXPIRED

  """Customer has been disabled by our provider for collecting payments"""
  PROVIDER_CHARGES_DISABLED
}

enum PaymentsCollectionState {
  STARTED
  COMPLETED
  FAILED
  AUTHENTICATION_REQUIRED
}

"""Autogenerated input type of PaymentsDisbursalAccountUpdate"""
input PaymentsDisbursalAccountUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  routingNumber: String!
  accountNumber: String!
  accountName: String!
  descriptor: String!
}

"""Autogenerated return type of PaymentsDisbursalAccountUpdate."""
type PaymentsDisbursalAccountUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  disbursals: Disbursals
  practice: Practice! @deprecated(reason: "Use disbursals instead")
}

type PaymentsDisbursalDispute {
  amount: Money!
  createdAt: DateTime!
  id: ID!

  """Payment associated with the dispute"""
  payment: Payment!
  state: PaymentsDisputeState!
}

"""The connection type for PaymentsDisbursalDispute."""
type PaymentsDisbursalDisputeConnection {
  """A list of edges."""
  edges: [PaymentsDisbursalDisputeEdge!]!

  """A list of nodes."""
  nodes: [PaymentsDisbursalDispute!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalAmount: Money!
  totalCount: Int!
}

"""An edge in a connection."""
type PaymentsDisbursalDisputeEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PaymentsDisbursalDispute!
}

enum PaymentsDisbursalsExport {
  """
  For creating a report with clawbacks and collections individually listed
  """
  PAYMENTS_CLAWBACKS_COLLECTIONS

  """
  For creating a report of disbursal totals (e.g. total of all clawbacks and collections per disbursal)
  """
  PAYMENTS_DISBURSALS
}

"""Autogenerated input type of PaymentsDisbursalsExport"""
input PaymentsDisbursalsExportInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ISO formatted date"""
  startDate: Date

  """ISO formatted date"""
  endDate: Date
  exportType: PaymentsDisbursalsExport!
}

"""Autogenerated return type of PaymentsDisbursalsExport."""
type PaymentsDisbursalsExportPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  export: Export!
}

enum PaymentsDisbursalsSettingState {
  """Customer is enabled to have money disbursed to their allocated account"""
  ENABLED

  """Customer requires F&R checks to enable disbursals"""
  KYC_REQUIRED

  """Customer is pending F&R checks to enable disbursals"""
  FRAUD_DETECTION

  """Customer requires an active Ignition subscription to enable disbursals"""
  SUBSCRIPTION_EXPIRED

  """
  Customer has updated their disbursal account information and require F&R checks to have disbursals enabled
  """
  DISBURSAL_ACCOUNT_CHANGED

  """
  Customer has been rejected as a suitable candidate for Ignition Payments
  """
  REJECTED_BY_STAFF

  """
  Customer must complete provider verification steps before enablement of disbursals
  """
  PROVIDER_PAYOUTS_DISABLED
}

enum PaymentsDisbursalStateEnum {
  STARTED
  COMPLETED
  FAILED
}

enum PaymentsDisputeState {
  STARTED
  WON
  LOST
}

type PaymentSettings {
  """State of payments collections setting"""
  collectionsState: PaymentsCollectionsSettingState!

  """Acceptance status for credit card payments"""
  creditCardAcceptance: PaymentMethodAcceptanceStatus!

  """Acceptance status for direct debit payments"""
  directDebitAcceptance: PaymentMethodAcceptanceStatus!

  """The bank account for disbursal"""
  disbursalAccount: BankAccount

  """Disbursals Disablement Type"""
  disbursalsDisablementType: DisbursalsDisablementType

  """State of payments disbursals setting"""
  disbursalsState: PaymentsDisbursalsSettingState!

  """ID of current payments settings"""
  id: ID!

  """Are disbursals enabled?"""
  isDisbursalsEnabled: Boolean!

  """
  Whether surcharges are restricted to only the 'credit_card' surcharge category
  """
  isSurchargeCreditCardsOnly: Boolean!

  """
  Whether a practice can use surcharges to pass on payment fees to their clients
  """
  isSurchargeEnabled: Boolean!

  """State of payments onboarding"""
  onboardingState: PaymentsOnboardingState!

  """Indicates whether the customer allows online payments"""
  onlinePaymentAllowed: Boolean!

  """
  Indicates whether he customer require a client to attach a payment method to proposals on acceptance
  """
  paymentMethodRequired: Boolean!

  """Description of the most recent change to surcharge settings"""
  surchargeLastUpdateMessage: String

  """Rate at which applicable cards are surcharged"""
  surchargeRate: Percentage!
}

"""Additional expenses added to the price of a transaction"""
type PaymentsFee {
  """A amount per charge"""
  amount: Money

  """The description of the fee based on"""
  description: String
}

type PaymentsNotificationsRecipientGroup {
  emailAddresses: [EmailAddress!]!
}

enum PaymentsOnboardingState {
  """
  Customer is required to complete provider onboarding before using Ignition Payments
  """
  PROVIDER_ONBOARDING_REQUIRED

  """
  Customer is required to complete Ignition Onboarding with our F&R team before
  being enabled for all Ignition Payments features
  """
  ONBOARDING_REQUIRED

  """Customer has onboarded to all provider and Ignition requested steps"""
  COMPLETED
}

"""An interface type for payment method"""
interface PaymentsPaymentMethod {
  createdAt: DateTime!
  id: ID!
  isInUse: Boolean!
  isInvalid: Boolean!
  name: String
  numberSuffix: String!
  referenceNumber: ID!
  verified: Boolean!
}

enum PaymentsPaymentStateEnum {
  UNCOLLECTED
  COLLECTING
  COLLECTED
  REFUNDING
  REFUNDED
  DISBURSING
  DISBURSED
  CLAWING_BACK
  CANCELLED
}

type PaymentsRefund {
  amount: Money!
  completedAt: DateTime
  createdAt: DateTime!
  id: ID!
  message: String
  payment: Payment!
  reason: String
  startedAt: DateTime
  state: PaymentsRefundState!
  updatedAt: DateTime!
}

enum PaymentsRefundState {
  APPROVED
  PENDING
  DECLINED
  STARTED
  COMPLETED
  FAILED
}

"""Autogenerated input type of PaymentStartCollection"""
input PaymentStartCollectionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Invoice slug"""
  invoiceId: ID!

  """Slug of payment method"""
  paymentMethodId: ID!
}

"""Autogenerated return type of PaymentStartCollection."""
type PaymentStartCollectionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  payment: Payment
}

"""Autogenerated return type of paymentStarted."""
type paymentStartedPayload {
  """True if this is the first started payment for the practice"""
  isFirstPayment: Boolean!

  """The started payment"""
  payment: Payment!
}

"""Autogenerated input type of PaymentsTermsUpdate"""
input PaymentsTermsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  onceOffTerms: Int
  recurringTerms: Int
}

"""Autogenerated return type of PaymentsTermsUpdate."""
type PaymentsTermsUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  payments: Payments!
  practice: Practice! @deprecated(reason: "Use payments instead")
}

type PaymentsTranslations {
  accountNumber: String!
  directDebit: String!
  routingNumber: String!
}

"""Autogenerated input type of PaymentUnscheduleCollection"""
input PaymentUnscheduleCollectionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of payment"""
  paymentId: ID!
}

"""Autogenerated return type of PaymentUnscheduleCollection."""
type PaymentUnscheduleCollectionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  payment: Payment!
}

type Percentage {
  format: String!
  value: Decimal!
}

input PercentageInput {
  """Value as a percentage, e.g. 10%"""
  percentage: Float

  """Percentage as a value, e.g. 0.1"""
  value: Float
}

scalar PhoneNumber

type Placeholder {
  """Description of the placeholder"""
  description: String!

  """id of the placeholder"""
  id: String!

  """Name of placeholder for users"""
  name: String!

  """Path used by Liquid to render the value"""
  path: String!

  """A hard-coded sample value for this placeholder"""
  sampleValue: String

  """State of the placeholder"""
  state: PlaceholderState!

  """The actual value when a scope is provided"""
  value: String
}

enum PlaceholderState {
  AVAILABLE
  DEPRECATED
}

type Plan {
  """The cost of additional active clients"""
  additionalActiveClientPrice: Money

  """a snippet describing additional active clients"""
  additionalActiveClientsText: String

  """
  A list additional features (beyond the features html) that are associated with this plan
  """
  additionalFeatures: [PlanFeature!]!

  """The percent a user saves if they get an annual plan"""
  annualDiscountRate: Percentage!
  billingPeriod: PlanBillingPeriod!
  code: String!

  """An HTML snippet about the direct debit"""
  directDebit: Html

  """
  A snippet about the additional fees associated to a direct debit charge
  """
  directDebitPriceText: String

  """An HTML snippet about what credit card processing is"""
  domesticCreditCard: Html

  """An unsafe HTML friendly description of some of the plan features"""
  features: HtmlText @deprecated(reason: "Use the safe_features field instead")
  feeDomesticCard: FeeType!
  feeInternationalCard: FeeType!

  """A HTML description of the plan implementation"""
  implementation: Html
  includesTax: Boolean!

  """An HTML snippet about what International amex processing is"""
  internationalAmexCard: Html
  isEligible: Boolean!

  """A boolean telling us this plan isn't used anymore"""
  isLegacy: Boolean!
  maxClients: Int!

  """Name of plan that is used for display"""
  name: String!

  """The number of proposals this plan supports"""
  numberOfProposals: Int

  """A snipped about the additional fees associated to a credit card"""
  paymentsCreditCardChargeText: String

  """A snippet about the additional fees for amex processing"""
  paymentsInternationalAmexCardChargeText: String

  """A short description of the plan. (subtitle perhaps)"""
  planDescription: String @deprecated(reason: "use shortDescription instead")

  """A HTML friendly description of some of the plan features"""
  planFeatures: HtmlText @deprecated(reason: "use features instead")

  """A HTML description of the plan implementation"""
  planImplementation: HtmlText @deprecated(reason: "use implementation instead")

  """A html friendly description of the support on offer"""
  planSupport: HtmlText @deprecated(reason: "use support instead")

  """An integer describing the plan's ordinal position."""
  position: Int!
  price: Money!
  priceMonthly: Money!

  """A safe HTML friendly description of some of the plan features"""
  safeFeatures: Html

  """A short description of the plan. (subtitle perhaps)"""
  shortDescription: String

  """A html friendly description of the support on offer"""
  support: Html

  """The name of the support queue that this plan enables"""
  supportQueueText: String
  taxCode: String!

  """Plan tier that practice is on"""
  tier: PlanNameEnum!

  """The date of the plan as a string"""
  version: String!
}

enum PlanBillingPeriod {
  """Billed monthly"""
  MONTHLY

  """Billed annually"""
  ANNUALLY
}

"""The connection type for Plan."""
type PlanConnection {
  """A list of edges."""
  edges: [PlanEdge!]!

  """A list of nodes."""
  nodes: [Plan!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PlanEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Plan!
}

enum PlanFeature {
  ONBOARDING
  SECURE_STORAGE
  ZAPIER_INTEGRATION
  BEST_PRACTICE_COACH
  WEBSITE_INTEGRATION
  WORKFLOW_INTEGRATION
  ACCOUNTING_INTEGRATION
  BUSINESS_INTELLIGENCE_DASHBOARD
  SERVICE_LIBRARY_WITH_MARKET_PRICE
}

enum PlanNameEnum {
  CORE
  PRO
  PROPLUS
  BOOKKEEPER
  NONE
  TRIAL
  STARTER
  PROFESSIONAL
  SCALE

  """Legacy plan"""
  MARS

  """Legacy plan"""
  JUPITER

  """Legacy plan"""
  NEPTUNE

  """Legacy plan"""
  SATURN
}

enum PlanVersion {
  NOV_2023
  JUNE_2018
  JUNE_2015
  MAY_2014
}

type Portion {
  billingSchedule: ProposalBillingScheduleInterface!
  description: String
  id: ID!
  invoiceStrategy: ProposalInvoiceStrategy!
  percentage: Decimal

  """the one-based position of this portion in the proposed service"""
  position: Int!
  price: ProposalPriceInterface!
  proposedService: ProposedService!
}

input PortionInput {
  id: ID
  price: ServicePriceRuleInput!
  billingSchedule: BillingScheduleInputType!
  invoiceStrategy: ProposalInvoiceStrategy!
}

type Practice {
  accounts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AccountConnection @deprecated(reason: "Use root level accounts instead")
  billing: PracticeBilling!

  """Currency used for billing clients"""
  billingCurrency: Currency!
  brandingThemes(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): XeroBrandingThemeConnection @deprecated(reason: "Access through Xero instead")
  clientDefaultEmailSettings: [EmailSettings!]!
  clients(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClientConnection @deprecated(reason: "Use root level clients instead")

  """
  List of revenue brackets for cmi questions based on the current practice region
  """
  cmiRevenueBrackets: [RevenueBracket!]!
  colour: String @deprecated(reason: "Use brandingTheme.colour instead")
  countryCode: CountryCode!
  createdAt: DateTime!
  creator: User!

  """Currency used for billing clients"""
  currency: Currency! @deprecated(reason: "Use billingCurrency instead.")

  """Current financial year of the practice."""
  currentFinancialYear: Int!
  customerSuccessMaturityIndex: CustomerSuccessMaturityIndexUnion
  defaultBillingGroupedBy: ProposalBillingGroupedBy!
  defaultIntroMessageTemplate: IntroMessageTemplate
  defaultNewProposalEmailTemplate: NewProposalEmailTemplate
  defaultNextStepsMessageTemplate: NextStepsMessageTemplate
  defaultTax: Tax!
  defaultTermsTemplate: TermsTemplate
  emailAddress: EmailAddress!
  features(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): FeatureConnection!

  """The month number of the start of the financial year (Jan = 1)."""
  financialYearStart: Int!
  id: ID!
  intent: PracticeIntentEnum!
  isBillable: Boolean!
  locale: String
  logo: String
  name: String!

  """When the notification for plan upgrade was sent"""
  notifiedOfImminentPlanUpgradeOn: Date
  paymentDescriptor: String
  paymentGateways(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PaymentGatewayConnectionType @deprecated(reason: "Use root level paymentGateways instead")
  paymentRegion: String
  paymentSettings: PaymentSettings!
  payments: Payments @deprecated(reason: "Use root level payments instead")
  plan: Plan
  practiceTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PracticeTemplateConnection @deprecated(reason: "Use root level templates instead")
  preferredLandingPage: PreferredLandingPage
  preferredProposalEditor: PreferredProposalEditor
  principal: User!
  referenceNumber: ID!

  """The referral copy to be displayed for the practice based on region"""
  referralCopy: CustomerSuccessReferralCopy
  referralMethod: String
  signupPhone: PhoneNumber
  stripePublishableKey: String

  """Boolean flag to control whether we show or hide the SCA form on Gizmo"""
  stripeSca: Boolean!
  subscriptionAccountCode: String

  """Currency used for the practice subscription"""
  subscriptionCurrency: Currency!
  subscriptionStatus: SubscriptionStatus!
  taxDisplay: TaxDisplay!
  taxTypeLabel: String
  taxes(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): TaxConnection @deprecated(reason: "Use root level taxes instead")
  tfaEffectiveFrom: Date
  timeZone: TimeZone!
  token: PublicToken
  trialEndDate: Date
  twoFactorAuthRequired: Boolean!
  updatedAt: DateTime!
  worldRegion: String!
}

type PracticeBilling {
  """The last day for an arrear account to pay before account is expired"""
  arrearsDueDate: Date

  """flag indicating payment for the account is overdue"""
  arrearsStatus: PracticeBillingArrearsStatus
  availablePlans: [PracticeBillingPlan!]
  billingInfo: PracticeBillingBillingInfo

  """Test coupons for validity"""
  couponsTest(plan: PracticeBillingPlanInput!, couponCodes: [String!]): [PracticeBillingCouponTest!]
  currentSubscription: PracticeBillingSubscription!

  """Eligible plans for coupon redemption."""
  eligibleBillingPlans(couponCode: String!): [PracticeBillingEligibleBillingPlan!]
  invoices(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PracticeBillingInvoiceConnection
  paymentChallenge: PracticeBillingPaymentChallenge
  paymentMethods: [PracticeBillingPaymentMethod!]

  """Preview of practice's billing subscription."""
  subscriptionPreview(plan: PracticeBillingPlanInput!, couponCodes: [String!]): PracticeBillingSubscription
}

type PracticeBillingAddress {
  city: String
  country: String
  lines: [String]
  postcode: String
  state: String
}

input PracticeBillingAddressInput {
  lines: [String!]
  city: String
  state: String
  postcode: String
  country: String
}

enum PracticeBillingArrearsStatus {
  PAID
  ARREARS
}

type PracticeBillingBillingInfo {
  address: PracticeBillingAddress
  email: EmailAddress
  firstName: String
  lastName: String
  phone: PhoneNumber
}

input PracticeBillingBillingInfoInput {
  firstName: String
  lastName: String
  email: EmailAddress
  phone: PhoneNumber
  address: PracticeBillingAddressInput
}

"""Autogenerated input type of practiceBillingCancelSubscription"""
input practiceBillingCancelSubscriptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  exitSurvey: ExitSurveyInputType!
}

"""Autogenerated return type of practiceBillingCancelSubscription."""
type practiceBillingCancelSubscriptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  exitSurvey: ExitSurvey!
  practice: Practice!
}

type PracticeBillingClientProduct implements PracticeBillingProduct {
  category: PracticeBillingProductCategory!
  description: String!
  limit: Int!
  name: String!
  price: PracticeBillingMoneyPrice!
}

type PracticeBillingCoupon {
  code: String
  description: String
}

type PracticeBillingCouponTest {
  code: String!
  description: String
  invalidReason: String
  isValid: Boolean!
}

"""A billing plan with the coupon code it's eligible for"""
type PracticeBillingEligibleBillingPlan {
  """
  Combination of specific tier and frequency ie. '2018-professional-monthly'
  """
  code: String
  couponCode: String!
  description: String

  """The billing frequency of the plan ie. monthly, annually"""
  frequency: String

  """Name of plan that is used for display"""
  name: String!
}

type PracticeBillingInvoice {
  amount: Money!
  amountWithTax: Money!
  createdOn: Date!
  id: ID!
  items: [PracticeBillingInvoiceItem!]
  pdfUrl: URL!
  reference: String!
  status: PracticeBillingInvoiceStatus!
  taxAmount: Money!
}

"""The connection type for PracticeBillingInvoice."""
type PracticeBillingInvoiceConnection {
  """A list of edges."""
  edges: [PracticeBillingInvoiceEdge!]!

  """A list of nodes."""
  nodes: [PracticeBillingInvoice!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PracticeBillingInvoiceEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PracticeBillingInvoice!
}

type PracticeBillingInvoiceItem {
  amount: Money!
  amountWithTax: Money!
  description: String!
  position: Int!
  quantity: Int
  taxAmount: Money!
  unitPrice: Money!
}

enum PracticeBillingInvoiceStatus {
  PAID
  UNPAID
}

type PracticeBillingMoneyPrice {
  discount: Money
  exTax: Money!
  original: Money!
}

type PracticeBillingOtherProduct implements PracticeBillingProduct {
  category: PracticeBillingProductCategory!
  description: String!
  limit: Int
  name: String!
}

type PracticeBillingPaymentChallenge {
  app: App!
  id: ID!

  """Integration specific token to resolve this challenge"""
  token: String!
  type: PracticeBillingPaymentChallengeTypeEnum!
}

enum PracticeBillingPaymentChallengeTypeEnum {
  SECURE_3D_2
}

type PracticeBillingPaymentFeeProduct implements PracticeBillingProduct {
  category: PracticeBillingProductCategory!
  description: String!
  name: String!
  percentagePrice: PracticeBillingPercentagePrice!
  price: PracticeBillingMoneyPrice!
}

type PracticeBillingPaymentMethod {
  cardType: String!
  expiryMonth: String!
  expiryYear: String!
  firstSix: String
  id: ID!
  lastFour: String
}

input PracticeBillingPaymentMethodInput {
  appName: String!
  token: String!
}

type PracticeBillingPercentagePrice {
  discount: Percentage
  exTax: Percentage!
  original: Percentage!
}

type PracticeBillingPlan {
  """
  Combination of specific tier and frequency ie. '2018-professional-monthly'
  """
  code: String
  id: ID!
  isCustom: Boolean!
  isLegacy: Boolean!

  """Name of plan that is used for display"""
  name: String!
  products(filter: PracticeBillingProductFilter): [PracticeBillingProduct!]!

  """Plan tier that practice is on"""
  tier: PracticeBillingPlanNameEnum!
}

enum PracticeBillingPlanFrequency {
  MONTHLY
  ANNUALLY
}

input PracticeBillingPlanInput {
  id: ID!
  frequency: PracticeBillingPlanFrequency!
}

enum PracticeBillingPlanNameEnum {
  PROPLUS
  BOOKKEEPER
  PRO
  CORE
  NONE
  TRIAL
  STARTER
  PROFESSIONAL
  SCALE

  """Legacy plan"""
  MARS

  """Legacy plan"""
  JUPITER

  """Legacy plan"""
  NEPTUNE

  """Legacy plan"""
  SATURN
}

type PracticeBillingPlanProduct implements PracticeBillingProduct {
  category: PracticeBillingProductCategory!
  description: String!
  frequency: PracticeBillingPlanFrequency!
  name: String!
  priceAnnually: PracticeBillingMoneyPrice!
  priceMonthly: PracticeBillingMoneyPrice!
}

interface PracticeBillingProduct {
  category: PracticeBillingProductCategory!
  description: String!
  name: String!
}

enum PracticeBillingProductCategory {
  SUBSCRIPTION
  FEATURE
  IMPLEMENTATION
  SUPPORT
  PAYMENT
  CLIENTS
}

input PracticeBillingProductFilter {
  category: String
  name: String
}

"""Autogenerated input type of practiceBillingReportPaymentChallengeError"""
input practiceBillingReportPaymentChallengeErrorInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The id of the payment challenge with an error"""
  id: ID!

  """The name of the App that generated this payment challenge"""
  appName: String!

  """The error message received while attempting to resolve a 3DS challenge"""
  errorMessage: String

  """The error code received while attempting to resolve a 3DS challenge"""
  errorCode: String

  """Request that the payment challenge be marked as failed"""
  failChallenge: Boolean!
}

"""
Autogenerated return type of practiceBillingReportPaymentChallengeError.
"""
type practiceBillingReportPaymentChallengeErrorPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice!
}

"""Autogenerated input type of practiceBillingResolvePaymentChallenge"""
input practiceBillingResolvePaymentChallengeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The id of the payment challenge being resolved"""
  id: ID!

  """App-specific token that resolves the payment challenge"""
  token: String!

  """The name of the App that generated this payment challenge"""
  appName: String!
}

"""Autogenerated return type of practiceBillingResolvePaymentChallenge."""
type practiceBillingResolvePaymentChallengePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice!
}

"""Autogenerated input type of practiceBillingSetSubscription"""
input practiceBillingSetSubscriptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  plan: PracticeBillingPlanInput
  couponCodes: [String!]
  paymentMethod: PracticeBillingPaymentMethodInput
  billingInfo: PracticeBillingBillingInfoInput
}

"""Autogenerated return type of practiceBillingSetSubscription."""
type practiceBillingSetSubscriptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice!
}

type PracticeBillingSubscription {
  accessAllowed: Boolean!
  activeClientCount: Int!
  activeUserCount: Int!
  cancelledDate: Date
  coupons: [PracticeBillingCoupon!]
  endDate: Date
  frequency: PracticeBillingPlanFrequency
  paymentMethod: PracticeBillingPaymentMethod
  pendingPaymentFees: Money!
  plan: PracticeBillingPlan!
  products(filter: PracticeBillingProductFilter): [PracticeBillingProduct!]
  renewDate: Date
  startDate: Date!
  trial: Boolean!
}

"""Autogenerated input type of PracticeConfirmDetails"""
input PracticeConfirmDetailsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practiceDetails: PracticeDetailsInput!
}

"""Autogenerated return type of PracticeConfirmDetails."""
type PracticeConfirmDetailsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice!
}

"""Input fields for the details of a practice"""
input PracticeDetailsInput {
  """The full name of the creator of the practice"""
  creatorFullName: String!

  """The name of the practice"""
  name: String!

  """Principal phone number for the practice"""
  signupPhone: PhoneNumber!

  """How did the creator of the practice hear about Ignition"""
  howDidYouHearAboutUs: String!

  """The country code for the practice"""
  countryCode: CountryCode!
}

enum PracticeIntentEnum {
  GROWTH
  PAYMENTS
  EFFICIENCY
  PROFIT
  UNKNOWN
}

"""Autogenerated input type of PracticeSetDefaultNewProposalEmailTemplate"""
input PracticeSetDefaultNewProposalEmailTemplateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of new proposal email template"""
  templateId: ID!
}

"""
Autogenerated return type of PracticeSetDefaultNewProposalEmailTemplate.
"""
type PracticeSetDefaultNewProposalEmailTemplatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of PracticeSetDefaultTax"""
input PracticeSetDefaultTaxInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of the Tax"""
  id: ID!
}

"""Autogenerated return type of PracticeSetDefaultTax."""
type PracticeSetDefaultTaxPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of PracticeSetDefaultTermsTemplate"""
input PracticeSetDefaultTermsTemplateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of terms template"""
  templateId: ID!
}

"""Autogenerated return type of PracticeSetDefaultTermsTemplate."""
type PracticeSetDefaultTermsTemplatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of PracticeSetIntent"""
input PracticeSetIntentInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  intent: PracticeIntentEnum!
}

"""Autogenerated return type of PracticeSetIntent."""
type PracticeSetIntentPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice!
}

"""Autogenerated input type of PracticeSetPreferredLandingPage"""
input PracticeSetPreferredLandingPageInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  preferredLandingPage: PreferredLandingPage
}

"""Autogenerated return type of PracticeSetPreferredLandingPage."""
type PracticeSetPreferredLandingPagePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of PracticeSetPreferredProposalEditor"""
input PracticeSetPreferredProposalEditorInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  preferredProposalEditor: PreferredProposalEditor
}

"""Autogenerated return type of PracticeSetPreferredProposalEditor."""
type PracticeSetPreferredProposalEditorPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

interface PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  slug: ID!
  updatedAt: DateTime!
}

"""The connection type for PracticeTemplate."""
type PracticeTemplateConnection {
  """A list of edges."""
  edges: [PracticeTemplateEdge]

  """A list of nodes."""
  nodes: [PracticeTemplate]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PracticeTemplateEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PracticeTemplate
}

enum PreferredLandingPage {
  """Always use the Dashboard page"""
  DASHBOARD
}

enum PreferredProposalEditor {
  """Always use New Proposals"""
  NPE
}

input PriceIncreaseInputType {
  """float between 0.0 and 100.0, with 10% expressed as 10.0"""
  percentage: PercentageInput!

  """Round to nearest amount. Typical values: 1, 5, 10"""
  roundToNearest: Int
}

type PriceRuleUnitName {
  """Slug of the custom unit price"""
  id: ID!

  """the name of the unit price rule"""
  name: String!
}

"""The connection type for PriceRuleUnitName."""
type PriceRuleUnitNameConnection {
  """A list of edges."""
  edges: [PriceRuleUnitNameEdge!]!

  """A list of nodes."""
  nodes: [PriceRuleUnitName!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PriceRuleUnitNameEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PriceRuleUnitName!
}

type Proconnect {
  state: ProconnectState!
}

"""Autogenerated input type of ProconnectConnect"""
input ProconnectConnectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of ProconnectConnect."""
type ProconnectConnectPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proconnect: Proconnect
}

"""Autogenerated input type of ProconnectDisconnect"""
input ProconnectDisconnectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of ProconnectDisconnect."""
type ProconnectDisconnectPayload {
  app: App!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proconnect: Proconnect
}

enum ProconnectState {
  AUTHORISED
  CONNECTED
  ENABLED
  DISCONNECTED
  UNAUTHORISED
  UNAVAILABLE
}

type Project {
  createdAt: DateTime!
  description: String

  """Reference number for the project (eg. PROJ-0001)"""
  displayReferenceNumber: String!
  id: ID!
  name: String!
  option: ProposalOption!
  position: Int!
  serviceGroups: [ServiceGroup!]!
  updatedAt: DateTime!
}

type Proposal {
  acceptProposalMessage: Textile
  acceptanceEmail: AcceptanceEmail
  acceptedAt: DateTime
  acceptedOption: ProposalOption @deprecated(reason: "Use selectedOption instead")
  activities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    orderBy: ActivityLogOrder = {createdAt: ASCENDING}
  ): ActivityLogConnection

  """
  If present, this is an error related to recent activity on the proposal, such as a failed send
  """
  activityError: String

  """The date/time when activityError last occurred"""
  activityErrorOccurredAt: DateTime
  billingGroupedBy: ProposalBillingGroupedBy!
  brochure: Brochure

  """Minimum contract window end date"""
  calculatedUntil: Date!
  client: Client
  contact: Contact
  createdAt: DateTime!
  createdFrom: ProposalSource
  creator: User!
  creditCardAccepted: Boolean!
  currency: Currency!
  directDebitAccepted: Boolean!

  """
  Reference number for the proposal (eg. PROP-0001) (adding again for consistency with ClientType)
  """
  displayReferenceNumber: String!
  duplicatedFrom: Proposal
  effectiveFrom: String

  """
  Indicates if any of the proposed services on the proposal has smart billing
  """
  hasSmartBilling: Boolean!
  id: ID!

  """Indicates if the proposal imported from a ledger"""
  isImportedFromLedger: Boolean!

  """Indicates if the proposal can be renewed"""
  isRenewable: Boolean!

  """Indicates if the proposal was created via client renewal"""
  isRenewal: Boolean!

  """Indicates if the proposal has been renewed"""
  isRenewed: Boolean!
  lockVersion: Int!
  minimumContractLength: Int!

  """
  Minimum contract value without tax based on selected option or the cheapest
  available option (if none have been selected yet)
  """
  minimumContractValue: Money!

  """
  Minimum contract value tax amount based on selected option or the cheapest
  available option (if none have been selected yet)
  """
  minimumContractValueTaxAmount: Money!

  """
  Minimum contract value with tax based on selected option or the cheapest available option (if none have been selected yet)
  """
  minimumContractValueWithTax: Money!
  name: String!
  nextStepsMessage: Html!
  nextStepsMessagePreview: Html!
  notifications: Notifications!
  oneTimeDateDisplay: ProposalOneTimeDateDisplay!
  option(id: ID!): ProposalOption
  options: [ProposalOption!]!
  paymentMethod: PaymentMethod
  paymentMethodRequired: Boolean!

  """The url of the generated PDF for this proposal"""
  pdfUrl: URL!
  personalisedMessage: Html!
  personalisedMessagePreview: Html!
  postAcceptanceVideoUrl: URL
  preAcceptanceVideoUrl: URL
  priceIncreased: Boolean!

  """
  Flag that indicates whether the primary signatory needs to sign before the others
  """
  primaryMustSignFirst: Boolean!
  project(id: ID!): Project
  proposalValueDisplay: ProposalValueDisplay!
  proposedService(id: ID!): ProposedService

  """Indicates if the proposal's preview is publicly available"""
  publiclyPreviewable: Boolean!
  recipients: [ProposalRecipient]!
  recommendedOption: ProposalOption
  reviewAssignee: User
  reviewState: ProposalReviewState!
  selectedOption: ProposalOption
  sender: User
  sentAt: DateTime
  serviceGroup(id: ID!): ServiceGroup
  serviceGroups: [ServiceGroup!]
  servicePriceDisplay: ProposalServicePriceDisplay!

  """Proposal service terms"""
  serviceTerms(
    """
    Slug of the option to use; defaults to the selected option (or first if none selected)
    """
    optionId: ID
  ): ProposalServiceTerms!

  """Signatories for this proposal"""
  signatories(filter: SignatoryFilter): [ProposalSignatory!]!
  startDate: Date
  startOn: ProposalStartOn!
  state: ProposalState!
  suggestedWorkflowTemplates: [WorkflowTemplateType!]!
  tax: Tax
  taxMethod: TaxMethod!
  terms: ProposalTerms @deprecated(reason: "Use termsMessage instead")

  """Proposal terms message"""
  termsMessage: ProposalTermsMessage!
  token: String!

  """
  If present, reason why the proposal cannot be renewed. Incurs an extra query, so should only be called when necessary
  """
  unrenewableReason: String
  updatedAt: DateTime!
  workflowSettings(appName: ID!): WorkflowSettings!
  workflowStrategies: [WorkflowStrategy!]!
  workflowStrategy(id: ID!): WorkflowStrategy
}

type ProposalAcceptedBrowserTemplate implements PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  slug: ID!
  updatedAt: DateTime!
}

"""Autogenerated input type of ProposalAcceptedBrowserTemplateUpdate"""
input ProposalAcceptedBrowserTemplateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of proposal accepted browser template"""
  id: ID!
  template: TemplateInput!
}

"""Autogenerated return type of ProposalAcceptedBrowserTemplateUpdate."""
type ProposalAcceptedBrowserTemplateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: ProposalAcceptedBrowserTemplate
  templates: Templates
}

type ProposalAcceptedEmailTemplate implements EmailTemplateInterface & PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  slug: ID!
  subject: String!
  updatedAt: DateTime!
}

"""Autogenerated input type of ProposalAcceptedEmailTemplateUpdate"""
input ProposalAcceptedEmailTemplateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of proposal accepted email template"""
  id: ID!
  template: EmailTemplateInput!
}

"""Autogenerated return type of ProposalAcceptedEmailTemplateUpdate."""
type ProposalAcceptedEmailTemplateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: ProposalAcceptedEmailTemplate
  templates: Templates
}

"""Autogenerated return type of proposalAccepted."""
type proposalAcceptedPayload {
  """True if this is the first accepted proposal for the practice"""
  isFirstProposal: Boolean!

  """The accepted proposal"""
  proposal: Proposal!
}

"""Autogenerated input type of ProposalAddDefaultWorkflow"""
input ProposalAddDefaultWorkflowInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of Proposal"""
  id: ID!

  """The name of the workflow app to create workflow for."""
  appName: String!

  """Defines how many workflows will be created."""
  workflowStructure: ProposalWorkflowSettingsWorkflowStructure!

  """
  Specify which option's projects or services will be used to build workflow
  defaults. Only applies if the proposal has options enabled.
  """
  optionId: ID

  """
  If true, any existing workflows on this proposal will first be removed before
  adding new workflows based on the current settings. Defaults to false.
  """
  removeExistingWorkflow: Boolean = false
}

"""Autogenerated return type of ProposalAddDefaultWorkflow."""
type ProposalAddDefaultWorkflowPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalAddMultipleBillingServiceGroup"""
input ProposalAddMultipleBillingServiceGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """the slug of the project to add the service group to"""
  projectId: ID!

  """
  Position for new service groups is automatically assigned. Use ProposalMoveServiceGroup to change position after creation.
  """
  position: Int = null

  """
  optional schedules to configure future billings. if not specified, a single on
  acceptance schedule will be assumed as a reasonable default
  """
  billingSchedules: [BillingScheduleInputType!] = null

  """
  the frontend billing mode to store for future display purposes. required if `billing_schedules` is present.
  """
  billingMode: ProposalBillingModeEnum = null
}

"""Autogenerated return type of ProposalAddMultipleBillingServiceGroup."""
type ProposalAddMultipleBillingServiceGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  serviceGroup: ServiceGroup
}

"""Autogenerated input type of ProposalAddOnAcceptanceServiceGroup"""
input ProposalAddOnAcceptanceServiceGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the project to add the service group to"""
  projectId: ID!

  """
  Position for new service groups is automatically assigned. Use ProposalMoveServiceGroup to change position after creation.
  """
  position: Int = null
}

"""Autogenerated return type of ProposalAddOnAcceptanceServiceGroup."""
type ProposalAddOnAcceptanceServiceGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  serviceGroup: ServiceGroup
}

"""Autogenerated input type of ProposalAddOption"""
input ProposalAddOptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of Proposal"""
  id: ID!

  """position to add new option at"""
  position: Int!
}

"""Autogenerated return type of ProposalAddOption."""
type ProposalAddOptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  option: ProposalOption
  proposal: Proposal
}

"""Autogenerated input type of ProposalAddProject"""
input ProposalAddProjectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the option to add the project to"""
  optionId: ID!

  """position to add new project at"""
  position: Int!
}

"""Autogenerated return type of ProposalAddProject."""
type ProposalAddProjectPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  project: Project
  proposal: Proposal
}

"""Autogenerated input type of ProposalAddProposedService"""
input ProposalAddProposedServiceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the service group to add the proposed service to"""
  serviceGroupId: ID!

  """uuid of the service library service to use as a template"""
  serviceId: ID!

  """position to add new project at"""
  position: Int
}

"""Autogenerated return type of ProposalAddProposedService."""
type ProposalAddProposedServicePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalAddRecipient"""
input ProposalAddRecipientInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """proposal slug"""
  id: ID!

  """email address"""
  email: EmailAddress!
}

"""Autogenerated return type of ProposalAddRecipient."""
type ProposalAddRecipientPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  recipient: ProposalRecipient
}

"""Autogenerated input type of ProposalAddRecurringServiceGroup"""
input ProposalAddRecurringServiceGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of the proposal"""
  id: ID!

  """UUID of the project to add the service group to"""
  projectId: ID!
  rule: RecurrenceRuleInput

  """
  Position for new service groups is automatically assigned. Use ProposalMoveServiceGroup to change position after creation.
  """
  position: Int = null
}

"""Autogenerated return type of ProposalAddRecurringServiceGroup."""
type ProposalAddRecurringServiceGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  serviceGroup: ServiceGroup
}

"""Autogenerated input type of ProposalAddServiceGroup"""
input ProposalAddServiceGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """the slug of the project to add the service group to"""
  projectId: ID!

  """
  Position for new service groups is automatically assigned. Use ProposalMoveServiceGroup to change position after creation.
  """
  position: Int = null

  """
  optional schedules to configure future billings. if not specified, a single on
  acceptance schedule will be assumed as a reasonable default
  """
  billingSchedules: [BillingScheduleInputType!] = null

  """
  the frontend billing mode to store for future display purposes. required if `billing_schedules` is present.
  """
  billingMode: ProposalBillingModeEnum = null
}

"""Autogenerated return type of ProposalAddServiceGroup."""
type ProposalAddServiceGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  serviceGroup: ServiceGroup
}

"""Autogenerated input type of proposalAddWorkflowStrategy"""
input proposalAddWorkflowStrategyInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """The workflow app this workflow will be deployed to."""
  appName: String
}

"""Autogenerated return type of proposalAddWorkflowStrategy."""
type proposalAddWorkflowStrategyPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalAddWorkflowStrategyStaff"""
input proposalAddWorkflowStrategyStaffInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!

  """Staff ID"""
  userId: ID!
}

"""Autogenerated return type of proposalAddWorkflowStrategyStaff."""
type proposalAddWorkflowStrategyStaffPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalAddWorkflowStrategyTemplate"""
input proposalAddWorkflowStrategyTemplateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!

  """Workflow Template ID"""
  templateId: ID!
}

"""Autogenerated return type of proposalAddWorkflowStrategyTemplate."""
type proposalAddWorkflowStrategyTemplatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalArchive"""
input proposalArchiveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
}

"""Autogenerated return type of proposalArchive."""
type proposalArchivePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal!
}

type ProposalBillingGroup {
  """
  The billing reference will be applied to invoices raised with this billing group.
  """
  billingReference: String!
  id: ID!

  """Name of billing group."""
  name: String!

  """Source of billing group"""
  source: ProposalBillingGroupSource

  """The type of this billing group."""
  type: ProposalBillingGroupType!
}

enum ProposalBillingGroupedBy {
  """
  Services from this proposal may be billed together with services from this client's other proposals.
  """
  CLIENT

  """
  Services from this proposal will be billed separately from this client's other
  proposals, but services from different projects may be billed together.
  """
  PROPOSAL

  """
  Services from this proposal will be billed separately for each project, and
  will not be combined with services from other proposals or projects.
  """
  PROJECT
}

union ProposalBillingGroupSource = Client | Project | Proposal

enum ProposalBillingGroupType {
  """Billing Group for Client"""
  CLIENT

  """Billing Group for Proposal"""
  PROPOSAL

  """Billing Group for Proposal Project"""
  PROJECT
}

enum ProposalBillingModeEnum {
  """Bill once"""
  ONCE_OFF

  """Bill recurring"""
  RECURRING

  """Bill with deposit"""
  DEPOSIT
}

interface ProposalBillingScheduleInterface {
  """Description of the billing cadence e.g. 'every month'"""
  cadence: String

  """
  List of past billing dates that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingDates: [Date!]!

  """
  Sum of the value of missed billing items that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingMinimumPrice: Money!

  """
  Sum of the tax of value of missed billing items that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingMinimumPriceTax: Money!

  """
  Sum of the value with tax, of missed billing items that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingMinimumPriceWithTax: Money!

  """
  Subtotal of all service price portions on an individual period of this billing schedule
  """
  catchUpPeriodSubtotal: Money!

  """
  Subtotal of all service price portions taxes on an individual period of this billing schedule
  """
  catchUpPeriodSubtotalTax: Money!
  id: ID!
  name: String
  position: Int!
  proposedServicePortions(filter: ProposedServiceFilter): [Portion!]!
  recurrence: ProposalBillingStrategyType!
  serviceGroup: ServiceGroup!
  start: ProposalStartBillingInterface!
  subtitle: String

  """Subtotal of fixed service price portions on this billing schedule"""
  subtotal: Money!

  """Subtotal of fixed service price portions on this billing schedule"""
  subtotalTax: Money!

  """Subtotal of fixed service price portions on this billing schedule"""
  subtotalWithTax: Money!
  title: String!
}

interface ProposalBillingStrategyInterface {
  """
  List of past billing dates that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingDates: [Date!]!
  createdAt: DateTime!
  description: String! @deprecated(reason: "use serviceGroup.title instead")
  start: ProposalStartBillingInterface!
  type: ProposalBillingStrategyType!
  updatedAt: DateTime!
}

enum ProposalBillingStrategyType {
  ONCE_OFF
  RECURRING
}

"""The connection type for Proposal."""
type ProposalConnection {
  """A list of edges."""
  edges: [ProposalEdge!]!

  """A list of nodes."""
  nodes: [Proposal!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of ProposalCreateBulk"""
input ProposalCreateBulkInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slugs of clients to create proposals for"""
  clientIds: [ID!]!

  """Slug of a custom or provided template"""
  templateId: ID!

  """The name to give the created proposals"""
  name: String!

  """The start type for the proposals"""
  startOn: ProposalStartOn!

  """
  date (ISO Formatted) the proposals start on. Only required when start_on is date
  """
  startDate: Date
}

"""Autogenerated return type of ProposalCreateBulk."""
type ProposalCreateBulkPayload {
  asyncJobGroup: AsyncJobGroup!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ProposalCreate"""
input ProposalCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  clientId: ID
}

"""Autogenerated return type of ProposalCreate."""
type ProposalCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  userErrors: [UserError!]
}

"""Autogenerated input type of ProposalCreateWithDemoClient"""
input ProposalCreateWithDemoClientInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of ProposalCreateWithDemoClient."""
type ProposalCreateWithDemoClientPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  userErrors: [UserError!]
}

"""Autogenerated input type of ProposalCreateWithPlaceholderClient"""
input ProposalCreateWithPlaceholderClientInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Optional template slug"""
  templateId: ID
}

"""Autogenerated return type of ProposalCreateWithPlaceholderClient."""
type ProposalCreateWithPlaceholderClientPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  userErrors: [UserError!]
}

type ProposalCustomTemplate {
  """creator of template"""
  creator: User!
  description: String
  id: ID!

  """time template was last updated"""
  lastUpdatedAt: DateTime!
  name: String!

  """Recent proposals created using this template by the practice"""
  proposals(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ProposalConnection!
  reference: ID!

  """The template's visibility"""
  visibility: TemplateVisibility!
}

"""The connection type for ProposalCustomTemplate."""
type ProposalCustomTemplateConnection {
  """A list of edges."""
  edges: [ProposalCustomTemplateEdge!]!

  """A list of nodes."""
  nodes: [ProposalCustomTemplate!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of ProposalCustomTemplateCreateFromProposal"""
input ProposalCustomTemplateCreateFromProposalInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Proposal"""
  proposalId: ID!

  """name of custom template"""
  name: String!

  """description of custom template"""
  description: String!
}

"""Autogenerated return type of ProposalCustomTemplateCreateFromProposal."""
type ProposalCustomTemplateCreateFromProposalPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customTemplate: ProposalCustomTemplate
  proposalCustomTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ProposalCustomTemplateConnection
}

"""Autogenerated input type of ProposalCustomTemplateDelete"""
input ProposalCustomTemplateDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Custom Template"""
  id: ID!
}

"""Autogenerated return type of ProposalCustomTemplateDelete."""
type ProposalCustomTemplateDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ProposalCustomTemplateConnection
}

"""An edge in a connection."""
type ProposalCustomTemplateEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ProposalCustomTemplate!
}

"""Autogenerated input type of ProposalCustomTemplatePreview"""
input ProposalCustomTemplatePreviewInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Custom Template"""
  id: ID!
}

"""Autogenerated return type of ProposalCustomTemplatePreview."""
type ProposalCustomTemplatePreviewPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalCustomTemplateReplace"""
input ProposalCustomTemplateReplaceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Custom Template"""
  id: ID!

  """Slug of Proposal"""
  proposalId: ID!

  """name of custom template"""
  name: String!

  """description of custom template"""
  description: String!
}

"""Autogenerated return type of ProposalCustomTemplateReplace."""
type ProposalCustomTemplateReplacePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customTemplate: ProposalCustomTemplate
}

"""Autogenerated input type of proposalDuplicate"""
input proposalDuplicateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
}

"""Autogenerated return type of proposalDuplicate."""
type proposalDuplicatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalDuplicateProject"""
input ProposalDuplicateProjectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the project to duplicate"""
  projectId: ID!
}

"""Autogenerated return type of ProposalDuplicateProject."""
type ProposalDuplicateProjectPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  option: ProposalOption
  project: Project
  proposal: Proposal
}

"""Autogenerated input type of ProposalDuplicateProposedService"""
input ProposalDuplicateProposedServiceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service to duplicate"""
  proposedServiceId: ID!
}

"""Autogenerated return type of ProposalDuplicateProposedService."""
type ProposalDuplicateProposedServicePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
  serviceGroup: ServiceGroup
}

"""Autogenerated input type of ProposalDuplicateServiceGroup"""
input ProposalDuplicateServiceGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the service group to duplicate"""
  serviceGroupId: ID!
}

"""Autogenerated return type of ProposalDuplicateServiceGroup."""
type ProposalDuplicateServiceGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  project: Project
  proposal: Proposal
  serviceGroup: ServiceGroup
}

"""An edge in a connection."""
type ProposalEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Proposal!
}

input ProposalFilter {
  stateNotIn: [ProposalState!]
  stateIn: [ProposalState!]
  clientIdEq: ID
}

type ProposalFixedPrice implements ProposalPriceInterface {
  """Amount excluding tax"""
  amount: Money!

  """
  Amount including tax. This is calculated using the tax type set on the proposed service.
  """
  amountWithTax: Money!
  currency: Currency!

  """Price display without tax"""
  display: String!

  """Total Price display without tax"""
  displayTotalAmount: String!

  """Total Price display with tax"""
  displayTotalAmountWithTax: String!

  """Price display with tax"""
  displayWithTax: String!
  invoiceStrategy: ProposalInvoiceStrategy!
  quantity: Decimal! @deprecated(reason: "Use quantity next to price, not in the price")
  taxDisplay: String

  """fixed price amount multiplied by the quantity"""
  total: Money!

  """Total Amount excluding tax"""
  totalAmount: Money!

  """
  Total Amount including tax. This is calculated using the tax type set on the proposed service.
  """
  totalAmountWithTax: Money!
  type: ProposalPriceType!
}

type ProposalIncludedPrice implements ProposalPriceInterface {
  currency: Currency!

  """Price display without tax"""
  display: String!

  """Price display with tax"""
  displayWithTax: String!
  quantity: Decimal! @deprecated(reason: "Use quantity next to price, not in the price")
  taxDisplay: String
  type: ProposalPriceType!
}

"""Autogenerated input type of proposalIncreaseServicePrices"""
input proposalIncreaseServicePricesInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal to increase prices of"""
  id: ID!
  priceIncreaseInput: PriceIncreaseInputType!
}

"""Autogenerated return type of proposalIncreaseServicePrices."""
type proposalIncreaseServicePricesPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""
Preview increasing service prices of a proposal.
          Also returns warnings to be shown to user before increase is applied, e.g.
          rounding causing a service price to decrease.
"""
type ProposalIncreaseServicePricesPreview {
  optionPriceIncreases: [ProposalIncreaseServicePricesPreviewOption!]!
  percentage: Percentage!
  proposalId: ID!
  roundToNearest: Int
}

"""Preview of a price increase for an option"""
type ProposalIncreaseServicePricesPreviewOption {
  minimumContractValue: Money!
  minimumContractValueDelta: Money!
  minimumContractValueDeltaPercentage: Float!
  minimumValue: Float! @deprecated(reason: "use the minimumContractValue fields instead")
  minimumValueDelta: Float! @deprecated(reason: "use the minimumContractValue fields instead")
  minimumValueDeltaPercentage: Float! @deprecated(reason: "use the minimumContractValue fields instead")
  option: ProposalOption!
  warnings: [ProposalProposalIncreaseServicePricesWarning!]!
}

enum ProposalInvoiceStrategy {
  AUTOMATIC
  MANUAL
}

"""Autogenerated input type of proposalMarkAsLost"""
input proposalMarkAsLostInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
}

"""Autogenerated return type of proposalMarkAsLost."""
type proposalMarkAsLostPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal!
}

type ProposalMinimumPrice implements ProposalPriceInterface {
  """Amount excluding tax"""
  amount: Money!

  """
  Amount including tax. This is calculated using the tax type set on the proposed service.
  """
  amountWithTax: Money!
  currency: Currency!

  """Price display without tax"""
  display: String!

  """Price display with tax"""
  displayWithTax: String!
  taxDisplay: String
  type: ProposalPriceType!
}

"""Autogenerated input type of ProposalMoveOption"""
input ProposalMoveOptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the option to move"""
  optionId: ID!
  position: Int!
}

"""Autogenerated return type of ProposalMoveOption."""
type ProposalMoveOptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  option: ProposalOption
  proposal: Proposal
}

"""Autogenerated input type of ProposalMoveProject"""
input ProposalMoveProjectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the project to move"""
  projectId: ID!
  position: Int!
}

"""Autogenerated return type of ProposalMoveProject."""
type ProposalMoveProjectPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  option: ProposalOption
  proposal: Proposal
}

"""Autogenerated input type of ProposalMoveProposedService"""
input ProposalMoveProposedServiceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service to move"""
  proposedServiceId: ID!

  """uuid of the service group to move proposed service to"""
  serviceGroupId: ID!
  position: Int!
}

"""Autogenerated return type of ProposalMoveProposedService."""
type ProposalMoveProposedServicePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  serviceGroup: ServiceGroup
}

"""Autogenerated input type of ProposalMoveServiceGroup"""
input ProposalMoveServiceGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the service group to move"""
  serviceGroupId: ID!

  """slug of the project to move the service group to"""
  projectId: ID!

  """Optionally specify a new position."""
  position: Int
}

"""Autogenerated return type of ProposalMoveServiceGroup."""
type ProposalMoveServiceGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  project: Project
  proposal: Proposal
}

"""Autogenerated input type of ProposalMoveToAwaitingAcceptance"""
input ProposalMoveToAwaitingAcceptanceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """send proposal to client or not"""
  sendToClient: Boolean
}

"""Autogenerated return type of ProposalMoveToAwaitingAcceptance."""
type ProposalMoveToAwaitingAcceptancePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

type ProposalOnceOffBillingSchedule implements ProposalBillingScheduleInterface {
  """Description of the billing cadence e.g. 'every month'"""
  cadence: String

  """
  List of past billing dates that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingDates: [Date!]!

  """
  Sum of the value of missed billing items that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingMinimumPrice: Money!

  """
  Sum of the tax of value of missed billing items that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingMinimumPriceTax: Money!

  """
  Sum of the value with tax, of missed billing items that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingMinimumPriceWithTax: Money!

  """
  Subtotal of all service price portions on an individual period of this billing schedule
  """
  catchUpPeriodSubtotal: Money!

  """
  Subtotal of all service price portions taxes on an individual period of this billing schedule
  """
  catchUpPeriodSubtotalTax: Money!
  id: ID!
  name: String
  position: Int!
  proposedServicePortions(filter: ProposedServiceFilter): [Portion!]!
  recurrence: ProposalBillingStrategyType!
  serviceGroup: ServiceGroup!
  start: ProposalStartBillingInterface!
  subtitle: String

  """Subtotal of fixed service price portions on this billing schedule"""
  subtotal: Money!

  """Subtotal of fixed service price portions on this billing schedule"""
  subtotalTax: Money!

  """Subtotal of fixed service price portions on this billing schedule"""
  subtotalWithTax: Money!
  title: String!
}

type ProposalOnceOffBillingStrategy implements ProposalBillingStrategyInterface {
  """
  List of past billing dates that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingDates: [Date!]!
  createdAt: DateTime!
  description: String! @deprecated(reason: "use serviceGroup.title instead")
  start: ProposalStartBillingInterface!
  type: ProposalBillingStrategyType!
  updatedAt: DateTime!
}

enum ProposalOneTimeDateDisplay {
  SHOW
  HIDE
}

type ProposalOption {
  createdAt: DateTime!
  description: String!
  id: ID!
  isRecommended: Boolean!
  minimumContractValue: Money!
  minimumContractValueTaxAmount: Money!
  minimumContractValueWithTax: Money!
  name: String!
  position: Int!
  projects: [Project!]!
  proposal: Proposal!
  serviceTerms: Textile
  updatedAt: DateTime!
}

"""Autogenerated input type of proposalOptionDuplicate"""
input proposalOptionDuplicateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the option to duplicate"""
  optionId: ID!
}

"""Autogenerated return type of proposalOptionDuplicate."""
type proposalOptionDuplicatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """the copy of option"""
  option: ProposalOption
  proposal: Proposal!
}

"""Autogenerated input type of ProposalOptionSetDescription"""
input ProposalOptionSetDescriptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Proposal"""
  id: ID!

  """Slug of the option to move"""
  optionId: ID!
  description: String!
}

"""Autogenerated return type of ProposalOptionSetDescription."""
type ProposalOptionSetDescriptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  option: ProposalOption
  proposal: Proposal
}

"""Autogenerated input type of ProposalOptionSetName"""
input ProposalOptionSetNameInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Proposal"""
  id: ID!

  """Slug of the option to move"""
  optionId: ID!
  name: String!
}

"""Autogenerated return type of ProposalOptionSetName."""
type ProposalOptionSetNamePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  option: ProposalOption
  proposal: Proposal
}

interface ProposalPriceInterface {
  currency: Currency!

  """Price display without tax"""
  display: String!

  """Price display with tax"""
  displayWithTax: String!
  taxDisplay: String
  type: ProposalPriceType!
}

type ProposalPriceRange implements ProposalPriceInterface {
  currency: Currency!

  """Price display without tax"""
  display: String!

  """Price display with tax"""
  displayWithTax: String!
  max: Money!
  min: Money!
  taxDisplay: String
  type: ProposalPriceType!
}

enum ProposalPriceType {
  FIXED
  HOURLY
  INCLUDED
  MINIMUM
  UNIT
  RANGE
}

enum ProposalProposalIncreaseServicePricesWarning {
  CONTAINS_NEGATIVE_INCREASE
  ABOVE_THRESHOLD_EFFECTIVE_PERCENTAGE_INCREASE
}

type ProposalProposedServiceDescription {
  """The type of content being rendered"""
  contentType: userContentType!
  html: Html

  """Available placeholders for terms messages"""
  placeholders: [Placeholder!]!

  """Preview HTML"""
  previewHtml(content: String): String!
}

type ProposalProvidedTemplate {
  """The organization or group the author belongs to"""
  authorEntity: String

  """The logo of the author entity"""
  authorLogoUrl: String

  """The name of author of the template"""
  authorName: String

  """Ignition team member who created the template"""
  creator: AdminUser!
  description: String
  id: ID!

  """time template was last updated"""
  lastUpdatedAt: DateTime

  """Description of provided templates with formatting"""
  longDescription: String
  name: String!

  """Recent proposals created using this template by the practice"""
  proposals(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ProposalConnection!
  sourceLogoUrl: URL!
  sourceName: String!

  """The template's visibility"""
  visibility: TemplateVisibility!
}

"""The connection type for ProposalProvidedTemplate."""
type ProposalProvidedTemplateConnection {
  """A list of edges."""
  edges: [ProposalProvidedTemplateEdge!]!

  """A list of nodes."""
  nodes: [ProposalProvidedTemplate!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ProposalProvidedTemplateEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ProposalProvidedTemplate!
}

type ProposalRecipient {
  acceptUrl: URL!
  acceptUrlShort: ShortURL!
  contact: Contact @deprecated(reason: "Recipients are not linked to contacts since Signatories were introduced (multi-sig)")
  email: EmailAddress
  id: ID!
}

type ProposalRecurringBillingSchedule implements ProposalBillingScheduleInterface {
  """Description of the billing cadence e.g. 'every month'"""
  cadence: String

  """
  List of past billing dates that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingDates: [Date!]!

  """
  Sum of the value of missed billing items that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingMinimumPrice: Money!

  """
  Sum of the tax of value of missed billing items that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingMinimumPriceTax: Money!

  """
  Sum of the value with tax, of missed billing items that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingMinimumPriceWithTax: Money!

  """
  Subtotal of all service price portions on an individual period of this billing schedule
  """
  catchUpPeriodSubtotal: Money!

  """
  Subtotal of all service price portions taxes on an individual period of this billing schedule
  """
  catchUpPeriodSubtotalTax: Money!
  id: ID!
  name: String
  position: Int!
  proposedServicePortions(filter: ProposedServiceFilter): [Portion!]!
  recurrence: ProposalBillingStrategyType!
  rule: RecurrenceRule!
  serviceGroup: ServiceGroup!
  start: ProposalStartBillingInterface!
  subtitle: String

  """Subtotal of fixed service price portions on this billing schedule"""
  subtotal: Money!

  """Subtotal of fixed service price portions on this billing schedule"""
  subtotalTax: Money!

  """Subtotal of fixed service price portions on this billing schedule"""
  subtotalWithTax: Money!
  title: String!
}

type ProposalRecurringBillingStrategy implements ProposalBillingStrategyInterface {
  """
  List of past billing dates that will apply as soon as proposal is accepted or completed
  """
  catchUpBillingDates: [Date!]!
  createdAt: DateTime!
  description: String! @deprecated(reason: "use serviceGroup.title instead")
  rule: RecurrenceRule!
  start: ProposalStartBillingInterface!
  type: ProposalBillingStrategyType!
  updatedAt: DateTime!
}

"""
Autogenerated input type of ProposalRefreshProposedServiceSmartQuantity
"""
input ProposalRefreshProposedServiceSmartQuantityInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service"""
  proposedServiceId: ID!
}

"""
Autogenerated return type of ProposalRefreshProposedServiceSmartQuantity.
"""
type ProposalRefreshProposedServiceSmartQuantityPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalRemoveOption"""
input ProposalRemoveOptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the option to remove"""
  optionId: ID!
}

"""Autogenerated return type of ProposalRemoveOption."""
type ProposalRemoveOptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalRemoveProject"""
input ProposalRemoveProjectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the project to remove"""
  projectId: ID!
}

"""Autogenerated return type of ProposalRemoveProject."""
type ProposalRemoveProjectPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  option: ProposalOption
  proposal: Proposal
}

"""Autogenerated input type of ProposalRemoveProposedService"""
input ProposalRemoveProposedServiceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service to remove"""
  proposedServiceId: ID!
}

"""Autogenerated return type of ProposalRemoveProposedService."""
type ProposalRemoveProposedServicePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  serviceGroup: ServiceGroup
}

"""Autogenerated input type of ProposalRemoveRecipient"""
input ProposalRemoveRecipientInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """proposal slug"""
  id: ID!

  """recipient slug"""
  recipientId: ID!
}

"""Autogenerated return type of ProposalRemoveRecipient."""
type ProposalRemoveRecipientPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  recipient: ProposalRecipient
}

"""Autogenerated input type of ProposalRemoveServiceGroup"""
input ProposalRemoveServiceGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the service group to remove"""
  serviceGroupId: ID!
}

"""Autogenerated return type of ProposalRemoveServiceGroup."""
type ProposalRemoveServiceGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  project: Project
  proposal: Proposal
}

"""Autogenerated input type of proposalRemoveWorkflowStrategy"""
input proposalRemoveWorkflowStrategyInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
}

"""Autogenerated return type of proposalRemoveWorkflowStrategy."""
type proposalRemoveWorkflowStrategyPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of proposalRemoveWorkflowStrategyStaff"""
input proposalRemoveWorkflowStrategyStaffInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!

  """Staff ID"""
  userId: ID!
}

"""Autogenerated return type of proposalRemoveWorkflowStrategyStaff."""
type proposalRemoveWorkflowStrategyStaffPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalRemoveWorkflowStrategyTemplate"""
input proposalRemoveWorkflowStrategyTemplateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!

  """Template id"""
  templateId: ID!
}

"""Autogenerated return type of proposalRemoveWorkflowStrategyTemplate."""
type proposalRemoveWorkflowStrategyTemplatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalRenewBulk"""
input proposalRenewBulkInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slugs of the proposals to renew"""
  ids: [ID!]!
}

"""Autogenerated return type of proposalRenewBulk."""
type proposalRenewBulkPayload {
  asyncJobGroup: AsyncJobGroup!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of proposalRenew"""
input proposalRenewInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal to be renewed"""
  id: ID!
}

"""Autogenerated return type of proposalRenew."""
type proposalRenewPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalResetOption"""
input ProposalResetOptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the option to reset"""
  optionId: ID!
}

"""Autogenerated return type of ProposalResetOption."""
type ProposalResetOptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  option: ProposalOption
  proposal: Proposal
}

"""Autogenerated input type of ProposalResetProject"""
input ProposalResetProjectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the project to reset"""
  projectId: ID!
}

"""Autogenerated return type of ProposalResetProject."""
type ProposalResetProjectPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  project: Project
  proposal: Proposal
}

type ProposalResult {
  acceptedBy: String
  acceptedOn: Date
  activeServiceCount: Int!
  client: ClientResult!
  clientSlug: String!
  completedOn: Date
  createdAt: DateTime!
  createdOn: Date!
  creator: String!
  currency: String!
  effectiveStartDate: Date
  emailOpenedByClientOn: Date
  emailTemplate: String
  expiryDate: Date
  hasEverBeenAwaitingAcceptance: Boolean!
  id: ID!
  indefiniteBilling: Boolean!
  isImportedFromLedger: Boolean!
  isRenewable: Boolean!
  isRenewed: Boolean!
  lostBy: String
  lostOn: Date
  minimumTerm: Int!

  """The proposal minimum contract value"""
  minimumValue: Money!

  """The minimum value to be taken by automatic billings"""
  minimumValueAuto: Money!
  minimumValueAutoCents: BigInt! @deprecated(reason: "Use the Money typed minimumValueAuto field instead")
  minimumValueCents: BigInt! @deprecated(reason: "Use the Money typed minimumValue field instead")

  """The minimum value to be taken by manual billings"""
  minimumValueManual: Money!
  minimumValueManualCents: BigInt! @deprecated(reason: "Use the Money typed minimumValueManual field instead")
  mostRecentActivityCause: String

  """If present, the most recent activity had an error"""
  mostRecentActivityError: String
  mostRecentActivityOn: Date
  name: String!
  optionsCount: Int!
  paymentRequired: Boolean!
  paymentType: String!
  paymentsEnabled: Boolean!
  proposal: Proposal!
  referenceNumber: String
  remindersSentCount: Int!
  renewal: Boolean!
  reviewAssignee: String
  reviewAssigneeSlug: String
  reviewState: ProposalReviewState
  sentBy: String
  sentCount: Int!
  sentOn: String
  serviceNames: String!
  signatoriesCount: Int!
  signedOnBehalf: Boolean!
  signedOnBehalfBy: String
  status: ProposalState!
  termsTemplate: String
  text: String!
  unrenewableReason: String
  updatedAt: DateTime!
  viewedByClient: Boolean!
  viewedByClientOn: Date
}

"""Autogenerated input type of ProposalReviewApprove"""
input ProposalReviewApproveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  assigneeId: ID
  notes: String
}

"""Autogenerated return type of ProposalReviewApprove."""
type ProposalReviewApprovePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal!
}

"""Autogenerated input type of ProposalReviewRequestChange"""
input ProposalReviewRequestChangeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  assigneeId: ID
  notes: String
}

"""Autogenerated return type of ProposalReviewRequestChange."""
type ProposalReviewRequestChangePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal!
}

"""Autogenerated input type of ProposalReviewRequestReview"""
input ProposalReviewRequestReviewInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  assigneeId: ID
  notes: String
}

"""Autogenerated return type of ProposalReviewRequestReview."""
type ProposalReviewRequestReviewPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal!
}

enum ProposalReviewState {
  NOT_IN_REVIEW
  REVIEW_REQUESTED
  CHANGE_REQUESTED
  APPROVED
}

"""Autogenerated input type of proposalRevoke"""
input proposalRevokeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
}

"""Autogenerated return type of proposalRevoke."""
type proposalRevokePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal!
}

"""Autogenerated input type of ProposalSave"""
input ProposalSaveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
}

"""Autogenerated return type of ProposalSave."""
type ProposalSavePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""
Autogenerated input type of ProposalsBulkCreateFromRecurringTransactions
"""
input ProposalsBulkCreateFromRecurringTransactionsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slugs of the recurring transactions to convert"""
  ids: [ID!]!
}

"""
Autogenerated return type of ProposalsBulkCreateFromRecurringTransactions.
"""
type ProposalsBulkCreateFromRecurringTransactionsPayload {
  asyncJobGroup: AsyncJobGroup!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ProposalsBulkCreateFromRepeatingInvoices"""
input ProposalsBulkCreateFromRepeatingInvoicesInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slugs of the repeating invoices to convert"""
  ids: [ID!]!
}

"""Autogenerated return type of ProposalsBulkCreateFromRepeatingInvoices."""
type ProposalsBulkCreateFromRepeatingInvoicesPayload {
  asyncJobGroup: AsyncJobGroup!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of proposalSendToClientBulk"""
input proposalSendToClientBulkInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slugs of the proposals to send"""
  ids: [ID!]!
}

"""Autogenerated return type of proposalSendToClientBulk."""
type proposalSendToClientBulkPayload {
  asyncJobGroup: AsyncJobGroup!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ProposalSendToClient"""
input ProposalSendToClientInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
}

"""Autogenerated return type of ProposalSendToClient."""
type ProposalSendToClientPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSendToSignatory"""
input ProposalSendToSignatoryInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the signatory"""
  signatoryId: ID!
}

"""Autogenerated return type of ProposalSendToSignatory."""
type ProposalSendToSignatoryPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  signatory: ProposalSignatory
}

enum ProposalServicePriceDisplay {
  SHOW
  HIDE
}

type ProposalServiceTerms {
  """The type of content being rendered"""
  contentType: userContentType!
  html: Html

  """Available placeholders for terms messages"""
  placeholders: [Placeholder!]!

  """Preview HTML"""
  previewHtml(content: String): String!

  """The unrendered template"""
  template: TermsTemplate
}

"""Autogenerated input type of ProposalSetBillingGroupedBy"""
input ProposalSetBillingGroupedByInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of the proposal"""
  id: ID!
  billingGroupedBy: ProposalBillingGroupedBy!
}

"""Autogenerated return type of ProposalSetBillingGroupedBy."""
type ProposalSetBillingGroupedByPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetBrochure"""
input ProposalSetBrochureInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of Proposal"""
  id: ID!

  """Brochure slug"""
  brochureId: ID!
}

"""Autogenerated return type of ProposalSetBrochure."""
type ProposalSetBrochurePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetClient"""
input ProposalSetClientInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of Proposal"""
  id: ID!

  """ID of client"""
  clientId: ID!
}

"""Autogenerated return type of ProposalSetClient."""
type ProposalSetClientPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal

  """Expect validation errors such as 'lock version mismatch'"""
  userErrors: [UserError!]
}

"""Autogenerated input type of ProposalSetEmailTemplate"""
input ProposalSetEmailTemplateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the email template"""
  templateId: ID!
}

"""Autogenerated return type of ProposalSetEmailTemplate."""
type ProposalSetEmailTemplatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetMinimumContractLength"""
input ProposalSetMinimumContractLengthInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """minimum length of the proposed contract in months"""
  months: Int!
}

"""Autogenerated return type of ProposalSetMinimumContractLength."""
type ProposalSetMinimumContractLengthPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetName"""
input ProposalSetNameInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of Proposal"""
  id: ID!
  name: String!
}

"""Autogenerated return type of ProposalSetName."""
type ProposalSetNamePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal

  """
  Expect validation errors such as 'lock version mismatch' or 'name too long (255 chars max)'
  """
  userErrors: [UserError!]
}

"""Autogenerated input type of ProposalSetNextStepsMessage"""
input ProposalSetNextStepsMessageInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
  message: RichText
  htmlMessage: Html
}

"""Autogenerated return type of ProposalSetNextStepsMessage."""
type ProposalSetNextStepsMessagePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetOneTimeDateDisplay"""
input ProposalSetOneTimeDateDisplayInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """how one time date proposals should be displayed"""
  oneTimeDateDisplay: ProposalOneTimeDateDisplay!
}

"""Autogenerated return type of ProposalSetOneTimeDateDisplay."""
type ProposalSetOneTimeDateDisplayPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetPaymentSettings"""
input ProposalSetPaymentSettingsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Proposal"""
  id: ID!
  creditCardAccepted: Boolean!
  directDebitAccepted: Boolean!
  paymentMethodRequired: Boolean!
}

"""Autogenerated return type of ProposalSetPaymentSettings."""
type ProposalSetPaymentSettingsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetPersonalisedMessage"""
input ProposalSetPersonalisedMessageInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
  message: RichText
  htmlMessage: Html
}

"""Autogenerated return type of ProposalSetPersonalisedMessage."""
type ProposalSetPersonalisedMessagePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetPostAcceptanceVideo"""
input ProposalSetPostAcceptanceVideoInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!
  videoUrl: String!
}

"""Autogenerated return type of ProposalSetPostAcceptanceVideo."""
type ProposalSetPostAcceptanceVideoPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetPracticeAsSender"""
input ProposalSetPracticeAsSenderInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
}

"""Autogenerated return type of ProposalSetPracticeAsSender."""
type ProposalSetPracticeAsSenderPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetPreAcceptanceVideo"""
input ProposalSetPreAcceptanceVideoInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!
  videoUrl: String!
}

"""Autogenerated return type of ProposalSetPreAcceptanceVideo."""
type ProposalSetPreAcceptanceVideoPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetProjectDescription"""
input ProposalSetProjectDescriptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the project to set the description of"""
  projectId: ID!
  description: String!
}

"""Autogenerated return type of ProposalSetProjectDescription."""
type ProposalSetProjectDescriptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  project: Project
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetProjectName"""
input ProposalSetProjectNameInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the project to set the graphql_name of"""
  projectId: ID!
  name: String!
}

"""Autogenerated return type of ProposalSetProjectName."""
type ProposalSetProjectNamePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  project: Project
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetProposalValueDisplay"""
input ProposalSetProposalValueDisplayInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
  valueDisplay: ProposalValueDisplay!
}

"""Autogenerated return type of ProposalSetProposalValueDisplay."""
type ProposalSetProposalValueDisplayPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetProposedServiceAccount"""
input ProposalSetProposedServiceAccountInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service to set account for"""
  proposedServiceId: ID!

  """uuid/slug of the account to set"""
  accountId: ID!
}

"""Autogenerated return type of ProposalSetProposedServiceAccount."""
type ProposalSetProposedServiceAccountPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalSetProposedServiceDescription"""
input ProposalSetProposedServiceDescriptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service"""
  proposedServiceId: ID!
  description: Html!
}

"""Autogenerated return type of ProposalSetProposedServiceDescription."""
type ProposalSetProposedServiceDescriptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalSetProposedServiceFixedPrice"""
input ProposalSetProposedServiceFixedPriceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service"""
  proposedServiceId: ID!
  amount: MoneyInput!
  invoiceStrategy: ProposalInvoiceStrategy!
}

"""Autogenerated return type of ProposalSetProposedServiceFixedPrice."""
type ProposalSetProposedServiceFixedPricePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalSetProposedServiceIncludedPrice"""
input ProposalSetProposedServiceIncludedPriceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service"""
  proposedServiceId: ID!
}

"""Autogenerated return type of ProposalSetProposedServiceIncludedPrice."""
type ProposalSetProposedServiceIncludedPricePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalSetProposedServiceMinimumPrice"""
input ProposalSetProposedServiceMinimumPriceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """proposal slug"""
  id: ID!

  """proposed service slug"""
  proposedServiceId: ID!
  amount: MoneyInput!
}

"""Autogenerated return type of ProposalSetProposedServiceMinimumPrice."""
type ProposalSetProposedServiceMinimumPricePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""
Autogenerated input type of ProposalSetProposedServicePortionInvoiceStrategy
"""
input ProposalSetProposedServicePortionInvoiceStrategyInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the proposed service"""
  proposedServiceId: ID!

  """slug of the portion"""
  portionId: ID!
  invoiceStrategy: ProposalInvoiceStrategy!
}

"""
Autogenerated return type of ProposalSetProposedServicePortionInvoiceStrategy.
"""
type ProposalSetProposedServicePortionInvoiceStrategyPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  portion: Portion
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetProposedServicePortionPrice"""
input ProposalSetProposedServicePortionPriceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """slug of the proposed service"""
  proposedServiceId: ID!

  """slug of the portion"""
  portionId: ID!
  amount: MoneyInput!
}

"""Autogenerated return type of ProposalSetProposedServicePortionPrice."""
type ProposalSetProposedServicePortionPricePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  portion: Portion
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalSetProposedServicePriceRange"""
input ProposalSetProposedServicePriceRangeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service"""
  proposedServiceId: ID!
  min: MoneyInput!
  max: MoneyInput!
}

"""Autogenerated return type of ProposalSetProposedServicePriceRange."""
type ProposalSetProposedServicePriceRangePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalSetProposedServiceQuantityRule"""
input ProposalSetProposedServiceQuantityRuleInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service"""
  proposedServiceId: ID!

  """Quantity rule"""
  quantityRule: QuantityRuleInput!
}

"""Autogenerated return type of ProposalSetProposedServiceQuantityRule."""
type ProposalSetProposedServiceQuantityRulePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalSetProposedServiceTaxExempt"""
input ProposalSetProposedServiceTaxExemptInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service"""
  proposedServiceId: ID!

  """tax exempt flag"""
  taxExempt: Boolean!
}

"""Autogenerated return type of ProposalSetProposedServiceTaxExempt."""
type ProposalSetProposedServiceTaxExemptPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalSetProposedServiceTax"""
input ProposalSetProposedServiceTaxInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service"""
  proposedServiceId: ID!

  """uuid of the tax type"""
  taxId: ID!
}

"""Autogenerated return type of ProposalSetProposedServiceTax."""
type ProposalSetProposedServiceTaxPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalSetProposedServiceUnitPrice"""
input ProposalSetProposedServiceUnitPriceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the proposed service"""
  proposedServiceId: ID!
  unitName: String!
  amount: MoneyInput!
  invoiceStrategy: ProposalInvoiceStrategy
}

"""Autogenerated return type of ProposalSetProposedServiceUnitPrice."""
type ProposalSetProposedServiceUnitPricePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

"""Autogenerated input type of ProposalSetRecommendedOption"""
input ProposalSetRecommendedOptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Proposal"""
  id: ID!

  """Slug of the recommending option"""
  optionId: ID!
}

"""Autogenerated return type of ProposalSetRecommendedOption."""
type ProposalSetRecommendedOptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetServiceGroupBillingSchedules"""
input ProposalSetServiceGroupBillingSchedulesInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the service group to set billing rules for"""
  serviceGroupId: ID!

  """the frontend billing mode to store for future display purposes"""
  billingMode: ProposalBillingModeEnum!
  billingSchedules: [BillingScheduleInputType!]!
}

"""Autogenerated return type of ProposalSetServiceGroupBillingSchedules."""
type ProposalSetServiceGroupBillingSchedulesPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  serviceGroup: ServiceGroup
}

"""Autogenerated input type of ProposalSetServicePriceDisplay"""
input ProposalSetServicePriceDisplayInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """how service prices should be displayed"""
  priceDisplay: ProposalServicePriceDisplay!
}

"""Autogenerated return type of ProposalSetServicePriceDisplay."""
type ProposalSetServicePriceDisplayPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetSignatories"""
input ProposalSetSignatoriesInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """proposal id"""
  id: ID!

  """id of contact to set as the primary signatory"""
  primarySignatoryContactId: ID!

  """id of contacts to set as secondary signatories"""
  secondarySignatoryContactIds: [ID!]
}

"""Autogenerated return type of ProposalSetSignatories."""
type ProposalSetSignatoriesPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetTax"""
input ProposalSetTaxInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of Proposal"""
  id: ID!

  """UUID of the tax"""
  taxId: ID!
}

"""Autogenerated return type of ProposalSetTax."""
type ProposalSetTaxPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal

  """Expect validation errors such as 'lock version mismatch'"""
  userErrors: [UserError!]
}

"""Autogenerated input type of ProposalSetTermsTemplate"""
input ProposalSetTermsTemplateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the terms template"""
  templateId: ID!
}

"""Autogenerated return type of ProposalSetTermsTemplate."""
type ProposalSetTermsTemplatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalSetUserAsSender"""
input ProposalSetUserAsSenderInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """uuid of the sender user"""
  userId: ID!
}

"""Autogenerated return type of ProposalSetUserAsSender."""
type ProposalSetUserAsSenderPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of proposalSetWorkflowStrategyBudget"""
input proposalSetWorkflowStrategyBudgetInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
  budget: MoneyInput!
}

"""Autogenerated return type of proposalSetWorkflowStrategyBudget."""
type proposalSetWorkflowStrategyBudgetPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalSetWorkflowStrategyCategories"""
input proposalSetWorkflowStrategyCategoriesInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!

  """IDs of the workflow categories"""
  categoryIds: [ID!]!
}

"""Autogenerated return type of proposalSetWorkflowStrategyCategories."""
type proposalSetWorkflowStrategyCategoriesPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalSetWorkflowStrategyDescription"""
input proposalSetWorkflowStrategyDescriptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
  description: String!
}

"""Autogenerated return type of proposalSetWorkflowStrategyDescription."""
type proposalSetWorkflowStrategyDescriptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalSetWorkflowStrategyDuration"""
input proposalSetWorkflowStrategyDurationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
  duration: DurationInput!
}

"""Autogenerated return type of proposalSetWorkflowStrategyDuration."""
type proposalSetWorkflowStrategyDurationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalSetWorkflowStrategyManager"""
input proposalSetWorkflowStrategyManagerInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!

  """ID of the manager user"""
  userId: ID!
}

"""Autogenerated return type of proposalSetWorkflowStrategyManager."""
type proposalSetWorkflowStrategyManagerPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalSetWorkflowStrategyName"""
input proposalSetWorkflowStrategyNameInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
  name: String!
}

"""Autogenerated return type of proposalSetWorkflowStrategyName."""
type proposalSetWorkflowStrategyNamePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalSetWorkflowStrategyPartner"""
input proposalSetWorkflowStrategyPartnerInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!

  """ID of the partner user"""
  userId: ID!
}

"""Autogenerated return type of proposalSetWorkflowStrategyPartner."""
type proposalSetWorkflowStrategyPartnerPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalSetWorkflowStrategyRecurrenceOnce"""
input proposalSetWorkflowStrategyRecurrenceOnceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
}

"""
Autogenerated return type of proposalSetWorkflowStrategyRecurrenceOnce.
"""
type proposalSetWorkflowStrategyRecurrenceOncePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalSetWorkflowStrategyRecurring"""
input proposalSetWorkflowStrategyRecurringInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
  recurrenceRule: RecurrenceRuleInput!
}

"""Autogenerated return type of proposalSetWorkflowStrategyRecurring."""
type proposalSetWorkflowStrategyRecurringPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalSetWorkflowStrategyStartOnDate"""
input proposalSetWorkflowStrategyStartOnDateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!

  """Start on date"""
  date: Date!
}

"""Autogenerated return type of proposalSetWorkflowStrategyStartOnDate."""
type proposalSetWorkflowStrategyStartOnDatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalSetWorkflowStrategyTemplates"""
input proposalSetWorkflowStrategyTemplatesInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!

  """IDs of the workflow templates"""
  templateIds: [ID!]!
}

"""Autogenerated return type of proposalSetWorkflowStrategyTemplates."""
type proposalSetWorkflowStrategyTemplatesPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalsExport"""
input proposalsExportInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """
  If provided, only proposals accepted or lost after this date will not be included.
  """
  startDate: Date

  """
  If provided, only proposals accepted or lost before this date will not be included.
  """
  endDate: Date
}

"""Autogenerated return type of proposalsExport."""
type proposalsExportPayload {
  backgroundJob: BackgroundJob!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

type ProposalSignatory {
  contact: Contact!
  id: ID!

  """Portal proposal url"""
  proposalUrl: URL!

  """Portal proposal short url"""
  proposalUrlShort: ShortURL!
  role: SignatoryRoleEnum!
  signature: ProposalSignature
  state: SignatoryStateEnum!
}

type ProposalSignature {
  id: ID!
  ipAddress: IpAddress!
  location: SignatureLocation
  reason: String

  """Datetime the signatory (or user) signed the proposal"""
  signedAt: DateTime

  """The user who has signed on behalf of a signatory"""
  signedOnBehalfBy: User
  text: String!
  userAgent: String!
}

"""Autogenerated input type of proposalSignOnBehalfForAll"""
input proposalSignOnBehalfForAllInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """id of the proposal"""
  id: ID!

  """reason the contract is being signed on behalf of the signatories"""
  reason: String!

  """payment method id"""
  paymentMethodId: ID
}

"""Autogenerated return type of proposalSignOnBehalfForAll."""
type proposalSignOnBehalfForAllPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal!
}

"""Source a proposal is created from"""
union ProposalSource = Proposal | ProposalCustomTemplate | ProposalProvidedTemplate | QuickbooksIntegrationRecurringTransaction | XeroIntegrationRepeatingInvoice

interface ProposalStartBillingInterface {
  delay: Duration!
  type: ProposalStartBillingType!
}

type ProposalStartBillingOnAcceptance implements ProposalStartBillingInterface {
  delay: Duration!
  type: ProposalStartBillingType!
}

type ProposalStartBillingOnDate implements ProposalStartBillingInterface {
  date: Date!
  delay: Duration!
  type: ProposalStartBillingType!
}

type ProposalStartBillingOnProposalEndDate implements ProposalStartBillingInterface {
  delay: Duration!
  type: ProposalStartBillingType!
}

type ProposalStartBillingOnProposalStartDate implements ProposalStartBillingInterface {
  delay: Duration!
  type: ProposalStartBillingType!
}

enum ProposalStartBillingType {
  """billing occurs based on proposal completion date plus optional delay"""
  ON_PROPOSAL_END_DATE

  """billing occurs based on proposal start date plus optional delay"""
  ON_PROPOSAL_START_DATE

  """billing occurs based on proposal acceptance plus optional delay"""
  ON_ACCEPTANCE

  """billing occurs on a specific date"""
  ON_DATE
}

enum ProposalStartOn {
  ACCEPTANCE
  DATE
}

"""Autogenerated input type of ProposalStartOnAcceptance"""
input ProposalStartOnAcceptanceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
}

"""Autogenerated return type of ProposalStartOnAcceptance."""
type ProposalStartOnAcceptancePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalStartOnDate"""
input ProposalStartOnDateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!

  """date (ISO Formatted) the proposed contract starts on"""
  date: Date!
}

"""Autogenerated return type of ProposalStartOnDate."""
type ProposalStartOnDatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

enum ProposalState {
  NEW
  DRAFT
  LOST
  ARCHIVED
  AWAITING_ACCEPTANCE
  ACCEPTED
  COMPLETED
}

"""Autogenerated input type of ProposalTemplateUse"""
input ProposalTemplateUseInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of template"""
  id: ID!

  """ID of Client"""
  clientId: ID
}

"""Autogenerated return type of ProposalTemplateUse."""
type ProposalTemplateUsePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

type ProposalTerms {
  html: String @deprecated(reason: "Use the safeHtml type instead.")
  safeHtml: Html
  template: TermsTemplate
}

type ProposalTermsMessage {
  """The type of content being rendered"""
  contentType: userContentType!

  """The template rendered in HTML"""
  html: HtmlText @deprecated(reason: "Use the safeHtml field instead.")

  """Available placeholders for terms messages"""
  placeholders: [Placeholder!]!

  """Preview HTML"""
  previewHtml(content: String): String!
  safeHtml: Html

  """The unrendered template"""
  template: TermsTemplate
}

type ProposalUnitPrice implements ProposalPriceInterface {
  """Amount excluding tax"""
  amount: Money!

  """
  Amount including tax. This is calculated using the tax type set on the proposed service.
  """
  amountWithTax: Money!
  currency: Currency!

  """Price display without tax"""
  display: String!

  """Total Price display without tax"""
  displayTotalAmount: String!

  """Total Price display with tax"""
  displayTotalAmountWithTax: String!

  """Price display with tax"""
  displayWithTax: String!
  invoiceStrategy: ProposalInvoiceStrategy!
  name: String!
  quantity: Decimal! @deprecated(reason: "Use quantity next to price, not in the price")
  taxDisplay: String

  """Total Amount excluding tax"""
  totalAmount: Money!

  """
  Total Amount including tax. This is calculated using the tax type set on the proposed service.
  """
  totalAmountWithTax: Money!
  type: ProposalPriceType!
}

"""Autogenerated input type of ProposalUnsetBrochure"""
input ProposalUnsetBrochureInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of Proposal"""
  id: ID!
}

"""Autogenerated return type of ProposalUnsetBrochure."""
type ProposalUnsetBrochurePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalUnsetRecommendedOption"""
input ProposalUnsetRecommendedOptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of Proposal"""
  id: ID!
}

"""Autogenerated return type of ProposalUnsetRecommendedOption."""
type ProposalUnsetRecommendedOptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of proposalUnsetWorkflowStrategyManager"""
input proposalUnsetWorkflowStrategyManagerInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
}

"""Autogenerated return type of proposalUnsetWorkflowStrategyManager."""
type proposalUnsetWorkflowStrategyManagerPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalUnsetWorkflowStrategyPartner"""
input proposalUnsetWorkflowStrategyPartnerInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
}

"""Autogenerated return type of proposalUnsetWorkflowStrategyPartner."""
type proposalUnsetWorkflowStrategyPartnerPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of ProposalUpdateProposedService"""
input ProposalUpdateProposedServiceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Slug of the proposal."""
  id: ID!

  """Slug of the proposed service to update."""
  proposedServiceId: ID!

  """Service input."""
  service: ProposedServiceInput!
}

"""Autogenerated return type of ProposalUpdateProposedService."""
type ProposalUpdateProposedServicePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  proposedService: ProposedService
}

enum ProposalValueDisplay {
  SHOW
  HIDE
}

enum ProposalWorkflowSettingsDeployStrategy {
  MANUAL
  AUTOMATIC
}

"""Autogenerated input type of proposalWorkflowSettingsSetDeployStrategy"""
input proposalWorkflowSettingsSetDeployStrategyInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """
  The deploy strategy will apply to workflows creates for this app.
  
  """
  appName: String!
  deployStrategy: ProposalWorkflowSettingsDeployStrategy!
}

"""
Autogenerated return type of proposalWorkflowSettingsSetDeployStrategy.
"""
type proposalWorkflowSettingsSetDeployStrategyPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowSettings: WorkflowSettings
}

enum ProposalWorkflowSettingsWorkflowStructure {
  """No workflow will be created."""
  NONE

  """One workflow will be created."""
  PER_PROPOSAL

  """One workflow will be created for each project."""
  PER_PROJECT
}

enum ProposalWorkflowStrategyRecurrenceType {
  ONCE_OFF
  RECURRING
}

"""
Autogenerated input type of proposalWorkflowStrategySetClientBillingGroup
"""
input proposalWorkflowStrategySetClientBillingGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
}

"""
Autogenerated return type of proposalWorkflowStrategySetClientBillingGroup.
"""
type proposalWorkflowStrategySetClientBillingGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""
Autogenerated input type of proposalWorkflowStrategySetProjectBillingGroup
"""
input proposalWorkflowStrategySetProjectBillingGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!

  """Slug of the project"""
  projectId: ID!
}

"""
Autogenerated return type of proposalWorkflowStrategySetProjectBillingGroup.
"""
type proposalWorkflowStrategySetProjectBillingGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""
Autogenerated input type of proposalWorkflowStrategySetProposalBillingGroup
"""
input proposalWorkflowStrategySetProposalBillingGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
}

"""
Autogenerated return type of proposalWorkflowStrategySetProposalBillingGroup.
"""
type proposalWorkflowStrategySetProposalBillingGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""Autogenerated input type of proposalWorkflowStrategyStartOnAcceptance"""
input proposalWorkflowStrategyStartOnAcceptanceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
  delay: DurationInput!
}

"""
Autogenerated return type of proposalWorkflowStrategyStartOnAcceptance.
"""
type proposalWorkflowStrategyStartOnAcceptancePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

"""
Autogenerated input type of proposalWorkflowStrategyStartOnProposalStart
"""
input proposalWorkflowStrategyStartOnProposalStartInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
  delay: DurationInput!
}

"""
Autogenerated return type of proposalWorkflowStrategyStartOnProposalStart.
"""
type proposalWorkflowStrategyStartOnProposalStartPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal!
  workflowStrategy: WorkflowStrategy!
}

enum ProposalWorkflowStrategyStartType {
  ACCEPTANCE
  START_DATE
  DATE
}

"""Autogenerated input type of proposalWorkflowStrategyUnsetBillingGroup"""
input proposalWorkflowStrategyUnsetBillingGroupInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Proposal slug"""
  id: ID!

  """Workflow Strategy slug"""
  workflowStrategyId: ID!
}

"""
Autogenerated return type of proposalWorkflowStrategyUnsetBillingGroup.
"""
type proposalWorkflowStrategyUnsetBillingGroupPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
  workflowStrategy: WorkflowStrategy
}

type ProposedService {
  account: Account @deprecated(reason: "Use ledgerItems instead")

  """
  Checks price and quantity combinations to see if the billing mode can change
  """
  canChangeBillingMode: Boolean! @deprecated(reason: "Use canChangeInvoiceStrategy instead")

  """
  Checks price and quantity combinations to see if the billing mode can change
  """
  canChangeInvoiceStrategy: Boolean!
  createdAt: DateTime!
  description: Textile!
  descriptionContent: ProposalProposedServiceDescription!
  id: ID!

  """Indicates if the proposed service was created via client renewal"""
  isRenewal: Boolean!

  """Ledger Items. Currently only supports Xero account"""
  ledgerItems: [LedgerItem!]
  name: String!

  """Proposed service's billing schedule portions"""
  portions: [Portion!]!
  position: Int!
  price: ProposalPriceInterface!

  """Quantity Object containing amounts and rules"""
  quantity: BillingQuantityRuleInterface

  """The agreed service that is about to be replaced"""
  replacesAgreedService: AgreedService
  service: Service!
  serviceGroup: ServiceGroup!
  tax: Tax!
  taxExempt: Boolean!
  terms: Textile
  updatedAt: DateTime!
}

input ProposedServiceFilter {
  priceTypeIn: [ProposalPriceType!]
}

"""ProposedService input type for updating a proposed service"""
input ProposedServiceInput {
  """ProposedService name"""
  name: String!

  """ProposedService description"""
  description: String!

  """ProposedService terms"""
  terms: String

  """UUID of tax"""
  taxId: ID!

  """ProposedService price rule"""
  priceRule: ServicePriceRuleInput!

  """ProposedService quantity rule"""
  quantityRule: ServiceQuantityRuleInput

  """Ledger Item, currently only support Xero Account"""
  ledgerItem: LedgerItemInput
}

input ProvidedTemplateFilter {
  """Name of the template"""
  nameCont: String
}

type PublicToken {
  createdAt: Date!
  token: String!
}

"""Input type for quantity rule."""
input QuantityRuleInput {
  """Estimate quantity rule"""
  estimate: EstimateQuantityRuleInput

  """SmartBilling quantity rule"""
  smartBilling: SmartBillingQuantityRuleInput
}

"""The query root of this schema"""
type Query {
  currentPractice: Practice!
}

type quickbooks {
  companyId: ID
  items(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): QuickbooksItemConnection
  lastSynced: DateTime
  recurringTransactionsSearch(nameContains: String, type: [RecurringTransactionTypeEnum!], pagination: PaginationInput, sort: SearchQuerySortInput, asyncJobGroupId: ID, filterWithConversionErrors: Boolean): SearchQuery
  settings: QuickbooksSettings
  state: QuickbooksState! @deprecated(reason: "Use apps() query and its userConfiguration.state instead.")
  taxCodeMappings(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): QuickbooksTaxCodeMappingConnectionType @deprecated(reason: "Use appTaxes query instead.")
  taxCodes: [QuickbooksTaxCode!] @deprecated(reason: "Use appTaxes query instead.")
}

"""Autogenerated input type of QuickbooksDisconnect"""
input QuickbooksDisconnectInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of QuickbooksDisconnect."""
type QuickbooksDisconnectPayload {
  app: App!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  quickbooks: quickbooks
}

"""Autogenerated input type of QuickbooksEnable"""
input QuickbooksEnableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of QuickbooksEnable."""
type QuickbooksEnablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  quickbooks: quickbooks
}

type QuickbooksIntegrationLine {
  """Line amount"""
  amount: Money!

  """Description of the line"""
  description: String

  """Internal slug of the recuring transaction line"""
  id: ID!

  """Name of associated item (if present)"""
  itemName: String

  """Line number"""
  lineNum: Int!

  """Quantity"""
  quantity: String

  """Unit price"""
  unitPrice: Money!
}

type QuickbooksIntegrationRecurringTransaction {
  """List of jobs associated with the recurring transaction"""
  asyncJobs: [AsyncJob!]

  """Name of the Customer associated with the recurring transaction"""
  customerName: String

  """When do we finish invoicing (optional)"""
  endDate: Date

  """External URL for recurring transaction"""
  externalUrl: String

  """Internal slug of the recurring transaction"""
  id: ID!

  """Interval type"""
  intervalType: RecurringTransactionIntervalTypeEnum

  """List of Quickbooks Recurring Transaction Lines"""
  lines: [QuickbooksIntegrationLine!]

  """When do we finish invoicing (optional)"""
  nextDate: Date

  """External Quickbooks ID of the recurring transaction"""
  quickbooksId: String!

  """Automated, Reminded or Unscheduled"""
  recurType: String

  """Name of the Recurring Transaction"""
  recurringTemplateName: String

  """Total amount"""
  totalAmount: Money!

  """Type of Recurring Transaction"""
  type: RecurringTransactionTypeEnum!
}

type QuickbooksItem {
  id: ID!
  name: String!
}

"""The connection type for QuickbooksItem."""
type QuickbooksItemConnection {
  """A list of edges."""
  edges: [QuickbooksItemEdge!]!

  """A list of nodes."""
  nodes: [QuickbooksItem!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type QuickbooksItemEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: QuickbooksItem!
}

"""
Autogenerated return type of quickbooksRecurringTransactionStopRemoteFailed.
"""
type quickbooksRecurringTransactionStopRemoteFailedPayload {
  """The associated proposal"""
  proposal: Proposal!

  """The recurring transaction which throws an error when we try to stop it"""
  recurringTransaction: QuickbooksIntegrationRecurringTransaction!
}

type QuickbooksSettings {
  confirmed: Boolean!
  createInvoices: Boolean!
  defaultItem: QuickbooksItem
  defaultTerms: Int!
  invoicesShowServiceDescription: Boolean!
  recurringTerms: Int!
  syncClientName: Boolean!
}

input QuickbooksSettingsInput {
  syncClientName: Boolean!
  invoicesShowServiceDescription: Boolean!
  createInvoices: Boolean!
  defaultTerms: Int!
  recurringTerms: Int!
  defaultItemId: ID!
}

"""Autogenerated input type of QuickbooksSettingsUpdate"""
input QuickbooksSettingsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  settings: QuickbooksSettingsInput
}

"""Autogenerated return type of QuickbooksSettingsUpdate."""
type QuickbooksSettingsUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  quickbooks: quickbooks
}

enum QuickbooksState {
  AUTHORISED
  CONNECTED
  ENABLED
  DISCONNECTED
  UNAUTHORISED
  UNAVAILABLE
}

type QuickbooksTaxCode {
  id: ID!
  name: String!
  salesTaxPercentage: Percentage!
  salesTaxRate: Decimal! @deprecated(reason: "Use sales_tax_percentage")
}

type QuickbooksTaxCodeMapping {
  id: ID!
  referenceNumber: ID!

  """Ignition tax type"""
  tax: Tax!

  """QuickBooks integration tax code"""
  taxCode: QuickbooksTaxCode
}

"""The connection type for QuickbooksTaxCodeMapping."""
type QuickbooksTaxCodeMappingConnectionType {
  areAllMapped: Boolean!

  """A list of edges."""
  edges: [TaxCodeMappingEdge!]!

  """A list of nodes."""
  nodes: [QuickbooksTaxCodeMapping!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of QuickbooksTaxCodeMappingCreate"""
input QuickbooksTaxCodeMappingCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ignitionapp tax uuid"""
  ignitionappTaxId: ID!

  """tax code uuid"""
  taxCodeId: ID!
}

"""Autogenerated return type of QuickbooksTaxCodeMappingCreate."""
type QuickbooksTaxCodeMappingCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  quickbooks: quickbooks
}

input QuickbooksTaxCodeMappingInput {
  """UUID of PI Tax"""
  ignitionappTaxId: ID!

  """UUID of Tax Code"""
  taxCodeId: ID!
}

"""Autogenerated input type of QuickbooksTaxCodeMappingsUpdate"""
input QuickbooksTaxCodeMappingsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  mappings: [QuickbooksTaxCodeMappingInput!]!
}

"""Autogenerated return type of QuickbooksTaxCodeMappingsUpdate."""
type QuickbooksTaxCodeMappingsUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  quickbooks: quickbooks
}

"""Input type for range price rule."""
input RangePriceRuleInput {
  """Minimum price amount"""
  min: MoneyInput!

  """Maximum price amount"""
  max: MoneyInput!
}

type Recipient {
  emailAddress: EmailAddress!
}

type RecurrenceRule {
  """returns the frequency count, eg. 12, or nil for continuous schedules"""
  count: Int

  """returns the equivalent YEARLY, MONTHLY, WEEKLY, or DAILY value"""
  frequency: FrequencyTypeEnum!

  """representation of the recurrence rule in ical rule encoded format"""
  ical: String!
}

"""Recurrence rule in serialised iCal format."""
scalar RecurrenceRuleInput

enum RecurringTransactionIntervalTypeEnum {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

enum RecurringTransactionTypeEnum {
  BILL
  PURCHASE
  CREDIT_MEMO
  DEPOSIT
  ESTIMATE
  INVOICE
  JOURNAL_ENTRY
  REFUND_RECEIPT
  SALES_RECEIPT
  TRANSFER
  VENDOR_CREDIT
  PURCHASE_ORDER
}

"""Referral made by a user"""
type Referral {
  """email of person being referred"""
  email: String!

  """id of referral"""
  id: ID!

  """total rewards earned by referral"""
  rewards: [Reward!]!
}

"""The connection type for Referral."""
type ReferralConnection {
  """A list of edges."""
  edges: [ReferralEdge!]!
  newCount: Int!

  """A list of nodes."""
  nodes: [Referral!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  successfulCount: Int!
  totalRewards: ReferralTotalRewards!
}

type ReferralDetails {
  """amount of reward"""
  amount: Money!

  """email of person being referred"""
  email: String!

  """id of referral"""
  id: ID!

  """status of referral"""
  status: ReferralStatus!
}

"""An edge in a connection."""
type ReferralEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Referral!
}

enum ReferralStatus {
  """referree signed up and trialing the product"""
  TRIAL

  """rewards is paid and available for collection"""
  PAID

  """rewards approved but not yet paid out"""
  APPROVED

  """rewards rejected"""
  DECLINED

  """rewards waiting for review"""
  PENDING

  """
  Rewarding is in a brief pause so the company can investigate before approving or declining
  """
  HOLD
}

"""Total rewards earned on a referral"""
type ReferralTotalRewards {
  """rewards approved to be paid"""
  available: Money!

  """rewards paid"""
  earned: Money!
}

"""An uploaded image which may be dynamically resized."""
type ResizeableImage {
  """The filename of the uploaded image."""
  filename: String!

  """The mimetype of the uploaded, if available."""
  mimetype: String

  """The size of the uploaded image in bytes, if available."""
  size: Int!

  """The public URL of the uploaded image."""
  url(
    """Width (in px)"""
    width: Int

    """Height (in px)"""
    height: Int

    """
    If height/width provided, how should the image be fit into the new dimensions.
    """
    fit: ResizeableImageFit
  ): URL!
}

enum ResizeableImageFit {
  """
  Preserve the aspect ratio, resize the image to be as large as possible while
  ensuring its dimensions are less than or equal to both those specified.
  """
  CLIP

  """
  Preserve the aspect ratio, ensure the image covers both provided dimensions by clipping/cropping to fit.
  """
  CROP

  """
  Do not enlarge if the dimensions of the provided image are already less than the specified width or height.
  """
  SCALE

  """
  Ignore the aspect ratio of the provided image and stretch to both provided dimensions.
  """
  MAX
}

"""The connection type for SearchResult."""
type ResultConnection {
  """A list of edges."""
  edges: [ResultEdge!]!
  ids: [ID!]

  """A list of nodes."""
  nodes: [SearchResult!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ResultEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: SearchResult!
}

type RevenueBracket {
  label: String!
  value: MaturityIndexRevenueBracketValueEnum!
}

"""reward for an action on the referral flow"""
type Reward {
  """amount of reward"""
  amount: Money!

  """email of referee who earned the reward"""
  email: String!

  """id of reward"""
  id: ID!

  """status of reward"""
  status: RewardStatus!
}

"""The connection type for Reward."""
type RewardConnection {
  """A list of edges."""
  edges: [RewardEdge!]!

  """A list of nodes."""
  nodes: [Reward!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type RewardEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Reward!
}

enum RewardStatus {
  """rewards paid out"""
  PAID

  """rewards approved but not yet paid out"""
  APPROVED

  """rewards rejected"""
  DECLINED

  """rewards waiting to be approved or declined"""
  PENDING
}

"""Deprecated - use the Html type instead"""
scalar RichText

type Schedule {
  """
  The dates included in this schedule. For CONTINUOUS schedules, only dates from the the first 24 months are returned.
  """
  dates: [Date!]

  """The human-readable description of the schedule."""
  description: String

  """
  The date from which the schedule stops recurring. Will be NULL for CONTINUOUS schedules.
  """
  endDate: Date

  """The ical representation of the schedule in RFC5545 format."""
  ical: String!

  """
  The human-readable description for how often this schedule recurs. Examples: -
  "1 month" - "2 quarters" - "2 months and 2 days"
  """
  recurrenceDescription: String!

  """The date from which the schedule starts recurring."""
  startDate: Date!

  """The schedule type."""
  type: ScheduleTypeEnum!
}

type ScheduleItem {
  billOn: Date!
  billingName: String
  date: Date! @deprecated(reason: "Use billOn instead")
  id: ID!
  invoiceStrategy: ProposalInvoiceStrategy
  isBilled: Boolean!
  price: Money!
}

enum ScheduleTypeEnum {
  CONTINUOUS
  NON_RECURRING
  RECURRING
}

type Search {
  attributeValues(type: SearchType!, attribute: String!, contains: String): [String!]!
  pagedQuery(type: SearchType!, booleanFilters: [SearchQueryBooleanFilterInput!], dateFilters: [SearchQueryDateFilterInput!], relativeDateFilters: [SearchQueryRelativeDateFilterInput!], numberFilters: [SearchQueryNumberFilterInput!], textFilters: [SearchQueryTextFilterInput!], sort: SearchQuerySortInput, pagination: PaginationInput = {pageSize: 25, pageNumber: 1}): SearchQuery!
  searchQuery(type: SearchType!, booleanFilters: [SearchQueryBooleanFilterInput!] = [], dateFilters: [SearchQueryDateFilterInput!] = [], numberFilters: [SearchQueryNumberFilterInput!] = [], textFilters: [SearchQueryTextFilterInput!] = [], sort: SearchQuerySortInput, pagination: PaginationInput = {pageSize: 25, pageNumber: 1}): [SearchResult!]! @deprecated(reason: "use pagedResults")
}

enum SearchBooleanFilterCondition {
  EQUALS
}

enum SearchDateFilterCondition {
  EQUALS
  BEFORE
  AFTER
  BETWEEN
  HAS_VALUE
  HAS_NO_VALUE
}

"""Autogenerated input type of SearchExportCsv"""
input SearchExportCsvInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  type: SearchType!
  booleanFilters: [SearchQueryBooleanFilterInput!]
  dateFilters: [SearchQueryDateFilterInput!]
  relativeDateFilters: [SearchQueryRelativeDateFilterInput!]
  numberFilters: [SearchQueryNumberFilterInput!]
  textFilters: [SearchQueryTextFilterInput!]
  sort: SearchQuerySortInput
}

"""Autogenerated return type of SearchExportCsv."""
type SearchExportCsvPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

enum SearchNumberFilterCondition {
  EQUALS
  BEFORE
  AFTER
  BETWEEN
}

type SearchQuery {
  results(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ResultConnection!
  totalCount: Int!
  totalValue: Money
}

input SearchQueryBooleanFilterInput {
  relation: SearchType
  attribute: String!
  condition: SearchBooleanFilterCondition!
  values: [Boolean!]!
}

input SearchQueryDateFilterInput {
  relation: SearchType
  attribute: String!
  condition: SearchDateFilterCondition!
  values: [Date!]!
}

input SearchQueryNumberFilterInput {
  relation: SearchType
  attribute: String!
  condition: SearchNumberFilterCondition!
  values: [Decimal!]!
}

input SearchQueryRelativeDateFilterInput {
  relation: SearchType
  attribute: String!
  condition: SearchRelativeDateFilterCondition!
  values: [DurationInput!]!
}

input SearchQuerySortInput {
  attribute: String!
  direction: SearchSortDirection!
  relation: SearchType
}

input SearchQueryTextFilterInput {
  relation: SearchType
  attribute: String!
  condition: SearchTextFilterCondition!
  values: [String!]!
}

enum SearchRelativeDateFilterCondition {
  PREVIOUS
  NEXT
}

union SearchResult = AppClientResult | ClientResult | IgnitionAppServiceType | ProposalCustomTemplate | ProposalProvidedTemplate | ProposalResult | QuickbooksIntegrationRecurringTransaction | Service | XeroIntegrationRepeatingInvoice

enum SearchSortDirection {
  """asc"""
  ASC

  """desc"""
  DESC
}

enum SearchTextFilterCondition {
  CONTAINS
  EQUALS
  ANY_OF
  HAS_NO_VALUE
}

enum SearchType {
  PROPOSAL
  CLIENT
  APP_CLIENT
  ASYNC_JOB
  ASYNC_JOB_GROUP
  BILLING_ITEM
  PROPOSAL_BULK_ACTION
  CLIENT_BULK_ACTION
}

input SelectedTrackingOptionInput {
  """The ID of the Xero tracking category"""
  categoryId: ID!

  """The ID of the selected option for this category"""
  optionId: ID!
}

"""Autogenerated input type of SendDemoProposal"""
input SendDemoProposalInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  email: EmailAddress!
}

"""Autogenerated return type of SendDemoProposal."""
type SendDemoProposalPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of SendPaymentMethodRequestToClients"""
input SendPaymentMethodRequestToClientsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """A list of client ids"""
  clientIds: [ID!]!

  """Message text included in the notification to the client"""
  messageText: String!

  """Allowed payment methods in the client portal request"""
  creditCardAccepted: Boolean!

  """Allowed payment methods in the client portal request"""
  directDebitAccepted: Boolean!

  """Use this payment method for future billing items"""
  useMethodInFuture: Boolean!
}

"""Autogenerated return type of SendPaymentMethodRequestToClients."""
type SendPaymentMethodRequestToClientsPayload {
  """Async Job Group for the notifications sending in the background"""
  asyncJobGroup: AsyncJobGroup

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  paymentMethodRequestGroup: PaymentMethodRequestGroup!
}

"""Autogenerated input type of SendTestProposal"""
input SendTestProposalInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """slug of the proposal"""
  id: ID!
  email: EmailAddress!
}

"""Autogenerated return type of SendTestProposal."""
type SendTestProposalPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

type Service {
  account: Account
  billingLabel: String!
  createdAt: DateTime!
  defaultBillingType: DefaultBillingType!

  """A description of the Service"""
  description: String!

  """
  A description of the Service in Rendered Textile HTML without div wrapper
  """
  descriptionHtml: String!

  """A description of the Service in Textile"""
  descriptionTextile: String!
  hourlyPrice: Money @deprecated(reason: "Use unitPrice instead")
  id: ID!
  invoiceStrategy: ServiceInvoiceStrategy
  ledgerItems: [LedgerItem!]
  maxPrice: Money
  minPrice: Money

  """The name of the Service"""
  name: String!
  priceForDisplay: String
  priceRule: BillingPriceRuleInterface!
  priceType: ServicePriceType

  """Publically available (legacy CPE field)"""
  publicallyAvailable: Boolean!
  quantityRule: BillingQuantityRuleInterface @deprecated(reason: "Quantity is no longer desired to be defined in the Library")
  referenceNumber: ID!

  """Sequence position (legacy CPE field)"""
  sequence: Int

  """Service group (legacy CPE field)"""
  serviceGroup: ServiceGroupType

  """Short description of the service (legacy CPE field)"""
  shortDescription: String

  """The slug of the Service"""
  slug: ID!
  standardPrice: Money
  tax: Tax!

  """(QBO US) Tax exempt (legacy CPE field)"""
  taxExempt: Boolean!
  terms: String
  termsHtml: String
  token: String

  """Unit name for service's price"""
  unitName: String
  unitPrice: Money
  updatedAt: DateTime!

  """Weekly price (legacy CPE field)"""
  weeklyPrice: Money
  workflowTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): WorkflowTemplateTypeConnection
}

"""Autogenerated input type of ServiceAddWorkflowTemplateMappings"""
input ServiceAddWorkflowTemplateMappingsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The uuid of the Service to map"""
  id: ID!

  """The Workflow Templates Ids to map to"""
  workflowTemplateIds: [ID!]!

  """The name of the App the templates belong to"""
  appName: String!
}

"""Autogenerated return type of ServiceAddWorkflowTemplateMappings."""
type ServiceAddWorkflowTemplateMappingsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  service: Service
}

"""The connection type for Service."""
type ServiceConnection {
  """A list of edges."""
  edges: [ServiceEdge!]!

  """A list of nodes."""
  nodes: [Service!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of ServiceCreate"""
input ServiceCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  service: ServiceInput!
}

"""Autogenerated return type of ServiceCreate."""
type ServiceCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  service: Service
}

"""Autogenerated input type of ServiceDelete"""
input ServiceDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  idsIn: [ID!]!
}

"""Autogenerated return type of ServiceDelete."""
type ServiceDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  services(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ServiceConnection
}

"""Autogenerated input type of ServiceDeleteWorkflowTemplateMappings"""
input ServiceDeleteWorkflowTemplateMappingsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The uuid of the Service to map"""
  id: ID!

  """The Workflow Templates Ids to remove from the mappings"""
  workflowTemplateIds: [ID!]!

  """The name of the App the templates belong to"""
  appName: String!
}

"""Autogenerated return type of ServiceDeleteWorkflowTemplateMappings."""
type ServiceDeleteWorkflowTemplateMappingsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  service: Service
}

"""An edge in a connection."""
type ServiceEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Service!
}

input ServiceFilter {
  """Filter by name"""
  nameCont: String

  """Returns only records where the ids are present in this list"""
  idsIn: [ID!]

  """Service origin reference filter e.g. csv, xero, quickbooks"""
  serviceOriginReferenceEq: String

  """Service origin type filter. e.g. app, csv, provided_template"""
  serviceOriginTypeEq: String
}

type ServiceGroup {
  """
  the frontend-specific billing mode set by the frontend for display purposes
  """
  billingMode: ProposalBillingModeEnum!
  billingSchedules: [ProposalBillingScheduleInterface!]!
  billingStrategy: ProposalBillingStrategyInterface! @deprecated(reason: "Use billing_schedules instead")
  cadence: String @deprecated(reason: "Use billingSchedules { cadence }")
  createdAt: DateTime!
  id: ID!
  position: Int!
  project: Project!
  proposedServices(filter: ProposedServiceFilter): [ProposedService]!
  subtitle: String

  """subtotal of all fixed price proposed services"""
  subtotal: Money!

  """
  Formatted value of the service group subtotal, always without tax, eg. From $50
  """
  subtotalDescription: String!

  """subtotal tax of all fixed price proposed services"""
  subtotalTax: Money!

  """Formatted value of the service group tax on the subtotal, eg. From $5"""
  subtotalTaxDescription: String!

  """subtotal and subtotal tax of all fixed price proposed services"""
  subtotalWithTax: Money!

  """
  Formatted value of the service group subtotal and subtotal tax, eg. From $55
  """
  subtotalWithTaxDescription: String!
  title: String!
  updatedAt: DateTime!
}

"""Autogenerated input type of ServiceGroupCreate"""
input ServiceGroupCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  name: String!
  shortDescription: String
  sequence: Int
  isDefault: Boolean = false
}

"""Autogenerated return type of ServiceGroupCreate."""
type ServiceGroupCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  serviceGroup: ServiceGroupType!
}

"""services provided"""
type ServiceGroupType {
  id: ID!
  isDefault: Boolean!

  """Database ID for legacy CPE processing"""
  legacyId: ID! @deprecated(reason: "Use id for standard slug-based identification")

  """service name"""
  name: String!
  sequence: Int

  """description of service"""
  shortDescription: String
}

"""Service Import"""
type ServiceImport {
  attachmentFileName: String!
  attachmentFileSize: Int!
  id: ID!
  practice: Practice!
  user: User!
}

"""Autogenerated input type of ServiceImport"""
input ServiceImportInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of ServiceImport."""
type ServiceImportPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  import: ServiceImport!
}

"""Service input type for creating a service"""
input ServiceInput {
  """Service name"""
  name: String!

  """Service description"""
  description: String!

  """Service terms"""
  terms: String

  """UUID of tax"""
  taxId: ID!

  """Service price rule"""
  priceRule: ServicePriceRuleInput!

  """Service quantity rule"""
  quantityRule: ServiceQuantityRuleInput

  """Billing mode"""
  invoiceStrategy: ServiceInvoiceStrategy = AUTOMATIC

  """Weekly price (legacy CPE field)"""
  weeklyPrice: MoneyInput

  """Short description of the service (legacy CPE field)"""
  shortDescription: String

  """Sequence position (legacy CPE field)"""
  sequence: Int

  """Service group ID (legacy CPE field)"""
  serviceGroupId: ID

  """Default billing type (legacy CPE field)"""
  defaultBillingType: DefaultBillingType

  """Price type (legacy CPE field)"""
  priceType: ServicePriceType

  """Standard price (legacy CPE field)"""
  standardPrice: MoneyInput

  """Minimum price (legacy CPE field)"""
  minPrice: MoneyInput

  """Maximum price (legacy CPE field)"""
  maxPrice: MoneyInput

  """Unit price (legacy CPE field)"""
  unitPrice: MoneyInput

  """Unit name (legacy CPE field)"""
  unitName: String

  """(QBO US) Tax exempt (legacy CPE field)"""
  taxExempt: Boolean

  """Publically available (legacy CPE field)"""
  publicallyAvailable: Boolean

  """Ledger Items (Xero account or QuickBooks service item)"""
  ledgerItems: [ServiceLedgerItemInput!]

  """Workflow Template Items"""
  workflowTemplateMappings: [WorkflowTemplateMappingsInput!]
}

enum ServiceInvoiceStrategy {
  AUTOMATIC
  MANUAL
}

"""Input type for Service Ledger Item."""
input ServiceLedgerItemInput {
  """Slug of ledger item."""
  ledgerItemId: ID!

  """Ledger app (Xero or QuickBooks)"""
  appName: String!
}

"""A service origin reflects how a service was created"""
type ServiceOriginType {
  id: ID!

  """The name of the Service Origin"""
  name: String!

  """The reference of the Service Origin (e.g. xero, quickbooks, csv)"""
  reference: String!

  """The type of the Service Origin (e.g. app or csv)"""
  type: String!
}

"""
Price rule input type for creating service. Just one input field is allowed
"""
input ServicePriceRuleInput {
  """Fixed rate price"""
  fixed: FixedPriceRuleInput

  """Unit price """
  unit: UnitPriceRuleInput

  """Price range"""
  range: RangePriceRuleInput

  """Minimum price only"""
  minimum: MinimumPriceRuleInput

  """Price included"""
  included: IncludedPriceRuleInput
}

enum ServicePriceType {
  STANDARD
  RANGE
  HOURLY
}

"""
Quantity rule input type for creating service. Just one input field is allowed
"""
input ServiceQuantityRuleInput {
  """Estimate quantity"""
  estimate: EstimateQuantityRuleInput

  """Smart billing quantity rule"""
  smartBilling: SmartBillingQuantityRuleInput
}

enum ServiceRevenueExport {
  DASHBOARD_SERVICE_REVENUE
  DASHBOARD_SERVICE_REVENUE_BY_CLIENT
}

"""Autogenerated input type of ServiceRevenueExport"""
input ServiceRevenueExportInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ISO formatted date"""
  startDate: Date!

  """ISO formatted date"""
  endDate: Date!
  exportType: ServiceRevenueExport!
}

"""Autogenerated return type of ServiceRevenueExport."""
type ServiceRevenueExportPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  userErrors: [UserError!]
}

"""Autogenerated input type of ServicesBulkCreate"""
input ServicesBulkCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """name of the app (e.g. "xero" or "quickbooks")"""
  appName: String!

  """list of AppService ids"""
  ids: [ID!]!
}

"""Autogenerated return type of ServicesBulkCreate."""
type ServicesBulkCreatePayload {
  asyncJobGroup: AsyncJobGroup

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ServiceSetWorkflowTemplateMappings"""
input ServiceSetWorkflowTemplateMappingsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The uuid of the Service to map"""
  id: ID!

  """The Workflow Templates to map to"""
  workflowTemplateIds: [ID!]!

  """The name of the App the templates belong to"""
  appName: String!
}

"""Autogenerated return type of ServiceSetWorkflowTemplateMappings."""
type ServiceSetWorkflowTemplateMappingsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  service: Service
}

"""Autogenerated input type of ServiceTokenGenerate"""
input ServiceTokenGenerateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ID for service"""
  id: ID!
}

"""Autogenerated return type of ServiceTokenGenerate."""
type ServiceTokenGeneratePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  service: Service!
}

"""Autogenerated input type of ServiceTokenRevoke"""
input ServiceTokenRevokeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ID for service"""
  id: ID!
}

"""Autogenerated return type of ServiceTokenRevoke."""
type ServiceTokenRevokePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  service: Service!
}

"""Autogenerated input type of ServiceUpdate"""
input ServiceUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of the service"""
  id: ID!
  service: ServiceInput!
}

"""Autogenerated return type of ServiceUpdate."""
type ServiceUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  service: Service
}

"""Settings input type for updating the dashboard."""
input SettingsInput {
  """Number of available staff for the practice."""
  staffCount: Int!

  """
  Beginning month of the monthly budgets.  Defaults to practice's financial year start.
  """
  budgetStart: DateInput

  """
  Budgets for each month starting with the budget start month. Dollar amounts assumed to be in the practice's currency.
  """
  monthlyBudgets: [Int!]!
}

scalar ShortURL

input SignatoryFilter {
  role: SignatoryRoleEnum
}

enum SignatoryRoleEnum {
  PRIMARY
  SECONDARY
}

enum SignatoryStateEnum {
  SIGNED
  SIGNED_ON_BEHALF
  UNSIGNED
}

type SignatureLocation {
  cityName: String!
  latitude: Float!
  longitude: Float!
}

type SmartBillingQuantityOption {
  """source of the dynamic option e.g. gusto_company_headcount"""
  source: String!
}

"""The connection type for SmartBillingQuantityOption."""
type SmartBillingQuantityOptionConnection {
  """A list of edges."""
  edges: [SmartBillingQuantityOptionEdge!]!

  """A list of nodes."""
  nodes: [SmartBillingQuantityOption!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type SmartBillingQuantityOptionEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: SmartBillingQuantityOption!
}

"""Input type for SmartBilling quantity rule."""
input SmartBillingQuantityRuleInput {
  """Source of the rule to apply. e.g. gusto_company_headcount"""
  source: String!
}

enum StaffCount {
  """with a team of 50+ staff"""
  FIFTY_PLUS

  """with a team of 21-50 staff"""
  TWENTY_ONE_TO_FIFTY

  """with a team of 11-20 staff"""
  ELEVEN_TO_TWENTY

  """with a team of 6-10 staff"""
  SIX_TO_TEN

  """with a team of 4-5 staff"""
  FOUR_TO_FIVE

  """with a team of 1-3 staff"""
  ONE_TO_THREE

  """as a sole trader"""
  SOLE
}

type Subscription {
  """User notifications have been updated"""
  notificationsUpdated: UpdatedPayload!
  paymentCollected: paymentCollectedPayload!
  paymentDisbursed: paymentDisbursedPayload!
  paymentStarted: paymentStartedPayload!
  proposalAccepted: proposalAcceptedPayload!

  """QuickBooks app has been connected"""
  quickbooksConnected: ConnectedPayload!

  """Fires when we cannot stop the remote recurring transaction"""
  quickbooksRecurringTransactionStopRemoteFailed: quickbooksRecurringTransactionStopRemoteFailedPayload!

  """Fires when we cannot stop the remote repeating invoice"""
  xeroRepeatingInvoiceStopRemoteFailed: xeroRepeatingInvoiceStopRemoteFailedPayload!
}

type SubscriptionCoupon {
  """Coupon code"""
  code: String!

  """Coupon discount rate"""
  discountPercentage: Percentage

  """Coupon discount type"""
  type: CouponDiscountType!
}

type SubscriptionPreview {
  """Length of time between billing cycles."""
  billingPeriod: PlanBillingPeriod!

  """Carried forward amount."""
  carriedForward: Money

  """Subscription's coupon."""
  coupon: SubscriptionCoupon

  """Flag to indicate if coupon is applied."""
  couponApplied: Boolean!

  """Remaining credit of the subscription."""
  creditRemaining: Money

  """Amount of discount."""
  discountAmount: Money

  """Price with discount."""
  discountedPrice: Money

  """Price without any discount."""
  standardPrice: Money!
}

enum SubscriptionStatus {
  SUBSCRIBED
  TRIAL
  EXPIRED
}

"""Autogenerated input type of SurchargeDisable"""
input SurchargeDisableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of SurchargeDisable."""
type SurchargeDisablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  paymentSettings: PaymentSettings!
}

"""Autogenerated input type of SurchargeEnable"""
input SurchargeEnableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Rate at which applicable cards are surcharged"""
  surchargeRate: PercentageInput!

  """
  Whether surcharges are restricted to only the 'credit_card' surcharge category
  """
  isSurchargeCreditCardsOnly: Boolean!
}

"""Autogenerated return type of SurchargeEnable."""
type SurchargeEnablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  paymentSettings: PaymentSettings!
}

type SystemTemplate implements PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  slug: ID!
  updatedAt: DateTime!
}

type Tax {
  appTaxes(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: AppTaxFilter
  ): AppTaxConnection!
  id: ID!
  name: String!
  rate: Decimal!
  referenceNumber: ID!
}

"""An edge in a connection."""
type TaxCodeMappingEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: QuickbooksTaxCodeMapping!
}

"""The connection type for Tax."""
type TaxConnection {
  """A list of edges."""
  edges: [TaxEdge!]!

  """A list of nodes."""
  nodes: [Tax!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of TaxCreate"""
input TaxCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Tax name"""
  name: String!

  """Tax rate"""
  rate: Decimal!

  """
  A list of Capability AppTaxes which will be automatically mapped to the new Tax.
  """
  appTaxes: [AppTaxInput!] = []
}

"""Autogenerated return type of TaxCreate."""
type TaxCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  tax: Tax
  taxes(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): TaxConnection
}

enum TaxDisplay {
  """Amounts displayed include tax"""
  INCLUDING_TAX

  """Amounts displayed exclude tax"""
  EXCLUDING_TAX

  """No tax information is displayed"""
  NO_TAX_DISPLAY
}

"""An edge in a connection."""
type TaxEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Tax!
}

input TaxFilter {
  mappedIn: TaxMappingsLedger
}

enum TaxMappingsLedger {
  XERO
  QUICKBOOKS
}

enum TaxMethod {
  """Tax is set on the proposal"""
  PROPOSAL

  """Tax is set per service"""
  SERVICES
}

type TaxRate {
  displayTaxRate: String @deprecated(reason: "Use tax_rate_percentage")
  id: ID!
  name: String!
  taxRatePercentage: Percentage
  taxType: String!
}

type TaxRateMapping {
  id: ID!

  """Ignition tax type"""
  tax: Tax!

  """Xero integration tax rate"""
  taxRate: TaxRate
}

"""An edge in a connection."""
type TaxRateMappingEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: TaxRateMapping!
}

"""Autogenerated input type of TaxSetAppMappings"""
input TaxSetAppMappingsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The App name we're mapping to."""
  appName: String!

  """The list of taxes and the AppTax to map to."""
  taxMappings: [AppTaxMappingInput!]!
}

"""Autogenerated return type of TaxSetAppMappings."""
type TaxSetAppMappingsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  taxes: [Tax!]
}

input TemplateFilter {
  nameCont: String
  templateTypeEq: TemplateType
  systemNameEq: TemplateSystem
}

input TemplateInput {
  name: String
  content: String!
}

type Templates {
  """
  Email template for explaining that something went wrong when adding or updating the clients bank account
  """
  bankAccountFailureEmailTemplate: BankAccountFailureEmailTemplate

  """
  Email template for explaining bank account verification when the client accepts a proposal
  """
  bankAccountVerificationEmailTemplate: BankAccountVerificationEmailTemplate

  """Intro message template"""
  introMessageTemplate(id: ID!): IntroMessageTemplate

  """Intro message templates"""
  introMessageTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): IntroMessageTemplateConnection

  """Email template for advising client of new group proposal"""
  newGroupProposalEmailTemplate: NewGroupProposalEmailTemplate

  """Email template for advising client of new proposal"""
  newProposalEmailTemplate(id: ID!): NewProposalEmailTemplate

  """Email templates for advising client of new proposal"""
  newProposalEmailTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): NewProposalEmailTemplateConnection

  """Email template for advising client of submission"""
  newSubmissionEmailTemplate: NewSubmissionEmailTemplate

  """Next steps message template"""
  nextStepsMessageTemplate(id: ID!): NextStepsMessageTemplate
  nextStepsMessageTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): NextStepsMessageTemplateConnection
  proposalAcceptedBrowserTemplate: ProposalAcceptedBrowserTemplate

  """Email template for advising client of proposal acceptance"""
  proposalAcceptedEmailTemplate: ProposalAcceptedEmailTemplate

  """Engagement template"""
  termsTemplate(id: ID!): TermsTemplate

  """Engagement templates"""
  termsTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): TermsTemplateConnection
}

enum TemplateSystem {
  ENGAGEMENT_TEMPLATE
  ACCEPT_ENGAGEMENT_MESSAGE
  ADVISE_CLIENT_OF_ACCEPTANCE
  ADVISE_CLIENT_OF_NEW_PROPOSAL
  ADVISE_CLIENT_OF_NEW_GROUP_PROPOSAL
  ADVISE_CLIENT_OF_SUBMISSION
  ADVISE_CLIENT_OF_BANK_VERIFICATION_REQUIRED
  ADVISE_CLIENT_OF_BANK_ACCOUNT_FAILURE
  INTRO_MESSAGE_TEMPLATE
}

enum TemplateType {
  EMAIL
  ENGAGEMENT
  SYSTEM
}

enum TemplateVisibility {
  PRIVATE
  PUBLIC
}

type TermsTemplate implements PracticeTemplate {
  content: String!
  contentHtml: String!
  createdAt: DateTime!
  description: String
  id: ID!
  isDefault: Boolean!
  name: String!
  slug: ID!
  updatedAt: DateTime!
}

"""The connection type for TermsTemplate."""
type TermsTemplateConnection {
  """A list of edges."""
  edges: [TermsTemplateEdge!]!

  """A list of nodes."""
  nodes: [TermsTemplate!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of TermsTemplateCreate"""
input TermsTemplateCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: TemplateInput!
}

"""Autogenerated return type of TermsTemplateCreate."""
type TermsTemplateCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: TermsTemplate
  templates: Templates
}

"""Autogenerated input type of TermsTemplateDelete"""
input TermsTemplateDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of terms template"""
  id: ID!
}

"""Autogenerated return type of TermsTemplateDelete."""
type TermsTemplateDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  templates: Templates
}

"""An edge in a connection."""
type TermsTemplateEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: TermsTemplate!
}

"""Autogenerated input type of TermsTemplateUpdate"""
input TermsTemplateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of terms template"""
  id: ID!
  template: TemplateInput!
}

"""Autogenerated return type of TermsTemplateUpdate."""
type TermsTemplateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  template: TermsTemplate
  templates: Templates
}

type Textile {
  """unsafe html for displaying on the web page"""
  html: String! @deprecated(reason: "Use the safeHtml field instead.")

  """sanitised html for displaying on the web page"""
  safeHtml: Html!

  """the raw textile for editing in a text area"""
  textile: String!
}

"""A representation of a time zone."""
type TimeZone {
  """The standard ICANN tz database code (e.g. 'America/New_York')"""
  code: String!

  """
  The friendly (Rails compatible) time zone name (e.g. 'Eastern Time (US & Canada)')
  """
  name: String!

  """Formatted UTC offset."""
  utcOffset: String!

  """The UTC offset in seconds."""
  utcOffsetInSeconds: Int!
}

enum TwoFactorAuthMethod {
  AUTH_APP
  SMS
}

"""Input type for unit price rule."""
input UnitPriceRuleInput {
  """Price amount"""
  amount: MoneyInput!

  """Unit name"""
  unitName: String!
}

input UpdateContactInput {
  """The UUID of the Contact"""
  id: ID!

  """The Email Address of the Contact"""
  email: EmailAddress
}

"""Autogenerated return type of Updated."""
type UpdatedPayload {
  user: User!
}

"""Autogenerated input type of UploadAvatar"""
input UploadAvatarInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  avatar: ImageInput!
}

"""Autogenerated return type of UploadAvatar."""
type UploadAvatarPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  success: Boolean!
}

scalar URL

type User {
  appUsers(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: AppUserFilter
  ): AppUserConnection!
  avatarUrl: URL
  createdAt: DateTime!

  """Time stamp address of the user's current/ most recent sign in"""
  currentSignInAt: DateTime

  """IP address of the user's current/ most recent sign in"""
  currentSignInIp: IpAddress
  emailAddress: EmailAddress!
  firstName: String!
  fullName: String!
  hasBillingPermission: Boolean!
  hasSignedIn: Boolean
  id: ID!

  """If the user is imported, this is the imported id"""
  importedId: ID
  invitationAcceptedAt: DateTime
  invitationSentAt: DateTime
  isActive: Boolean
  isPrincipal: Boolean!

  """whether user logs in through sso or not"""
  isSsoUser: Boolean!

  """Whether or not we send a weekly report"""
  isSubscribedToWeeklySummary: Boolean!
  jobTitle: String
  lastName: String!

  """Time stamp of the user's previous sign in"""
  lastSignInAt: DateTime

  """IP address of the user's previous sign in"""
  lastSignInIp: IpAddress
  notifications(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): NotificationsConnectionType
  referenceNumber: ID!
  referralDetails: [ReferralDetails!]
  referralRewards(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): RewardConnection

  """
  a referral URL that the user can share with others to participate in the referrals scheme
  """
  referralUrl: URL
  referrals(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ReferralConnection
  role: String
  roles: [String!]
  signInCount: Int!
  twoFactorAuthEnabled: Boolean!
  twoFactorAuthMethod: TwoFactorAuthMethod
  twoFactorAuthMobile: PhoneNumber
  updatedAt: DateTime!
  uuid: ID! @deprecated(reason: "Use id instead")
  watchSettings: UserWatchSettings!
}

"""
UserConfigAttributes contains details about an App's settings & presentation on the apps page.
"""
type UserConfigurable {
  """
  The name of the connected App account to be displayed on the app tile when connected
  """
  accountName: String @deprecated(reason: "Use connectedAccount { name }")

  """The list of accounts the app is authorised to connect to."""
  authorisedAccounts: [UserConfigurableAccount!]!

  """Whether a user can connect this App from an app tile"""
  connectable: Boolean!

  """Information about the currently connected account (if any)."""
  connectedAccount: UserConfigurableAccount

  """
  A description of the App that is displayed on its tile when not connected
  """
  connectionText: String!

  """
  A URL which the user will be redirected to in order to start connecting this App
  """
  connectionUrl: URL!

  """Whether a user can enable this App from an app tile"""
  enablable: Boolean!

  """The last time this App was successfully synced"""
  lastSynced: DateTime
  state: UserConfigurableState!
}

type UserConfigurableAccount {
  id: ID!
  name: String!
}

enum UserConfigurableState {
  """App is not connected."""
  DISCONNECTED

  """App is authorised but not yet connected to an account."""
  AUTHORISED

  """App is in the process of connecting to an account."""
  CONNECTING

  """App is connected to an account but not yet enabled."""
  CONNECTED

  """App is enabled"""
  ENABLED

  """App is connected but authorisation has failed."""
  UNAUTHORISED
}

"""The connection type for User."""
type UserConnection {
  """A list of edges."""
  edges: [UserEdge!]!

  """A list of nodes."""
  nodes: [User!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

enum userContentType {
  PROPOSAL_TERMS
  PROPOSAL_SERVICE_TERMS
  PROPOSAL_PROPOSED_SERVICE_DESCRIPTION
}

"""Autogenerated input type of UserCreate"""
input UserCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The User input fields"""
  userInput: UserInputType!

  """Automatically send an email invitation to the user?"""
  sendInvitation: Boolean = false
}

"""Autogenerated return type of UserCreate."""
type UserCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User!
}

"""Autogenerated input type of UserDelete"""
input UserDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the User to delete"""
  id: ID!
}

"""Autogenerated return type of UserDelete."""
type UserDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User!
}

"""An edge in a connection."""
type UserEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: User!
}

type UserError implements DisplayableError {
  """Path to the input field which caused the error"""
  field: [String!]

  """The error message"""
  message: String!
}

"""Input fields for a user"""
input UserInputType {
  """The user's full name"""
  fullName: String!

  """The user's email address"""
  emailAddress: EmailAddress!

  """ACCOUNTANT or PRACTICEADMIN"""
  role: UserRoleEnum!

  """Can this user bill or not?"""
  hasBillingPermission: Boolean!

  """Is the user being subscribed to the weekly summary email"""
  isSubscribedToWeeklySummary: Boolean!

  """User's job title"""
  jobTitle: String

  """User's XPM/WFM ID"""
  importedId: ID
}

"""Autogenerated input type of UserInviteAll"""
input UserInviteAllInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The invitations"""
  invitations: [InvitationInputType!]!
}

"""Autogenerated return type of UserInviteAll."""
type UserInviteAllPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """List of invitation results by this mutation"""
  invitations: [InvitationType!]
}

"""Autogenerated input type of UserInvite"""
input UserInviteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the User to invite"""
  id: ID!
}

"""Autogenerated return type of UserInvite."""
type UserInvitePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User
}

"""Autogenerated input type of UserLogout"""
input UserLogoutInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of UserLogout."""
type UserLogoutPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of UserPasswordUpdate"""
input UserPasswordUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  password: String!
  oldPassword: String!
}

"""Autogenerated return type of UserPasswordUpdate."""
type UserPasswordUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of UserRegisterReferralUrl"""
input UserRegisterReferralUrlInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of UserRegisterReferralUrl."""
type UserRegisterReferralUrlPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  currentUser: User!
}

"""Autogenerated input type of UserResetTwoFactorAuth"""
input UserResetTwoFactorAuthInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the User to reset"""
  id: ID!

  """The OTP of the current User"""
  otp: String!
}

"""Autogenerated return type of UserResetTwoFactorAuth."""
type UserResetTwoFactorAuthPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User
}

enum UserRoleEnum {
  ACCOUNTANT
  PRACTICEADMIN
}

"""Autogenerated input type of UserSendReferralInviteEmail"""
input UserSendReferralInviteEmailInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The invitee's email address"""
  recipientEmail: EmailAddress!
}

"""Autogenerated return type of UserSendReferralInviteEmail."""
type UserSendReferralInviteEmailPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  currentUser: User!
}

"""Autogenerated input type of UserSendTwoFactorAuthSmsCode"""
input UserSendTwoFactorAuthSmsCodeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of UserSendTwoFactorAuthSmsCode."""
type UserSendTwoFactorAuthSmsCodePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User
}

"""Autogenerated input type of UserSetAppMapping"""
input UserSetAppMappingInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the User to map"""
  id: ID!

  """The AppUsers to map to"""
  appUsers: [AppUserInput!]!
}

"""Autogenerated return type of UserSetAppMapping."""
type UserSetAppMappingPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User
}

"""Autogenerated input type of UserUpdate"""
input UserUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the User to update"""
  id: ID!

  """The User input fields"""
  userInput: UserInputType!
}

"""Autogenerated return type of UserUpdate."""
type UserUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User!
}

"""Autogenerated input type of UserUpdateWeeklySummaryEmail"""
input UserUpdateWeeklySummaryEmailInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Enables the weekly summary email flag in user profile"""
  enabled: Boolean!
}

"""Autogenerated return type of UserUpdateWeeklySummaryEmail."""
type UserUpdateWeeklySummaryEmailPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  currentUser: User!
}

type UserWatchSettings {
  defaults: [WatchableEventsEnum!]!
}

enum WatchableEventsEnum {
  ACCEPT_PAGE_VIEW
  ACCEPTANCE
  ACH_SOURCE_VERIFICATION_EMAIL_SENT
  ACH_SOURCE_VERIFIED
  BACS_DEBIT_SOURCE_DEBIT_INITIATED_EMAIL_SENT
  BACS_DEBIT_SOURCE_MANDATE_CONFIRMED_EMAIL_SENT
  BACS_DEBIT_SOURCE_MANDATE_CONFIRMED
  BACS_DEBIT_SOURCE_MANDATE_FAILED
  BULK_PRICE_CHANGED
  COMMENT
  COMPLETION
  CONTINUOUS_BILLING_DISABLED
  CONTINUOUS_BILLING_ENABLED
  CONTRACT_AWAITING_ACCEPTANCE_CLIENT_NOTIFICATION_REMINDER_SENT
  CONTRACT_AWAITING_ACCEPTANCE_CLIENT_NOTIFICATION_SENT
  CREATION
  CREDIT_CARD_EXPIRING
  DELETION
  EDIT_SERVICE_OFFERING
  EMAIL_BOUNCE
  EMAIL_OPEN
  EMAIL_SEND
  ENGAGEMENT_LETTER_CREATED
  GROUP_EMAIL_SEND
  INVOICE_DEPLOY
  INVOICE_ERROR
  INVOICE_NOTIFICATION_SENT
  INVOICE_ON_COMPLETION
  INVOICE_RECONCILED
  INVOICE_RECONCILIATION_FAILURE
  INVOICE_REDEPLOYED
  JOB_DEPLOY
  MARK_AS_ACTIVE
  MARK_AS_LOST
  MOVE_TO_DRAFT
  MOVE_TO_SENT
  PAYMENT_AUTHENTICATION_REQUIRED
  PAYMENT_COLLECTED_NOTIFICATION_SENT
  PAYMENT_COLLECTION
  PAYMENT_DISABLED
  PAYMENT_DISBURSAL
  PAYMENT_ENABLED
  PAYMENT_METHOD_CHANGED
  PAYMENT_METHOD_REMOVED
  PAYMENT_PENDING_VERIFICATION
  PAYMENT_REJECTION
  PAYMENT_RETRIED_BY_CLIENT
  PROPOSAL_BULK_SEND
  QUEUE
  REVOCATION
  ROLL_OVER
}

type WorkflowCategoryType {
  app: App!
  externalId: ID!
  id: ID!
  name: String!
}

"""The connection type for WorkflowCategoryType."""
type WorkflowCategoryTypeConnection {
  """A list of edges."""
  edges: [WorkflowCategoryTypeEdge!]!

  """A list of nodes."""
  nodes: [WorkflowCategoryType!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type WorkflowCategoryTypeEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: WorkflowCategoryType!
}

type WorkflowSettings {
  appName: String
  createdAt: DateTime!
  deployStrategy: ProposalWorkflowSettingsDeployStrategy
  id: ID!
  lockVersion: Int!
  updatedAt: DateTime!
  workflowStructure: ProposalWorkflowSettingsWorkflowStructure
}

type WorkflowStrategy {
  appName: String!

  """
  The billing group assigned to this workflow.

  When invoices are issued with this billing group, the credits will be applied
  to this workflow strategy.

  """
  billingGroup: ProposalBillingGroup
  billingReference: String
  budget: Money
  categories: [WorkflowCategoryType!]
  createdAt: DateTime!
  delay: Duration
  description: String
  duration: Duration
  id: ID!
  lockVersion: Int!
  manager: User
  name: String
  partner: User
  recurrenceRule: RecurrenceRule
  recurrenceType: ProposalWorkflowStrategyRecurrenceType
  staff: [User!]!
  startDate: Date
  startType: ProposalWorkflowStrategyStartType
  templates: [WorkflowTemplateType!]
  updatedAt: DateTime!
}

"""Input type for Capabilities Workflow Template Mappings."""
input WorkflowTemplateMappingsInput {
  """Workflow Templates Ids."""
  workflowTemplateIds: [ID!]!

  """Workflow Template App"""
  appName: String!
}

type WorkflowTemplateType {
  app: App!
  externalId: ID!
  id: ID!
  name: String!
}

"""The connection type for WorkflowTemplateType."""
type WorkflowTemplateTypeConnection {
  """A list of edges."""
  edges: [WorkflowTemplateTypeEdge!]!

  """A list of nodes."""
  nodes: [WorkflowTemplateType!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type WorkflowTemplateTypeEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: WorkflowTemplateType!
}

input WorkTemplateMappingInput {
  serviceId: ID!
  workTemplateId: ID!
}

type Xero {
  """Branding theme when payment is collected by Ignition"""
  defaultBrandingTheme: XeroBrandingTheme
  defaultInvoiceState: String
  defaultSalesAccount: Account
  defaultTerms: Int

  """Automatically create invoices in Xero"""
  deployInvoices: Boolean
  id: ID!

  """Branding theme when payment is arranged manually"""
  recurringBrandingTheme: XeroBrandingTheme
  recurringTerms: Int

  """Xero Repeating Invoices search results"""
  repeatingInvoicesSearch(nameContains: String, includeDeleted: Boolean, pagination: PaginationInput, sort: SearchQuerySortInput, asyncJobGroupId: ID, filterWithConversionErrors: Boolean): SearchQuery
  state: XeroState! @deprecated(reason: "Use apps() query and its userConfiguration.state instead.")
  syncClientName: Boolean
  taxRateMappings(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): XeroTaxRateMappingConnectionType
  taxRates: [TaxRate!]
  trackingCategories: [XeroTrackingCategory!]
}

type XeroBrandingTheme {
  createdAt: DateTime!
  id: ID!
  name: String!
  updatedAt: DateTime!
  uuid: ID! @deprecated(reason: "Use id instead")
}

"""The connection type for XeroBrandingTheme."""
type XeroBrandingThemeConnection {
  """A list of edges."""
  edges: [XeroBrandingThemeEdge!]!

  """A list of nodes."""
  nodes: [XeroBrandingTheme!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type XeroBrandingThemeEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: XeroBrandingTheme!
}

type XeroIntegrationLineItem {
  """Whether or not the repeating invoice line item was deleted."""
  deleted: Boolean

  """Description of the line item"""
  description: String!

  """Discount amount"""
  discountAmount: Money!

  """Discount rate"""
  discountRate: Float

  """Internal slug of the repeating invoice line item"""
  id: ID!

  """Item code"""
  itemCode: String

  """Name of associated item (if present)"""
  itemName: String

  """Line amount"""
  lineAmount: Money!

  """Quantity"""
  quantity: Float

  """Tax amount"""
  taxAmount: Money!

  """Tax Type"""
  taxType: String

  """Unit amount"""
  unitAmount: Money!
}

type XeroIntegrationRepeatingInvoice {
  """List of jobs associated with the repeating invoice"""
  asyncJobs: [AsyncJob!]

  """Name of the Contact associated with the repeating invoice"""
  contactName: String

  """Whether or not the repeating invoice was deleted."""
  deleted: Boolean

  """When do we finish invoicing (optional)"""
  endDate: Date

  """External URL for repeating invoice"""
  externalUrl: String

  """Internal slug of the repeating invoice"""
  id: ID!

  """List of Xero Repeating Invoice Line Items"""
  lineItems: [XeroIntegrationLineItem!]

  """When is the next invoice being generated"""
  nextScheduledDate: Date!

  """Weekly or monthly frequency"""
  period: Int!

  """Total cost"""
  total: Money!

  """WEEKLY or MONTHLY"""
  unit: String!

  """Customer added string to refer to the repeating invoice"""
  xeroReference: String

  """External Xero ID of the repeating invoice"""
  xeroRepeatingInvoiceId: String!
}

"""Autogenerated return type of xeroRepeatingInvoiceStopRemoteFailed."""
type xeroRepeatingInvoiceStopRemoteFailedPayload {
  """The associated proposal"""
  proposal: Proposal!

  """The repeating invoice which throws an error when we try to stop it"""
  repeatingInvoice: XeroIntegrationRepeatingInvoice!
}

enum XeroState {
  INACTIVE
  ACTIVE
  DISCONNECTED
  UNAVAILABLE
}

"""The connection type for TaxRateMapping."""
type XeroTaxRateMappingConnectionType {
  areAllMapped: Boolean!

  """A list of edges."""
  edges: [TaxRateMappingEdge!]!

  """A list of nodes."""
  nodes: [TaxRateMapping!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of XeroTaxRateMappingCreate"""
input XeroTaxRateMappingCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """UUID of pi tax"""
  ignitionappTaxId: ID!

  """UUID of tax rate"""
  taxRateId: ID!
}

"""Autogenerated return type of XeroTaxRateMappingCreate."""
type XeroTaxRateMappingCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  xero: Xero
}

input XeroTaxRateMappingInput {
  """UUID of PI Tax"""
  ignitionappTaxId: ID!

  """UUID of Tax Rate"""
  taxRateId: ID!
}

"""Autogenerated input type of XeroTaxRateMappingsUpdate"""
input XeroTaxRateMappingsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  mappings: [XeroTaxRateMappingInput!]!
}

"""Autogenerated return type of XeroTaxRateMappingsUpdate."""
type XeroTaxRateMappingsUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  xero: Xero
}

"""A Xero tracking category"""
type XeroTrackingCategory {
  """The available options for this tracking category"""
  availableOptions: [XeroTrackingCategoryOption!]!

  """Id of the category from Xero"""
  id: ID!

  """Name of the category from Xero"""
  name: String!

  """The tracking option that has been selected for this client"""
  selectedOption: XeroTrackingCategoryOption
}

"""A Xero tracking category option"""
type XeroTrackingCategoryOption {
  """The id of this option from Xero"""
  id: String!

  """The name of the tracking option (as created in Xero at the last sync)"""
  name: String!
}

type XPM {
  id: ID!
  lastSynced: DateTime
  referenceNumber: ID!
  state: XPMState!
}

enum XPMState {
  AUTHORISED
  CONNECTED
  DISCONNECTED
  UNAUTHORISED
}

